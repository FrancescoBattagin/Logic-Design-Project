--test # 1

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 129 , 8)),
				 2 => std_logic_vector(to_unsigned( 221 , 8)),
				 3 => std_logic_vector(to_unsigned( 183 , 8)),
				 4 => std_logic_vector(to_unsigned( 167 , 8)),
				 5 => std_logic_vector(to_unsigned( 194 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 115 , 8)),
				 9 => std_logic_vector(to_unsigned( 61 , 8)),
				 10 => std_logic_vector(to_unsigned( 137 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 14 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 194 , 8)),
				 15 => std_logic_vector(to_unsigned( 235 , 8)),
				 16 => std_logic_vector(to_unsigned( 92 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 2

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 157 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 63 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 187 , 8)),
				 8 => std_logic_vector(to_unsigned( 201 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 251 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 235 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 234 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 234 , 8)),
				 17 => std_logic_vector(to_unsigned( 47 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 3

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 177 , 8)),
				 2 => std_logic_vector(to_unsigned( 188 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 142 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 137 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 113 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 112 , 8)),
				 13 => std_logic_vector(to_unsigned( 186 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 205 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 4

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 82 , 8)),
				 2 => std_logic_vector(to_unsigned( 82 , 8)),
				 3 => std_logic_vector(to_unsigned( 149 , 8)),
				 4 => std_logic_vector(to_unsigned( 15 , 8)),
				 5 => std_logic_vector(to_unsigned( 157 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 6 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 169 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 33 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 179 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 5

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 151 , 8)),
				 1 => std_logic_vector(to_unsigned( 36 , 8)),
				 2 => std_logic_vector(to_unsigned( 231 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 50 , 8)),
				 5 => std_logic_vector(to_unsigned( 103 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 1 , 8)),
				 8 => std_logic_vector(to_unsigned( 106 , 8)),
				 9 => std_logic_vector(to_unsigned( 151 , 8)),
				 10 => std_logic_vector(to_unsigned( 131 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 52 , 8)),
				 13 => std_logic_vector(to_unsigned( 112 , 8)),
				 14 => std_logic_vector(to_unsigned( 74 , 8)),
				 15 => std_logic_vector(to_unsigned( 121 , 8)),
				 16 => std_logic_vector(to_unsigned( 121 , 8)),
				 17 => std_logic_vector(to_unsigned( 131 , 8)),
				 18 => std_logic_vector(to_unsigned( 234 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 6

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 32 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 90 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 116 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 241 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 233 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 221 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 214 , 8)),
				 15 => std_logic_vector(to_unsigned( 14 , 8)),
				 16 => std_logic_vector(to_unsigned( 30 , 8)),
				 17 => std_logic_vector(to_unsigned( 93 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 7

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 95 , 8)),
				 2 => std_logic_vector(to_unsigned( 157 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 48 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 14 , 8)),
				 13 => std_logic_vector(to_unsigned( 238 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 243 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 133 , 8)),
				 18 => std_logic_vector(to_unsigned( 207 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 8

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 111 , 8)),
				 1 => std_logic_vector(to_unsigned( 66 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 73 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 17 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 30 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 44 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 142 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 153 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 153 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 247 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 9

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 21 , 8)),
				 1 => std_logic_vector(to_unsigned( 91 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 234 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 228 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 104 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 31 , 8)),
				 11 => std_logic_vector(to_unsigned( 178 , 8)),
				 12 => std_logic_vector(to_unsigned( 158 , 8)),
				 13 => std_logic_vector(to_unsigned( 216 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 182 , 8)),
				 18 => std_logic_vector(to_unsigned( 94 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 10

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 87 , 8)),
				 2 => std_logic_vector(to_unsigned( 189 , 8)),
				 3 => std_logic_vector(to_unsigned( 147 , 8)),
				 4 => std_logic_vector(to_unsigned( 129 , 8)),
				 5 => std_logic_vector(to_unsigned( 249 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 148 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 98 , 8)),
				 11 => std_logic_vector(to_unsigned( 65 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 39 , 8)),
				 15 => std_logic_vector(to_unsigned( 147 , 8)),
				 16 => std_logic_vector(to_unsigned( 25 , 8)),
				 17 => std_logic_vector(to_unsigned( 125 , 8)),
				 18 => std_logic_vector(to_unsigned( 255 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 11

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 233 , 8)),
				 2 => std_logic_vector(to_unsigned( 64 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 244 , 8)),
				 6 => std_logic_vector(to_unsigned( 53 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 202 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 246 , 8)),
				 18 => std_logic_vector(to_unsigned( 242 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 12

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 113 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 55 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 158 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 214 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 81 , 8)),
				 13 => std_logic_vector(to_unsigned( 92 , 8)),
				 14 => std_logic_vector(to_unsigned( 75 , 8)),
				 15 => std_logic_vector(to_unsigned( 46 , 8)),
				 16 => std_logic_vector(to_unsigned( 212 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 13

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 198 , 8)),
				 1 => std_logic_vector(to_unsigned( 252 , 8)),
				 2 => std_logic_vector(to_unsigned( 163 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 46 , 8)),
				 5 => std_logic_vector(to_unsigned( 156 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 130 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 59 , 8)),
				 11 => std_logic_vector(to_unsigned( 138 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 180 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 58 , 8)),
				 16 => std_logic_vector(to_unsigned( 88 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 14

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 226 , 8)),
				 1 => std_logic_vector(to_unsigned( 221 , 8)),
				 2 => std_logic_vector(to_unsigned( 231 , 8)),
				 3 => std_logic_vector(to_unsigned( 230 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 244 , 8)),
				 6 => std_logic_vector(to_unsigned( 178 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 149 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 124 , 8)),
				 11 => std_logic_vector(to_unsigned( 184 , 8)),
				 12 => std_logic_vector(to_unsigned( 148 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 110 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 227 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 15

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 20 , 8)),
				 2 => std_logic_vector(to_unsigned( 215 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 160 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 84 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 220 , 8)),
				 16 => std_logic_vector(to_unsigned( 20 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 227 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 16

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 75 , 8)),
				 1 => std_logic_vector(to_unsigned( 250 , 8)),
				 2 => std_logic_vector(to_unsigned( 250 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 248 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 245 , 8)),
				 7 => std_logic_vector(to_unsigned( 103 , 8)),
				 8 => std_logic_vector(to_unsigned( 209 , 8)),
				 9 => std_logic_vector(to_unsigned( 152 , 8)),
				 10 => std_logic_vector(to_unsigned( 160 , 8)),
				 11 => std_logic_vector(to_unsigned( 200 , 8)),
				 12 => std_logic_vector(to_unsigned( 112 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 109 , 8)),
				 15 => std_logic_vector(to_unsigned( 78 , 8)),
				 16 => std_logic_vector(to_unsigned( 44 , 8)),
				 17 => std_logic_vector(to_unsigned( 223 , 8)),
				 18 => std_logic_vector(to_unsigned( 184 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 17

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 25 , 8)),
				 1 => std_logic_vector(to_unsigned( 215 , 8)),
				 2 => std_logic_vector(to_unsigned( 154 , 8)),
				 3 => std_logic_vector(to_unsigned( 142 , 8)),
				 4 => std_logic_vector(to_unsigned( 84 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 65 , 8)),
				 7 => std_logic_vector(to_unsigned( 173 , 8)),
				 8 => std_logic_vector(to_unsigned( 195 , 8)),
				 9 => std_logic_vector(to_unsigned( 101 , 8)),
				 10 => std_logic_vector(to_unsigned( 206 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 60 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 173 , 8)),
				 16 => std_logic_vector(to_unsigned( 171 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 112 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 18

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 143 , 8)),
				 1 => std_logic_vector(to_unsigned( 176 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 188 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 230 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 177 , 8)),
				 11 => std_logic_vector(to_unsigned( 114 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 253 , 8)),
				 18 => std_logic_vector(to_unsigned( 108 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 19

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 120 , 8)),
				 1 => std_logic_vector(to_unsigned( 226 , 8)),
				 2 => std_logic_vector(to_unsigned( 166 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 142 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 17 , 8)),
				 10 => std_logic_vector(to_unsigned( 147 , 8)),
				 11 => std_logic_vector(to_unsigned( 80 , 8)),
				 12 => std_logic_vector(to_unsigned( 84 , 8)),
				 13 => std_logic_vector(to_unsigned( 124 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 28 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 71 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 20

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 233 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 44 , 8)),
				 4 => std_logic_vector(to_unsigned( 180 , 8)),
				 5 => std_logic_vector(to_unsigned( 140 , 8)),
				 6 => std_logic_vector(to_unsigned( 202 , 8)),
				 7 => std_logic_vector(to_unsigned( 216 , 8)),
				 8 => std_logic_vector(to_unsigned( 126 , 8)),
				 9 => std_logic_vector(to_unsigned( 28 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 167 , 8)),
				 12 => std_logic_vector(to_unsigned( 148 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 127 , 8)),
				 15 => std_logic_vector(to_unsigned( 205 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 17 , 8)),
				 18 => std_logic_vector(to_unsigned( 35 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 21

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 101 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 90 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 46 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 59 , 8)),
				 7 => std_logic_vector(to_unsigned( 160 , 8)),
				 8 => std_logic_vector(to_unsigned( 212 , 8)),
				 9 => std_logic_vector(to_unsigned( 190 , 8)),
				 10 => std_logic_vector(to_unsigned( 182 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 118 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 118 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 118 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 22

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 64 , 8)),
				 1 => std_logic_vector(to_unsigned( 68 , 8)),
				 2 => std_logic_vector(to_unsigned( 190 , 8)),
				 3 => std_logic_vector(to_unsigned( 216 , 8)),
				 4 => std_logic_vector(to_unsigned( 88 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 145 , 8)),
				 8 => std_logic_vector(to_unsigned( 97 , 8)),
				 9 => std_logic_vector(to_unsigned( 76 , 8)),
				 10 => std_logic_vector(to_unsigned( 192 , 8)),
				 11 => std_logic_vector(to_unsigned( 143 , 8)),
				 12 => std_logic_vector(to_unsigned( 125 , 8)),
				 13 => std_logic_vector(to_unsigned( 206 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 127 , 8)),
				 18 => std_logic_vector(to_unsigned( 153 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 23

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 122 , 8)),
				 2 => std_logic_vector(to_unsigned( 244 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 14 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 37 , 8)),
				 8 => std_logic_vector(to_unsigned( 14 , 8)),
				 9 => std_logic_vector(to_unsigned( 74 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 18 , 8)),
				 12 => std_logic_vector(to_unsigned( 97 , 8)),
				 13 => std_logic_vector(to_unsigned( 46 , 8)),
				 14 => std_logic_vector(to_unsigned( 69 , 8)),
				 15 => std_logic_vector(to_unsigned( 59 , 8)),
				 16 => std_logic_vector(to_unsigned( 56 , 8)),
				 17 => std_logic_vector(to_unsigned( 202 , 8)),
				 18 => std_logic_vector(to_unsigned( 183 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 24

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 90 , 8)),
				 1 => std_logic_vector(to_unsigned( 7 , 8)),
				 2 => std_logic_vector(to_unsigned( 74 , 8)),
				 3 => std_logic_vector(to_unsigned( 66 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 70 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 77 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 61 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 44 , 8)),
				 18 => std_logic_vector(to_unsigned( 175 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 25

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 173 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 8 , 8)),
				 5 => std_logic_vector(to_unsigned( 189 , 8)),
				 6 => std_logic_vector(to_unsigned( 93 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 113 , 8)),
				 9 => std_logic_vector(to_unsigned( 13 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 66 , 8)),
				 13 => std_logic_vector(to_unsigned( 81 , 8)),
				 14 => std_logic_vector(to_unsigned( 42 , 8)),
				 15 => std_logic_vector(to_unsigned( 175 , 8)),
				 16 => std_logic_vector(to_unsigned( 61 , 8)),
				 17 => std_logic_vector(to_unsigned( 148 , 8)),
				 18 => std_logic_vector(to_unsigned( 54 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 26

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 82 , 8)),
				 1 => std_logic_vector(to_unsigned( 123 , 8)),
				 2 => std_logic_vector(to_unsigned( 83 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 68 , 8)),
				 5 => std_logic_vector(to_unsigned( 220 , 8)),
				 6 => std_logic_vector(to_unsigned( 228 , 8)),
				 7 => std_logic_vector(to_unsigned( 50 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 99 , 8)),
				 11 => std_logic_vector(to_unsigned( 3 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 227 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 25 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 37 , 8)),
				 18 => std_logic_vector(to_unsigned( 59 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 27

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 165 , 8)),
				 1 => std_logic_vector(to_unsigned( 231 , 8)),
				 2 => std_logic_vector(to_unsigned( 38 , 8)),
				 3 => std_logic_vector(to_unsigned( 90 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 111 , 8)),
				 9 => std_logic_vector(to_unsigned( 67 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 92 , 8)),
				 12 => std_logic_vector(to_unsigned( 135 , 8)),
				 13 => std_logic_vector(to_unsigned( 140 , 8)),
				 14 => std_logic_vector(to_unsigned( 87 , 8)),
				 15 => std_logic_vector(to_unsigned( 139 , 8)),
				 16 => std_logic_vector(to_unsigned( 213 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 28

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 70 , 8)),
				 1 => std_logic_vector(to_unsigned( 60 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 195 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 67 , 8)),
				 6 => std_logic_vector(to_unsigned( 199 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 134 , 8)),
				 9 => std_logic_vector(to_unsigned( 171 , 8)),
				 10 => std_logic_vector(to_unsigned( 63 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 107 , 8)),
				 14 => std_logic_vector(to_unsigned( 31 , 8)),
				 15 => std_logic_vector(to_unsigned( 117 , 8)),
				 16 => std_logic_vector(to_unsigned( 21 , 8)),
				 17 => std_logic_vector(to_unsigned( 198 , 8)),
				 18 => std_logic_vector(to_unsigned( 224 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 29

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 44 , 8)),
				 1 => std_logic_vector(to_unsigned( 141 , 8)),
				 2 => std_logic_vector(to_unsigned( 100 , 8)),
				 3 => std_logic_vector(to_unsigned( 31 , 8)),
				 4 => std_logic_vector(to_unsigned( 168 , 8)),
				 5 => std_logic_vector(to_unsigned( 37 , 8)),
				 6 => std_logic_vector(to_unsigned( 162 , 8)),
				 7 => std_logic_vector(to_unsigned( 99 , 8)),
				 8 => std_logic_vector(to_unsigned( 100 , 8)),
				 9 => std_logic_vector(to_unsigned( 2 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 96 , 8)),
				 12 => std_logic_vector(to_unsigned( 255 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 37 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 182 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 30

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 186 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 72 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 80 , 8)),
				 7 => std_logic_vector(to_unsigned( 117 , 8)),
				 8 => std_logic_vector(to_unsigned( 77 , 8)),
				 9 => std_logic_vector(to_unsigned( 160 , 8)),
				 10 => std_logic_vector(to_unsigned( 34 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 151 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 150 , 8)),
				 15 => std_logic_vector(to_unsigned( 154 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 58 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 31

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 71 , 8)),
				 4 => std_logic_vector(to_unsigned( 242 , 8)),
				 5 => std_logic_vector(to_unsigned( 100 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 147 , 8)),
				 8 => std_logic_vector(to_unsigned( 166 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 158 , 8)),
				 11 => std_logic_vector(to_unsigned( 169 , 8)),
				 12 => std_logic_vector(to_unsigned( 205 , 8)),
				 13 => std_logic_vector(to_unsigned( 169 , 8)),
				 14 => std_logic_vector(to_unsigned( 205 , 8)),
				 15 => std_logic_vector(to_unsigned( 52 , 8)),
				 16 => std_logic_vector(to_unsigned( 193 , 8)),
				 17 => std_logic_vector(to_unsigned( 51 , 8)),
				 18 => std_logic_vector(to_unsigned( 148 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 32

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 134 , 8)),
				 1 => std_logic_vector(to_unsigned( 226 , 8)),
				 2 => std_logic_vector(to_unsigned( 62 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 48 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 200 , 8)),
				 12 => std_logic_vector(to_unsigned( 135 , 8)),
				 13 => std_logic_vector(to_unsigned( 113 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 124 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 115 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 33

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 117 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 148 , 8)),
				 3 => std_logic_vector(to_unsigned( 148 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 72 , 8)),
				 6 => std_logic_vector(to_unsigned( 41 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 241 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 208 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 175 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 217 , 8)),
				 15 => std_logic_vector(to_unsigned( 26 , 8)),
				 16 => std_logic_vector(to_unsigned( 145 , 8)),
				 17 => std_logic_vector(to_unsigned( 95 , 8)),
				 18 => std_logic_vector(to_unsigned( 7 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 34

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 197 , 8)),
				 1 => std_logic_vector(to_unsigned( 172 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 131 , 8)),
				 4 => std_logic_vector(to_unsigned( 185 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 193 , 8)),
				 7 => std_logic_vector(to_unsigned( 101 , 8)),
				 8 => std_logic_vector(to_unsigned( 135 , 8)),
				 9 => std_logic_vector(to_unsigned( 48 , 8)),
				 10 => std_logic_vector(to_unsigned( 37 , 8)),
				 11 => std_logic_vector(to_unsigned( 54 , 8)),
				 12 => std_logic_vector(to_unsigned( 31 , 8)),
				 13 => std_logic_vector(to_unsigned( 70 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 73 , 8)),
				 16 => std_logic_vector(to_unsigned( 12 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 35

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 10 , 8)),
				 3 => std_logic_vector(to_unsigned( 111 , 8)),
				 4 => std_logic_vector(to_unsigned( 33 , 8)),
				 5 => std_logic_vector(to_unsigned( 133 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 3 , 8)),
				 12 => std_logic_vector(to_unsigned( 59 , 8)),
				 13 => std_logic_vector(to_unsigned( 219 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 11 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 36

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 153 , 8)),
				 2 => std_logic_vector(to_unsigned( 203 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 177 , 8)),
				 6 => std_logic_vector(to_unsigned( 72 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 230 , 8)),
				 10 => std_logic_vector(to_unsigned( 19 , 8)),
				 11 => std_logic_vector(to_unsigned( 30 , 8)),
				 12 => std_logic_vector(to_unsigned( 128 , 8)),
				 13 => std_logic_vector(to_unsigned( 130 , 8)),
				 14 => std_logic_vector(to_unsigned( 219 , 8)),
				 15 => std_logic_vector(to_unsigned( 212 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 49 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 37

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 95 , 8)),
				 3 => std_logic_vector(to_unsigned( 206 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 26 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 11 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 194 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 78 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 77 , 8)),
				 17 => std_logic_vector(to_unsigned( 118 , 8)),
				 18 => std_logic_vector(to_unsigned( 118 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 38

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 12 , 8)),
				 2 => std_logic_vector(to_unsigned( 237 , 8)),
				 3 => std_logic_vector(to_unsigned( 191 , 8)),
				 4 => std_logic_vector(to_unsigned( 229 , 8)),
				 5 => std_logic_vector(to_unsigned( 212 , 8)),
				 6 => std_logic_vector(to_unsigned( 208 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 180 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 125 , 8)),
				 12 => std_logic_vector(to_unsigned( 56 , 8)),
				 13 => std_logic_vector(to_unsigned( 21 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 52 , 8)),
				 16 => std_logic_vector(to_unsigned( 89 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 46 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 39

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 220 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 188 , 8)),
				 3 => std_logic_vector(to_unsigned( 26 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 71 , 8)),
				 6 => std_logic_vector(to_unsigned( 147 , 8)),
				 7 => std_logic_vector(to_unsigned( 182 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 202 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 213 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 175 , 8)),
				 15 => std_logic_vector(to_unsigned( 190 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 215 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 40

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 216 , 8)),
				 3 => std_logic_vector(to_unsigned( 100 , 8)),
				 4 => std_logic_vector(to_unsigned( 200 , 8)),
				 5 => std_logic_vector(to_unsigned( 214 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 54 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 106 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 110 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 168 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 41

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 13 , 8)),
				 1 => std_logic_vector(to_unsigned( 20 , 8)),
				 2 => std_logic_vector(to_unsigned( 79 , 8)),
				 3 => std_logic_vector(to_unsigned( 44 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 118 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 24 , 8)),
				 8 => std_logic_vector(to_unsigned( 40 , 8)),
				 9 => std_logic_vector(to_unsigned( 59 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 99 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 219 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 230 , 8)),
				 17 => std_logic_vector(to_unsigned( 194 , 8)),
				 18 => std_logic_vector(to_unsigned( 16 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 42

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 73 , 8)),
				 2 => std_logic_vector(to_unsigned( 196 , 8)),
				 3 => std_logic_vector(to_unsigned( 148 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 198 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 29 , 8)),
				 9 => std_logic_vector(to_unsigned( 161 , 8)),
				 10 => std_logic_vector(to_unsigned( 242 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 151 , 8)),
				 13 => std_logic_vector(to_unsigned( 169 , 8)),
				 14 => std_logic_vector(to_unsigned( 22 , 8)),
				 15 => std_logic_vector(to_unsigned( 170 , 8)),
				 16 => std_logic_vector(to_unsigned( 21 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 174 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 43

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 36 , 8)),
				 1 => std_logic_vector(to_unsigned( 44 , 8)),
				 2 => std_logic_vector(to_unsigned( 142 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 78 , 8)),
				 9 => std_logic_vector(to_unsigned( 93 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 116 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 234 , 8)),
				 15 => std_logic_vector(to_unsigned( 153 , 8)),
				 16 => std_logic_vector(to_unsigned( 200 , 8)),
				 17 => std_logic_vector(to_unsigned( 144 , 8)),
				 18 => std_logic_vector(to_unsigned( 120 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 44

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 173 , 8)),
				 1 => std_logic_vector(to_unsigned( 95 , 8)),
				 2 => std_logic_vector(to_unsigned( 16 , 8)),
				 3 => std_logic_vector(to_unsigned( 109 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 109 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 110 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 7 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 121 , 8)),
				 16 => std_logic_vector(to_unsigned( 38 , 8)),
				 17 => std_logic_vector(to_unsigned( 84 , 8)),
				 18 => std_logic_vector(to_unsigned( 144 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 45

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 98 , 8)),
				 1 => std_logic_vector(to_unsigned( 83 , 8)),
				 2 => std_logic_vector(to_unsigned( 237 , 8)),
				 3 => std_logic_vector(to_unsigned( 143 , 8)),
				 4 => std_logic_vector(to_unsigned( 102 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 20 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 250 , 8)),
				 13 => std_logic_vector(to_unsigned( 173 , 8)),
				 14 => std_logic_vector(to_unsigned( 116 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 55 , 8)),
				 17 => std_logic_vector(to_unsigned( 172 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 46

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 9 , 8)),
				 1 => std_logic_vector(to_unsigned( 30 , 8)),
				 2 => std_logic_vector(to_unsigned( 31 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 14 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 29 , 8)),
				 8 => std_logic_vector(to_unsigned( 31 , 8)),
				 9 => std_logic_vector(to_unsigned( 124 , 8)),
				 10 => std_logic_vector(to_unsigned( 200 , 8)),
				 11 => std_logic_vector(to_unsigned( 127 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 131 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 88 , 8)),
				 17 => std_logic_vector(to_unsigned( 5 , 8)),
				 18 => std_logic_vector(to_unsigned( 63 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 47

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 234 , 8)),
				 1 => std_logic_vector(to_unsigned( 170 , 8)),
				 2 => std_logic_vector(to_unsigned( 141 , 8)),
				 3 => std_logic_vector(to_unsigned( 199 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 44 , 8)),
				 8 => std_logic_vector(to_unsigned( 181 , 8)),
				 9 => std_logic_vector(to_unsigned( 189 , 8)),
				 10 => std_logic_vector(to_unsigned( 58 , 8)),
				 11 => std_logic_vector(to_unsigned( 213 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 21 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 14 , 8)),
				 17 => std_logic_vector(to_unsigned( 138 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 48

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 167 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 105 , 8)),
				 5 => std_logic_vector(to_unsigned( 156 , 8)),
				 6 => std_logic_vector(to_unsigned( 74 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 69 , 8)),
				 9 => std_logic_vector(to_unsigned( 19 , 8)),
				 10 => std_logic_vector(to_unsigned( 157 , 8)),
				 11 => std_logic_vector(to_unsigned( 62 , 8)),
				 12 => std_logic_vector(to_unsigned( 163 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 49

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 0 , 8)),
				 1 => std_logic_vector(to_unsigned( 113 , 8)),
				 2 => std_logic_vector(to_unsigned( 74 , 8)),
				 3 => std_logic_vector(to_unsigned( 50 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 51 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 195 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 145 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 146 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 146 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 114 , 8)),
				 18 => std_logic_vector(to_unsigned( 143 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 0 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 50

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 130 , 8)),
				 2 => std_logic_vector(to_unsigned( 176 , 8)),
				 3 => std_logic_vector(to_unsigned( 223 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 78 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 185 , 8)),
				 8 => std_logic_vector(to_unsigned( 163 , 8)),
				 9 => std_logic_vector(to_unsigned( 14 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 136 , 8)),
				 12 => std_logic_vector(to_unsigned( 35 , 8)),
				 13 => std_logic_vector(to_unsigned( 163 , 8)),
				 14 => std_logic_vector(to_unsigned( 93 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 165 , 8)),
				 18 => std_logic_vector(to_unsigned( 196 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 51

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 32 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 9 , 8)),
				 3 => std_logic_vector(to_unsigned( 149 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 175 , 8)),
				 8 => std_logic_vector(to_unsigned( 167 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 124 , 8)),
				 11 => std_logic_vector(to_unsigned( 196 , 8)),
				 12 => std_logic_vector(to_unsigned( 102 , 8)),
				 13 => std_logic_vector(to_unsigned( 26 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 107 , 8)),
				 16 => std_logic_vector(to_unsigned( 209 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 52

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 82 , 8)),
				 1 => std_logic_vector(to_unsigned( 83 , 8)),
				 2 => std_logic_vector(to_unsigned( 75 , 8)),
				 3 => std_logic_vector(to_unsigned( 12 , 8)),
				 4 => std_logic_vector(to_unsigned( 54 , 8)),
				 5 => std_logic_vector(to_unsigned( 52 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 251 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 241 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 233 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 214 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 37 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 53

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 74 , 8)),
				 2 => std_logic_vector(to_unsigned( 93 , 8)),
				 3 => std_logic_vector(to_unsigned( 103 , 8)),
				 4 => std_logic_vector(to_unsigned( 64 , 8)),
				 5 => std_logic_vector(to_unsigned( 53 , 8)),
				 6 => std_logic_vector(to_unsigned( 38 , 8)),
				 7 => std_logic_vector(to_unsigned( 150 , 8)),
				 8 => std_logic_vector(to_unsigned( 68 , 8)),
				 9 => std_logic_vector(to_unsigned( 102 , 8)),
				 10 => std_logic_vector(to_unsigned( 43 , 8)),
				 11 => std_logic_vector(to_unsigned( 103 , 8)),
				 12 => std_logic_vector(to_unsigned( 90 , 8)),
				 13 => std_logic_vector(to_unsigned( 89 , 8)),
				 14 => std_logic_vector(to_unsigned( 34 , 8)),
				 15 => std_logic_vector(to_unsigned( 33 , 8)),
				 16 => std_logic_vector(to_unsigned( 187 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 230 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 54

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 154 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 160 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 190 , 8)),
				 6 => std_logic_vector(to_unsigned( 45 , 8)),
				 7 => std_logic_vector(to_unsigned( 72 , 8)),
				 8 => std_logic_vector(to_unsigned( 59 , 8)),
				 9 => std_logic_vector(to_unsigned( 117 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 184 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 156 , 8)),
				 15 => std_logic_vector(to_unsigned( 68 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 115 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 55

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 30 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 193 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 254 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 243 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 144 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 147 , 8)),
				 12 => std_logic_vector(to_unsigned( 43 , 8)),
				 13 => std_logic_vector(to_unsigned( 25 , 8)),
				 14 => std_logic_vector(to_unsigned( 88 , 8)),
				 15 => std_logic_vector(to_unsigned( 108 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 130 , 8)),
				 18 => std_logic_vector(to_unsigned( 142 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 56

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 221 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 250 , 8)),
				 5 => std_logic_vector(to_unsigned( 132 , 8)),
				 6 => std_logic_vector(to_unsigned( 190 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 70 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 69 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 68 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 252 , 8)),
				 17 => std_logic_vector(to_unsigned( 87 , 8)),
				 18 => std_logic_vector(to_unsigned( 254 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 57

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 38 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 187 , 8)),
				 3 => std_logic_vector(to_unsigned( 89 , 8)),
				 4 => std_logic_vector(to_unsigned( 25 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 114 , 8)),
				 8 => std_logic_vector(to_unsigned( 215 , 8)),
				 9 => std_logic_vector(to_unsigned( 165 , 8)),
				 10 => std_logic_vector(to_unsigned( 164 , 8)),
				 11 => std_logic_vector(to_unsigned( 190 , 8)),
				 12 => std_logic_vector(to_unsigned( 139 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 92 , 8)),
				 15 => std_logic_vector(to_unsigned( 62 , 8)),
				 16 => std_logic_vector(to_unsigned( 27 , 8)),
				 17 => std_logic_vector(to_unsigned( 78 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 58

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 69 , 8)),
				 2 => std_logic_vector(to_unsigned( 219 , 8)),
				 3 => std_logic_vector(to_unsigned( 245 , 8)),
				 4 => std_logic_vector(to_unsigned( 74 , 8)),
				 5 => std_logic_vector(to_unsigned( 82 , 8)),
				 6 => std_logic_vector(to_unsigned( 0 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 95 , 8)),
				 10 => std_logic_vector(to_unsigned( 156 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 243 , 8)),
				 15 => std_logic_vector(to_unsigned( 205 , 8)),
				 16 => std_logic_vector(to_unsigned( 100 , 8)),
				 17 => std_logic_vector(to_unsigned( 193 , 8)),
				 18 => std_logic_vector(to_unsigned( 31 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 59

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 201 , 8)),
				 2 => std_logic_vector(to_unsigned( 140 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 113 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 96 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 88 , 8)),
				 9 => std_logic_vector(to_unsigned( 105 , 8)),
				 10 => std_logic_vector(to_unsigned( 187 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 62 , 8)),
				 13 => std_logic_vector(to_unsigned( 1 , 8)),
				 14 => std_logic_vector(to_unsigned( 16 , 8)),
				 15 => std_logic_vector(to_unsigned( 2 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 181 , 8)),
				 18 => std_logic_vector(to_unsigned( 116 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 60

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 108 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 123 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 43 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 102 , 8)),
				 18 => std_logic_vector(to_unsigned( 229 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 61

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 120 , 8)),
				 1 => std_logic_vector(to_unsigned( 226 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 0 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 12 , 8)),
				 6 => std_logic_vector(to_unsigned( 242 , 8)),
				 7 => std_logic_vector(to_unsigned( 108 , 8)),
				 8 => std_logic_vector(to_unsigned( 146 , 8)),
				 9 => std_logic_vector(to_unsigned( 130 , 8)),
				 10 => std_logic_vector(to_unsigned( 124 , 8)),
				 11 => std_logic_vector(to_unsigned( 207 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 191 , 8)),
				 14 => std_logic_vector(to_unsigned( 188 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 153 , 8)),
				 17 => std_logic_vector(to_unsigned( 197 , 8)),
				 18 => std_logic_vector(to_unsigned( 163 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 62

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 73 , 8)),
				 1 => std_logic_vector(to_unsigned( 211 , 8)),
				 2 => std_logic_vector(to_unsigned( 166 , 8)),
				 3 => std_logic_vector(to_unsigned( 175 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 222 , 8)),
				 6 => std_logic_vector(to_unsigned( 43 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 30 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 200 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 192 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 98 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 72 , 8)),
				 17 => std_logic_vector(to_unsigned( 95 , 8)),
				 18 => std_logic_vector(to_unsigned( 81 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 63

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 41 , 8)),
				 1 => std_logic_vector(to_unsigned( 59 , 8)),
				 2 => std_logic_vector(to_unsigned( 253 , 8)),
				 3 => std_logic_vector(to_unsigned( 158 , 8)),
				 4 => std_logic_vector(to_unsigned( 154 , 8)),
				 5 => std_logic_vector(to_unsigned( 226 , 8)),
				 6 => std_logic_vector(to_unsigned( 226 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 163 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 165 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 123 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 85 , 8)),
				 18 => std_logic_vector(to_unsigned( 143 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 64

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 38 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 225 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 192 , 8)),
				 7 => std_logic_vector(to_unsigned( 72 , 8)),
				 8 => std_logic_vector(to_unsigned( 124 , 8)),
				 9 => std_logic_vector(to_unsigned( 219 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 149 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 143 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 143 , 8)),
				 17 => std_logic_vector(to_unsigned( 250 , 8)),
				 18 => std_logic_vector(to_unsigned( 227 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 65

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 158 , 8)),
				 1 => std_logic_vector(to_unsigned( 244 , 8)),
				 2 => std_logic_vector(to_unsigned( 200 , 8)),
				 3 => std_logic_vector(to_unsigned( 245 , 8)),
				 4 => std_logic_vector(to_unsigned( 199 , 8)),
				 5 => std_logic_vector(to_unsigned( 203 , 8)),
				 6 => std_logic_vector(to_unsigned( 133 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 158 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 164 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 98 , 8)),
				 16 => std_logic_vector(to_unsigned( 138 , 8)),
				 17 => std_logic_vector(to_unsigned( 183 , 8)),
				 18 => std_logic_vector(to_unsigned( 68 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 66

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 246 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 163 , 8)),
				 3 => std_logic_vector(to_unsigned( 74 , 8)),
				 4 => std_logic_vector(to_unsigned( 243 , 8)),
				 5 => std_logic_vector(to_unsigned( 211 , 8)),
				 6 => std_logic_vector(to_unsigned( 106 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 105 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 63 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 63 , 8)),
				 13 => std_logic_vector(to_unsigned( 219 , 8)),
				 14 => std_logic_vector(to_unsigned( 178 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 144 , 8)),
				 17 => std_logic_vector(to_unsigned( 142 , 8)),
				 18 => std_logic_vector(to_unsigned( 47 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 52 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 67

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 28 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 38 , 8)),
				 5 => std_logic_vector(to_unsigned( 65 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 68 , 8)),
				 8 => std_logic_vector(to_unsigned( 13 , 8)),
				 9 => std_logic_vector(to_unsigned( 111 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 38 , 8)),
				 12 => std_logic_vector(to_unsigned( 109 , 8)),
				 13 => std_logic_vector(to_unsigned( 96 , 8)),
				 14 => std_logic_vector(to_unsigned( 51 , 8)),
				 15 => std_logic_vector(to_unsigned( 111 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 162 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 68

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 115 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 133 , 8)),
				 5 => std_logic_vector(to_unsigned( 15 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 179 , 8)),
				 8 => std_logic_vector(to_unsigned( 91 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 59 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 215 , 8)),
				 14 => std_logic_vector(to_unsigned( 169 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 188 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 69

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 148 , 8)),
				 1 => std_logic_vector(to_unsigned( 248 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 63 , 8)),
				 4 => std_logic_vector(to_unsigned( 226 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 85 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 113 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 115 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 85 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 119 , 8)),
				 16 => std_logic_vector(to_unsigned( 90 , 8)),
				 17 => std_logic_vector(to_unsigned( 4 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 70

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 248 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 220 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 82 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 194 , 8)),
				 10 => std_logic_vector(to_unsigned( 129 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 74 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 72 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 72 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 11 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 240 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 71

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 221 , 8)),
				 1 => std_logic_vector(to_unsigned( 133 , 8)),
				 2 => std_logic_vector(to_unsigned( 152 , 8)),
				 3 => std_logic_vector(to_unsigned( 159 , 8)),
				 4 => std_logic_vector(to_unsigned( 202 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 157 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 202 , 8)),
				 9 => std_logic_vector(to_unsigned( 38 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 29 , 8)),
				 13 => std_logic_vector(to_unsigned( 144 , 8)),
				 14 => std_logic_vector(to_unsigned( 20 , 8)),
				 15 => std_logic_vector(to_unsigned( 104 , 8)),
				 16 => std_logic_vector(to_unsigned( 156 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 250 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 72

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 130 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 47 , 8)),
				 4 => std_logic_vector(to_unsigned( 238 , 8)),
				 5 => std_logic_vector(to_unsigned( 142 , 8)),
				 6 => std_logic_vector(to_unsigned( 143 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 192 , 8)),
				 9 => std_logic_vector(to_unsigned( 83 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 85 , 8)),
				 12 => std_logic_vector(to_unsigned( 44 , 8)),
				 13 => std_logic_vector(to_unsigned( 127 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 155 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 87 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 73

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 109 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 10 , 8)),
				 4 => std_logic_vector(to_unsigned( 245 , 8)),
				 5 => std_logic_vector(to_unsigned( 198 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 198 , 8)),
				 8 => std_logic_vector(to_unsigned( 57 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 23 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 42 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 138 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 4 , 8)),
				 18 => std_logic_vector(to_unsigned( 203 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 74

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 142 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 223 , 8)),
				 4 => std_logic_vector(to_unsigned( 69 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 41 , 8)),
				 7 => std_logic_vector(to_unsigned( 110 , 8)),
				 8 => std_logic_vector(to_unsigned( 133 , 8)),
				 9 => std_logic_vector(to_unsigned( 117 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 186 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 145 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 140 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 75

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 148 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 156 , 8)),
				 4 => std_logic_vector(to_unsigned( 65 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 67 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 11 , 8)),
				 9 => std_logic_vector(to_unsigned( 117 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 123 , 8)),
				 12 => std_logic_vector(to_unsigned( 68 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 52 , 8)),
				 15 => std_logic_vector(to_unsigned( 149 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 68 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 76

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 151 , 8)),
				 1 => std_logic_vector(to_unsigned( 21 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 245 , 8)),
				 4 => std_logic_vector(to_unsigned( 84 , 8)),
				 5 => std_logic_vector(to_unsigned( 153 , 8)),
				 6 => std_logic_vector(to_unsigned( 41 , 8)),
				 7 => std_logic_vector(to_unsigned( 170 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 210 , 8)),
				 10 => std_logic_vector(to_unsigned( 32 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 12 , 8)),
				 13 => std_logic_vector(to_unsigned( 239 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 231 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 77

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 251 , 8)),
				 1 => std_logic_vector(to_unsigned( 169 , 8)),
				 2 => std_logic_vector(to_unsigned( 56 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 55 , 8)),
				 5 => std_logic_vector(to_unsigned( 222 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 66 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 32 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 89 , 8)),
				 18 => std_logic_vector(to_unsigned( 214 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 78

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 28 , 8)),
				 4 => std_logic_vector(to_unsigned( 223 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 75 , 8)),
				 8 => std_logic_vector(to_unsigned( 121 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 157 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 64 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 79

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 181 , 8)),
				 1 => std_logic_vector(to_unsigned( 61 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 120 , 8)),
				 4 => std_logic_vector(to_unsigned( 140 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 119 , 8)),
				 8 => std_logic_vector(to_unsigned( 13 , 8)),
				 9 => std_logic_vector(to_unsigned( 121 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 127 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 5 , 8)),
				 14 => std_logic_vector(to_unsigned( 219 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 158 , 8)),
				 17 => std_logic_vector(to_unsigned( 155 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 80

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 164 , 8)),
				 1 => std_logic_vector(to_unsigned( 201 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 75 , 8)),
				 7 => std_logic_vector(to_unsigned( 41 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 49 , 8)),
				 10 => std_logic_vector(to_unsigned( 143 , 8)),
				 11 => std_logic_vector(to_unsigned( 141 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 169 , 8)),
				 14 => std_logic_vector(to_unsigned( 23 , 8)),
				 15 => std_logic_vector(to_unsigned( 171 , 8)),
				 16 => std_logic_vector(to_unsigned( 21 , 8)),
				 17 => std_logic_vector(to_unsigned( 218 , 8)),
				 18 => std_logic_vector(to_unsigned( 135 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 81

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 63 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 231 , 8)),
				 3 => std_logic_vector(to_unsigned( 188 , 8)),
				 4 => std_logic_vector(to_unsigned( 205 , 8)),
				 5 => std_logic_vector(to_unsigned( 91 , 8)),
				 6 => std_logic_vector(to_unsigned( 221 , 8)),
				 7 => std_logic_vector(to_unsigned( 102 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 60 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 60 , 8)),
				 15 => std_logic_vector(to_unsigned( 19 , 8)),
				 16 => std_logic_vector(to_unsigned( 71 , 8)),
				 17 => std_logic_vector(to_unsigned( 186 , 8)),
				 18 => std_logic_vector(to_unsigned( 140 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 82

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 195 , 8)),
				 1 => std_logic_vector(to_unsigned( 188 , 8)),
				 2 => std_logic_vector(to_unsigned( 41 , 8)),
				 3 => std_logic_vector(to_unsigned( 148 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 158 , 8)),
				 7 => std_logic_vector(to_unsigned( 146 , 8)),
				 8 => std_logic_vector(to_unsigned( 203 , 8)),
				 9 => std_logic_vector(to_unsigned( 179 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 129 , 8)),
				 13 => std_logic_vector(to_unsigned( 80 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 215 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 196 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 83

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 120 , 8)),
				 2 => std_logic_vector(to_unsigned( 236 , 8)),
				 3 => std_logic_vector(to_unsigned( 143 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 49 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 32 , 8)),
				 11 => std_logic_vector(to_unsigned( 11 , 8)),
				 12 => std_logic_vector(to_unsigned( 149 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 165 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 141 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 13 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 84

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 137 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 200 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 226 , 8)),
				 5 => std_logic_vector(to_unsigned( 249 , 8)),
				 6 => std_logic_vector(to_unsigned( 202 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 150 , 8)),
				 9 => std_logic_vector(to_unsigned( 35 , 8)),
				 10 => std_logic_vector(to_unsigned( 172 , 8)),
				 11 => std_logic_vector(to_unsigned( 121 , 8)),
				 12 => std_logic_vector(to_unsigned( 119 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 114 , 8)),
				 18 => std_logic_vector(to_unsigned( 207 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 85

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 74 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 96 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 96 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 99 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 159 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 115 , 8)),
				 14 => std_logic_vector(to_unsigned( 104 , 8)),
				 15 => std_logic_vector(to_unsigned( 116 , 8)),
				 16 => std_logic_vector(to_unsigned( 212 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 86

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 226 , 8)),
				 1 => std_logic_vector(to_unsigned( 210 , 8)),
				 2 => std_logic_vector(to_unsigned( 137 , 8)),
				 3 => std_logic_vector(to_unsigned( 232 , 8)),
				 4 => std_logic_vector(to_unsigned( 203 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 254 , 8)),
				 7 => std_logic_vector(to_unsigned( 46 , 8)),
				 8 => std_logic_vector(to_unsigned( 251 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 46 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 184 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 87

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 216 , 8)),
				 1 => std_logic_vector(to_unsigned( 64 , 8)),
				 2 => std_logic_vector(to_unsigned( 166 , 8)),
				 3 => std_logic_vector(to_unsigned( 1 , 8)),
				 4 => std_logic_vector(to_unsigned( 119 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 32 , 8)),
				 8 => std_logic_vector(to_unsigned( 123 , 8)),
				 9 => std_logic_vector(to_unsigned( 82 , 8)),
				 10 => std_logic_vector(to_unsigned( 73 , 8)),
				 11 => std_logic_vector(to_unsigned( 148 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 153 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 88

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 29 , 8)),
				 2 => std_logic_vector(to_unsigned( 4 , 8)),
				 3 => std_logic_vector(to_unsigned( 30 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 114 , 8)),
				 6 => std_logic_vector(to_unsigned( 244 , 8)),
				 7 => std_logic_vector(to_unsigned( 154 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 106 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 103 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 50 , 8)),
				 17 => std_logic_vector(to_unsigned( 244 , 8)),
				 18 => std_logic_vector(to_unsigned( 126 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 89

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 49 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 178 , 8)),
				 3 => std_logic_vector(to_unsigned( 220 , 8)),
				 4 => std_logic_vector(to_unsigned( 101 , 8)),
				 5 => std_logic_vector(to_unsigned( 142 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 42 , 8)),
				 8 => std_logic_vector(to_unsigned( 208 , 8)),
				 9 => std_logic_vector(to_unsigned( 69 , 8)),
				 10 => std_logic_vector(to_unsigned( 181 , 8)),
				 11 => std_logic_vector(to_unsigned( 120 , 8)),
				 12 => std_logic_vector(to_unsigned( 130 , 8)),
				 13 => std_logic_vector(to_unsigned( 66 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 216 , 8)),
				 18 => std_logic_vector(to_unsigned( 163 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 90

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 52 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 128 , 8)),
				 3 => std_logic_vector(to_unsigned( 95 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 168 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 53 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 130 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 207 , 8)),
				 14 => std_logic_vector(to_unsigned( 27 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 189 , 8)),
				 18 => std_logic_vector(to_unsigned( 194 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 91

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 43 , 8)),
				 1 => std_logic_vector(to_unsigned( 52 , 8)),
				 2 => std_logic_vector(to_unsigned( 153 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 66 , 8)),
				 5 => std_logic_vector(to_unsigned( 155 , 8)),
				 6 => std_logic_vector(to_unsigned( 50 , 8)),
				 7 => std_logic_vector(to_unsigned( 157 , 8)),
				 8 => std_logic_vector(to_unsigned( 48 , 8)),
				 9 => std_logic_vector(to_unsigned( 187 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 187 , 8)),
				 12 => std_logic_vector(to_unsigned( 18 , 8)),
				 13 => std_logic_vector(to_unsigned( 207 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 186 , 8)),
				 17 => std_logic_vector(to_unsigned( 19 , 8)),
				 18 => std_logic_vector(to_unsigned( 20 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 11 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 92

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 150 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 41 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 27 , 8)),
				 5 => std_logic_vector(to_unsigned( 236 , 8)),
				 6 => std_logic_vector(to_unsigned( 94 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 219 , 8)),
				 9 => std_logic_vector(to_unsigned( 117 , 8)),
				 10 => std_logic_vector(to_unsigned( 37 , 8)),
				 11 => std_logic_vector(to_unsigned( 130 , 8)),
				 12 => std_logic_vector(to_unsigned( 30 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 180 , 8)),
				 17 => std_logic_vector(to_unsigned( 130 , 8)),
				 18 => std_logic_vector(to_unsigned( 37 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 93

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 164 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 200 , 8)),
				 3 => std_logic_vector(to_unsigned( 11 , 8)),
				 4 => std_logic_vector(to_unsigned( 242 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 186 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 29 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 29 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 39 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 55 , 8)),
				 18 => std_logic_vector(to_unsigned( 180 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 94

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 140 , 8)),
				 1 => std_logic_vector(to_unsigned( 80 , 8)),
				 2 => std_logic_vector(to_unsigned( 167 , 8)),
				 3 => std_logic_vector(to_unsigned( 164 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 169 , 8)),
				 6 => std_logic_vector(to_unsigned( 115 , 8)),
				 7 => std_logic_vector(to_unsigned( 173 , 8)),
				 8 => std_logic_vector(to_unsigned( 199 , 8)),
				 9 => std_logic_vector(to_unsigned( 206 , 8)),
				 10 => std_logic_vector(to_unsigned( 166 , 8)),
				 11 => std_logic_vector(to_unsigned( 78 , 8)),
				 12 => std_logic_vector(to_unsigned( 129 , 8)),
				 13 => std_logic_vector(to_unsigned( 87 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 21 , 8)),
				 18 => std_logic_vector(to_unsigned( 11 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 95

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 94 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 240 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 86 , 8)),
				 5 => std_logic_vector(to_unsigned( 75 , 8)),
				 6 => std_logic_vector(to_unsigned( 81 , 8)),
				 7 => std_logic_vector(to_unsigned( 202 , 8)),
				 8 => std_logic_vector(to_unsigned( 113 , 8)),
				 9 => std_logic_vector(to_unsigned( 68 , 8)),
				 10 => std_logic_vector(to_unsigned( 131 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 32 , 8)),
				 13 => std_logic_vector(to_unsigned( 235 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 96

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 232 , 8)),
				 1 => std_logic_vector(to_unsigned( 55 , 8)),
				 2 => std_logic_vector(to_unsigned( 153 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 110 , 8)),
				 5 => std_logic_vector(to_unsigned( 81 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 222 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 220 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 220 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 220 , 8)),
				 17 => std_logic_vector(to_unsigned( 248 , 8)),
				 18 => std_logic_vector(to_unsigned( 179 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 232 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 97

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 16 , 8)),
				 3 => std_logic_vector(to_unsigned( 206 , 8)),
				 4 => std_logic_vector(to_unsigned( 197 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 174 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 154 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 151 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 149 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 176 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 178 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 8 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 98

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 64 , 8)),
				 1 => std_logic_vector(to_unsigned( 116 , 8)),
				 2 => std_logic_vector(to_unsigned( 214 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 40 , 8)),
				 6 => std_logic_vector(to_unsigned( 88 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 177 , 8)),
				 9 => std_logic_vector(to_unsigned( 55 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 99 , 8)),
				 12 => std_logic_vector(to_unsigned( 72 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 228 , 8)),
				 15 => std_logic_vector(to_unsigned( 116 , 8)),
				 16 => std_logic_vector(to_unsigned( 252 , 8)),
				 17 => std_logic_vector(to_unsigned( 49 , 8)),
				 18 => std_logic_vector(to_unsigned( 206 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 99

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 68 , 8)),
				 1 => std_logic_vector(to_unsigned( 12 , 8)),
				 2 => std_logic_vector(to_unsigned( 26 , 8)),
				 3 => std_logic_vector(to_unsigned( 185 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 93 , 8)),
				 9 => std_logic_vector(to_unsigned( 99 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 118 , 8)),
				 12 => std_logic_vector(to_unsigned( 37 , 8)),
				 13 => std_logic_vector(to_unsigned( 119 , 8)),
				 14 => std_logic_vector(to_unsigned( 36 , 8)),
				 15 => std_logic_vector(to_unsigned( 136 , 8)),
				 16 => std_logic_vector(to_unsigned( 19 , 8)),
				 17 => std_logic_vector(to_unsigned( 197 , 8)),
				 18 => std_logic_vector(to_unsigned( 137 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 100

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 127 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 95 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 60 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 79 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 120 , 8)),
				 12 => std_logic_vector(to_unsigned( 95 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 97 , 8)),
				 18 => std_logic_vector(to_unsigned( 172 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 101

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 70 , 8)),
				 1 => std_logic_vector(to_unsigned( 134 , 8)),
				 2 => std_logic_vector(to_unsigned( 66 , 8)),
				 3 => std_logic_vector(to_unsigned( 159 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 178 , 8)),
				 6 => std_logic_vector(to_unsigned( 101 , 8)),
				 7 => std_logic_vector(to_unsigned( 68 , 8)),
				 8 => std_logic_vector(to_unsigned( 152 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 172 , 8)),
				 11 => std_logic_vector(to_unsigned( 233 , 8)),
				 12 => std_logic_vector(to_unsigned( 147 , 8)),
				 13 => std_logic_vector(to_unsigned( 244 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 135 , 8)),
				 17 => std_logic_vector(to_unsigned( 40 , 8)),
				 18 => std_logic_vector(to_unsigned( 27 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 102

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 169 , 8)),
				 1 => std_logic_vector(to_unsigned( 160 , 8)),
				 2 => std_logic_vector(to_unsigned( 0 , 8)),
				 3 => std_logic_vector(to_unsigned( 38 , 8)),
				 4 => std_logic_vector(to_unsigned( 115 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 194 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 171 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 171 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 156 , 8)),
				 18 => std_logic_vector(to_unsigned( 132 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 103

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 74 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 206 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 211 , 8)),
				 6 => std_logic_vector(to_unsigned( 201 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 254 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 245 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 100 , 8)),
				 13 => std_logic_vector(to_unsigned( 218 , 8)),
				 14 => std_logic_vector(to_unsigned( 88 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 32 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 104

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 142 , 8)),
				 1 => std_logic_vector(to_unsigned( 180 , 8)),
				 2 => std_logic_vector(to_unsigned( 240 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 183 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 104 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 229 , 8)),
				 13 => std_logic_vector(to_unsigned( 229 , 8)),
				 14 => std_logic_vector(to_unsigned( 225 , 8)),
				 15 => std_logic_vector(to_unsigned( 229 , 8)),
				 16 => std_logic_vector(to_unsigned( 225 , 8)),
				 17 => std_logic_vector(to_unsigned( 130 , 8)),
				 18 => std_logic_vector(to_unsigned( 57 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 105

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 52 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 108 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 98 , 8)),
				 6 => std_logic_vector(to_unsigned( 85 , 8)),
				 7 => std_logic_vector(to_unsigned( 187 , 8)),
				 8 => std_logic_vector(to_unsigned( 140 , 8)),
				 9 => std_logic_vector(to_unsigned( 217 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 128 , 8)),
				 12 => std_logic_vector(to_unsigned( 186 , 8)),
				 13 => std_logic_vector(to_unsigned( 154 , 8)),
				 14 => std_logic_vector(to_unsigned( 160 , 8)),
				 15 => std_logic_vector(to_unsigned( 178 , 8)),
				 16 => std_logic_vector(to_unsigned( 136 , 8)),
				 17 => std_logic_vector(to_unsigned( 94 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 106

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 184 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 205 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 6 , 8)),
				 6 => std_logic_vector(to_unsigned( 92 , 8)),
				 7 => std_logic_vector(to_unsigned( 14 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 248 , 8)),
				 11 => std_logic_vector(to_unsigned( 59 , 8)),
				 12 => std_logic_vector(to_unsigned( 121 , 8)),
				 13 => std_logic_vector(to_unsigned( 73 , 8)),
				 14 => std_logic_vector(to_unsigned( 107 , 8)),
				 15 => std_logic_vector(to_unsigned( 94 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 27 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 107

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 190 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 198 , 8)),
				 4 => std_logic_vector(to_unsigned( 92 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 168 , 8)),
				 12 => std_logic_vector(to_unsigned( 184 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 99 , 8)),
				 15 => std_logic_vector(to_unsigned( 130 , 8)),
				 16 => std_logic_vector(to_unsigned( 234 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 246 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 108

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 40 , 8)),
				 1 => std_logic_vector(to_unsigned( 178 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 10 , 8)),
				 4 => std_logic_vector(to_unsigned( 220 , 8)),
				 5 => std_logic_vector(to_unsigned( 33 , 8)),
				 6 => std_logic_vector(to_unsigned( 197 , 8)),
				 7 => std_logic_vector(to_unsigned( 202 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 160 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 89 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 50 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 129 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 109

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 158 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 158 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 12 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 120 , 8)),
				 9 => std_logic_vector(to_unsigned( 118 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 170 , 8)),
				 13 => std_logic_vector(to_unsigned( 55 , 8)),
				 14 => std_logic_vector(to_unsigned( 154 , 8)),
				 15 => std_logic_vector(to_unsigned( 53 , 8)),
				 16 => std_logic_vector(to_unsigned( 158 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 44 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 110

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 178 , 8)),
				 3 => std_logic_vector(to_unsigned( 11 , 8)),
				 4 => std_logic_vector(to_unsigned( 220 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 192 , 8)),
				 7 => std_logic_vector(to_unsigned( 17 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 52 , 8)),
				 10 => std_logic_vector(to_unsigned( 116 , 8)),
				 11 => std_logic_vector(to_unsigned( 83 , 8)),
				 12 => std_logic_vector(to_unsigned( 128 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 178 , 8)),
				 15 => std_logic_vector(to_unsigned( 55 , 8)),
				 16 => std_logic_vector(to_unsigned( 84 , 8)),
				 17 => std_logic_vector(to_unsigned( 156 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 111

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 225 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 54 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 54 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 53 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 112

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 174 , 8)),
				 1 => std_logic_vector(to_unsigned( 166 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 159 , 8)),
				 4 => std_logic_vector(to_unsigned( 210 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 115 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 114 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 114 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 230 , 8)),
				 15 => std_logic_vector(to_unsigned( 235 , 8)),
				 16 => std_logic_vector(to_unsigned( 170 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 113

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 64 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 153 , 8)),
				 5 => std_logic_vector(to_unsigned( 9 , 8)),
				 6 => std_logic_vector(to_unsigned( 102 , 8)),
				 7 => std_logic_vector(to_unsigned( 35 , 8)),
				 8 => std_logic_vector(to_unsigned( 76 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 47 , 8)),
				 11 => std_logic_vector(to_unsigned( 81 , 8)),
				 12 => std_logic_vector(to_unsigned( 30 , 8)),
				 13 => std_logic_vector(to_unsigned( 140 , 8)),
				 14 => std_logic_vector(to_unsigned( 186 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 125 , 8)),
				 17 => std_logic_vector(to_unsigned( 157 , 8)),
				 18 => std_logic_vector(to_unsigned( 44 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 114

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 18 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 107 , 8)),
				 4 => std_logic_vector(to_unsigned( 102 , 8)),
				 5 => std_logic_vector(to_unsigned( 129 , 8)),
				 6 => std_logic_vector(to_unsigned( 80 , 8)),
				 7 => std_logic_vector(to_unsigned( 146 , 8)),
				 8 => std_logic_vector(to_unsigned( 251 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 44 , 8)),
				 12 => std_logic_vector(to_unsigned( 67 , 8)),
				 13 => std_logic_vector(to_unsigned( 54 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 115 , 8)),
				 17 => std_logic_vector(to_unsigned( 8 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 115

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 94 , 8)),
				 2 => std_logic_vector(to_unsigned( 51 , 8)),
				 3 => std_logic_vector(to_unsigned( 105 , 8)),
				 4 => std_logic_vector(to_unsigned( 40 , 8)),
				 5 => std_logic_vector(to_unsigned( 130 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 26 , 8)),
				 8 => std_logic_vector(to_unsigned( 191 , 8)),
				 9 => std_logic_vector(to_unsigned( 176 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 209 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 213 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 116

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 216 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 195 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 158 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 146 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 145 , 8)),
				 9 => std_logic_vector(to_unsigned( 234 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 94 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 91 , 8)),
				 15 => std_logic_vector(to_unsigned( 109 , 8)),
				 16 => std_logic_vector(to_unsigned( 60 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 117

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 29 , 8)),
				 1 => std_logic_vector(to_unsigned( 31 , 8)),
				 2 => std_logic_vector(to_unsigned( 232 , 8)),
				 3 => std_logic_vector(to_unsigned( 186 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 193 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 233 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 223 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 31 , 8)),
				 14 => std_logic_vector(to_unsigned( 76 , 8)),
				 15 => std_logic_vector(to_unsigned( 123 , 8)),
				 16 => std_logic_vector(to_unsigned( 184 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 71 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 118

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 111 , 8)),
				 1 => std_logic_vector(to_unsigned( 50 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 173 , 8)),
				 4 => std_logic_vector(to_unsigned( 129 , 8)),
				 5 => std_logic_vector(to_unsigned( 203 , 8)),
				 6 => std_logic_vector(to_unsigned( 99 , 8)),
				 7 => std_logic_vector(to_unsigned( 166 , 8)),
				 8 => std_logic_vector(to_unsigned( 168 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 79 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 79 , 8)),
				 17 => std_logic_vector(to_unsigned( 129 , 8)),
				 18 => std_logic_vector(to_unsigned( 118 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 119

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 145 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 32 , 8)),
				 4 => std_logic_vector(to_unsigned( 57 , 8)),
				 5 => std_logic_vector(to_unsigned( 119 , 8)),
				 6 => std_logic_vector(to_unsigned( 253 , 8)),
				 7 => std_logic_vector(to_unsigned( 84 , 8)),
				 8 => std_logic_vector(to_unsigned( 68 , 8)),
				 9 => std_logic_vector(to_unsigned( 123 , 8)),
				 10 => std_logic_vector(to_unsigned( 29 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 231 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 94 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 120

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 13 , 8)),
				 2 => std_logic_vector(to_unsigned( 229 , 8)),
				 3 => std_logic_vector(to_unsigned( 46 , 8)),
				 4 => std_logic_vector(to_unsigned( 18 , 8)),
				 5 => std_logic_vector(to_unsigned( 58 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 58 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 58 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 42 , 8)),
				 14 => std_logic_vector(to_unsigned( 131 , 8)),
				 15 => std_logic_vector(to_unsigned( 48 , 8)),
				 16 => std_logic_vector(to_unsigned( 171 , 8)),
				 17 => std_logic_vector(to_unsigned( 55 , 8)),
				 18 => std_logic_vector(to_unsigned( 220 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 121

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 22 , 8)),
				 1 => std_logic_vector(to_unsigned( 138 , 8)),
				 2 => std_logic_vector(to_unsigned( 123 , 8)),
				 3 => std_logic_vector(to_unsigned( 22 , 8)),
				 4 => std_logic_vector(to_unsigned( 59 , 8)),
				 5 => std_logic_vector(to_unsigned( 52 , 8)),
				 6 => std_logic_vector(to_unsigned( 29 , 8)),
				 7 => std_logic_vector(to_unsigned( 20 , 8)),
				 8 => std_logic_vector(to_unsigned( 156 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 78 , 8)),
				 14 => std_logic_vector(to_unsigned( 246 , 8)),
				 15 => std_logic_vector(to_unsigned( 55 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 106 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 122

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 197 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 31 , 8)),
				 4 => std_logic_vector(to_unsigned( 47 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 145 , 8)),
				 8 => std_logic_vector(to_unsigned( 45 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 176 , 8)),
				 11 => std_logic_vector(to_unsigned( 198 , 8)),
				 12 => std_logic_vector(to_unsigned( 150 , 8)),
				 13 => std_logic_vector(to_unsigned( 48 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 60 , 8)),
				 16 => std_logic_vector(to_unsigned( 181 , 8)),
				 17 => std_logic_vector(to_unsigned( 49 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 123

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 149 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 123 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 79 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 85 , 8)),
				 10 => std_logic_vector(to_unsigned( 158 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 71 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 167 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 124

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 77 , 8)),
				 2 => std_logic_vector(to_unsigned( 150 , 8)),
				 3 => std_logic_vector(to_unsigned( 85 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 142 , 8)),
				 6 => std_logic_vector(to_unsigned( 85 , 8)),
				 7 => std_logic_vector(to_unsigned( 0 , 8)),
				 8 => std_logic_vector(to_unsigned( 139 , 8)),
				 9 => std_logic_vector(to_unsigned( 47 , 8)),
				 10 => std_logic_vector(to_unsigned( 92 , 8)),
				 11 => std_logic_vector(to_unsigned( 67 , 8)),
				 12 => std_logic_vector(to_unsigned( 72 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 224 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 210 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 125

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 20 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 111 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 43 , 8)),
				 7 => std_logic_vector(to_unsigned( 158 , 8)),
				 8 => std_logic_vector(to_unsigned( 251 , 8)),
				 9 => std_logic_vector(to_unsigned( 184 , 8)),
				 10 => std_logic_vector(to_unsigned( 225 , 8)),
				 11 => std_logic_vector(to_unsigned( 48 , 8)),
				 12 => std_logic_vector(to_unsigned( 167 , 8)),
				 13 => std_logic_vector(to_unsigned( 57 , 8)),
				 14 => std_logic_vector(to_unsigned( 158 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 12 , 8)),
				 18 => std_logic_vector(to_unsigned( 206 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 126

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 87 , 8)),
				 2 => std_logic_vector(to_unsigned( 14 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 211 , 8)),
				 7 => std_logic_vector(to_unsigned( 43 , 8)),
				 8 => std_logic_vector(to_unsigned( 23 , 8)),
				 9 => std_logic_vector(to_unsigned( 55 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 90 , 8)),
				 14 => std_logic_vector(to_unsigned( 222 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 120 , 8)),
				 17 => std_logic_vector(to_unsigned( 100 , 8)),
				 18 => std_logic_vector(to_unsigned( 4 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 127

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 54 , 8)),
				 1 => std_logic_vector(to_unsigned( 95 , 8)),
				 2 => std_logic_vector(to_unsigned( 206 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 92 , 8)),
				 5 => std_logic_vector(to_unsigned( 98 , 8)),
				 6 => std_logic_vector(to_unsigned( 172 , 8)),
				 7 => std_logic_vector(to_unsigned( 142 , 8)),
				 8 => std_logic_vector(to_unsigned( 165 , 8)),
				 9 => std_logic_vector(to_unsigned( 144 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 61 , 8)),
				 13 => std_logic_vector(to_unsigned( 82 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 230 , 8)),
				 17 => std_logic_vector(to_unsigned( 39 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 128

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 89 , 8)),
				 2 => std_logic_vector(to_unsigned( 24 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 15 , 8)),
				 5 => std_logic_vector(to_unsigned( 110 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 155 , 8)),
				 8 => std_logic_vector(to_unsigned( 114 , 8)),
				 9 => std_logic_vector(to_unsigned( 9 , 8)),
				 10 => std_logic_vector(to_unsigned( 201 , 8)),
				 11 => std_logic_vector(to_unsigned( 105 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 34 , 8)),
				 15 => std_logic_vector(to_unsigned( 135 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 4 , 8)),
				 18 => std_logic_vector(to_unsigned( 244 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 129

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 59 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 0 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 234 , 8)),
				 8 => std_logic_vector(to_unsigned( 11 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 240 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 192 , 8)),
				 14 => std_logic_vector(to_unsigned( 101 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 171 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 130

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 68 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 246 , 8)),
				 3 => std_logic_vector(to_unsigned( 37 , 8)),
				 4 => std_logic_vector(to_unsigned( 46 , 8)),
				 5 => std_logic_vector(to_unsigned( 153 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 210 , 8)),
				 8 => std_logic_vector(to_unsigned( 120 , 8)),
				 9 => std_logic_vector(to_unsigned( 226 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 91 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 77 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 155 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 131

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 122 , 8)),
				 1 => std_logic_vector(to_unsigned( 181 , 8)),
				 2 => std_logic_vector(to_unsigned( 30 , 8)),
				 3 => std_logic_vector(to_unsigned( 157 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 120 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 192 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 188 , 8)),
				 13 => std_logic_vector(to_unsigned( 6 , 8)),
				 14 => std_logic_vector(to_unsigned( 141 , 8)),
				 15 => std_logic_vector(to_unsigned( 38 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 28 , 8)),
				 18 => std_logic_vector(to_unsigned( 236 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 132

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 152 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 59 , 8)),
				 3 => std_logic_vector(to_unsigned( 99 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 81 , 8)),
				 6 => std_logic_vector(to_unsigned( 186 , 8)),
				 7 => std_logic_vector(to_unsigned( 56 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 171 , 8)),
				 10 => std_logic_vector(to_unsigned( 120 , 8)),
				 11 => std_logic_vector(to_unsigned( 189 , 8)),
				 12 => std_logic_vector(to_unsigned( 102 , 8)),
				 13 => std_logic_vector(to_unsigned( 235 , 8)),
				 14 => std_logic_vector(to_unsigned( 56 , 8)),
				 15 => std_logic_vector(to_unsigned( 182 , 8)),
				 16 => std_logic_vector(to_unsigned( 229 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 43 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 133

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 97 , 8)),
				 1 => std_logic_vector(to_unsigned( 230 , 8)),
				 2 => std_logic_vector(to_unsigned( 220 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 117 , 8)),
				 5 => std_logic_vector(to_unsigned( 202 , 8)),
				 6 => std_logic_vector(to_unsigned( 117 , 8)),
				 7 => std_logic_vector(to_unsigned( 146 , 8)),
				 8 => std_logic_vector(to_unsigned( 117 , 8)),
				 9 => std_logic_vector(to_unsigned( 153 , 8)),
				 10 => std_logic_vector(to_unsigned( 148 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 57 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 47 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 134

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 169 , 8)),
				 2 => std_logic_vector(to_unsigned( 31 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 28 , 8)),
				 5 => std_logic_vector(to_unsigned( 42 , 8)),
				 6 => std_logic_vector(to_unsigned( 200 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 146 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 43 , 8)),
				 11 => std_logic_vector(to_unsigned( 176 , 8)),
				 12 => std_logic_vector(to_unsigned( 250 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 189 , 8)),
				 16 => std_logic_vector(to_unsigned( 31 , 8)),
				 17 => std_logic_vector(to_unsigned( 150 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 135

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 31 , 8)),
				 2 => std_logic_vector(to_unsigned( 115 , 8)),
				 3 => std_logic_vector(to_unsigned( 52 , 8)),
				 4 => std_logic_vector(to_unsigned( 94 , 8)),
				 5 => std_logic_vector(to_unsigned( 53 , 8)),
				 6 => std_logic_vector(to_unsigned( 93 , 8)),
				 7 => std_logic_vector(to_unsigned( 109 , 8)),
				 8 => std_logic_vector(to_unsigned( 22 , 8)),
				 9 => std_logic_vector(to_unsigned( 124 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 240 , 8)),
				 13 => std_logic_vector(to_unsigned( 233 , 8)),
				 14 => std_logic_vector(to_unsigned( 206 , 8)),
				 15 => std_logic_vector(to_unsigned( 125 , 8)),
				 16 => std_logic_vector(to_unsigned( 147 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 228 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 136

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 20 , 8)),
				 1 => std_logic_vector(to_unsigned( 183 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 205 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 87 , 8)),
				 8 => std_logic_vector(to_unsigned( 154 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 232 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 34 , 8)),
				 16 => std_logic_vector(to_unsigned( 65 , 8)),
				 17 => std_logic_vector(to_unsigned( 221 , 8)),
				 18 => std_logic_vector(to_unsigned( 43 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 137

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 194 , 8)),
				 2 => std_logic_vector(to_unsigned( 178 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 102 , 8)),
				 5 => std_logic_vector(to_unsigned( 45 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 48 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 49 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 195 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 200 , 8)),
				 15 => std_logic_vector(to_unsigned( 127 , 8)),
				 16 => std_logic_vector(to_unsigned( 255 , 8)),
				 17 => std_logic_vector(to_unsigned( 207 , 8)),
				 18 => std_logic_vector(to_unsigned( 184 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 138

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 219 , 8)),
				 1 => std_logic_vector(to_unsigned( 100 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 5 , 8)),
				 4 => std_logic_vector(to_unsigned( 88 , 8)),
				 5 => std_logic_vector(to_unsigned( 139 , 8)),
				 6 => std_logic_vector(to_unsigned( 159 , 8)),
				 7 => std_logic_vector(to_unsigned( 196 , 8)),
				 8 => std_logic_vector(to_unsigned( 102 , 8)),
				 9 => std_logic_vector(to_unsigned( 115 , 8)),
				 10 => std_logic_vector(to_unsigned( 108 , 8)),
				 11 => std_logic_vector(to_unsigned( 105 , 8)),
				 12 => std_logic_vector(to_unsigned( 69 , 8)),
				 13 => std_logic_vector(to_unsigned( 117 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 243 , 8)),
				 17 => std_logic_vector(to_unsigned( 6 , 8)),
				 18 => std_logic_vector(to_unsigned( 73 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 139

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 95 , 8)),
				 1 => std_logic_vector(to_unsigned( 64 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 20 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 147 , 8)),
				 7 => std_logic_vector(to_unsigned( 6 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 16 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 45 , 8)),
				 12 => std_logic_vector(to_unsigned( 169 , 8)),
				 13 => std_logic_vector(to_unsigned( 115 , 8)),
				 14 => std_logic_vector(to_unsigned( 36 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 34 , 8)),
				 17 => std_logic_vector(to_unsigned( 255 , 8)),
				 18 => std_logic_vector(to_unsigned( 231 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 140

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 138 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 23 , 8)),
				 3 => std_logic_vector(to_unsigned( 242 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 8 , 8)),
				 7 => std_logic_vector(to_unsigned( 168 , 8)),
				 8 => std_logic_vector(to_unsigned( 215 , 8)),
				 9 => std_logic_vector(to_unsigned( 176 , 8)),
				 10 => std_logic_vector(to_unsigned( 207 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 41 , 8)),
				 14 => std_logic_vector(to_unsigned( 23 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 141

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 22 , 8)),
				 1 => std_logic_vector(to_unsigned( 183 , 8)),
				 2 => std_logic_vector(to_unsigned( 0 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 203 , 8)),
				 5 => std_logic_vector(to_unsigned( 181 , 8)),
				 6 => std_logic_vector(to_unsigned( 76 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 88 , 8)),
				 10 => std_logic_vector(to_unsigned( 148 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 44 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 74 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 249 , 8)),
				 18 => std_logic_vector(to_unsigned( 155 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 142

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 47 , 8)),
				 5 => std_logic_vector(to_unsigned( 93 , 8)),
				 6 => std_logic_vector(to_unsigned( 134 , 8)),
				 7 => std_logic_vector(to_unsigned( 30 , 8)),
				 8 => std_logic_vector(to_unsigned( 110 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 66 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 110 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 36 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 143

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 157 , 8)),
				 1 => std_logic_vector(to_unsigned( 184 , 8)),
				 2 => std_logic_vector(to_unsigned( 194 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 115 , 8)),
				 6 => std_logic_vector(to_unsigned( 169 , 8)),
				 7 => std_logic_vector(to_unsigned( 66 , 8)),
				 8 => std_logic_vector(to_unsigned( 0 , 8)),
				 9 => std_logic_vector(to_unsigned( 201 , 8)),
				 10 => std_logic_vector(to_unsigned( 78 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 55 , 8)),
				 13 => std_logic_vector(to_unsigned( 244 , 8)),
				 14 => std_logic_vector(to_unsigned( 35 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 31 , 8)),
				 17 => std_logic_vector(to_unsigned( 75 , 8)),
				 18 => std_logic_vector(to_unsigned( 235 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 144

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 174 , 8)),
				 2 => std_logic_vector(to_unsigned( 78 , 8)),
				 3 => std_logic_vector(to_unsigned( 176 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 2 , 8)),
				 6 => std_logic_vector(to_unsigned( 135 , 8)),
				 7 => std_logic_vector(to_unsigned( 54 , 8)),
				 8 => std_logic_vector(to_unsigned( 83 , 8)),
				 9 => std_logic_vector(to_unsigned( 81 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 86 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 96 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 127 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 91 , 8)),
				 18 => std_logic_vector(to_unsigned( 146 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 145

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 5 , 8)),
				 3 => std_logic_vector(to_unsigned( 87 , 8)),
				 4 => std_logic_vector(to_unsigned( 25 , 8)),
				 5 => std_logic_vector(to_unsigned( 105 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 106 , 8)),
				 8 => std_logic_vector(to_unsigned( 134 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 216 , 8)),
				 11 => std_logic_vector(to_unsigned( 228 , 8)),
				 12 => std_logic_vector(to_unsigned( 63 , 8)),
				 13 => std_logic_vector(to_unsigned( 169 , 8)),
				 14 => std_logic_vector(to_unsigned( 111 , 8)),
				 15 => std_logic_vector(to_unsigned( 102 , 8)),
				 16 => std_logic_vector(to_unsigned( 156 , 8)),
				 17 => std_logic_vector(to_unsigned( 112 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 146

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 89 , 8)),
				 1 => std_logic_vector(to_unsigned( 117 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 45 , 8)),
				 5 => std_logic_vector(to_unsigned( 146 , 8)),
				 6 => std_logic_vector(to_unsigned( 122 , 8)),
				 7 => std_logic_vector(to_unsigned( 174 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 27 , 8)),
				 10 => std_logic_vector(to_unsigned( 66 , 8)),
				 11 => std_logic_vector(to_unsigned( 53 , 8)),
				 12 => std_logic_vector(to_unsigned( 114 , 8)),
				 13 => std_logic_vector(to_unsigned( 142 , 8)),
				 14 => std_logic_vector(to_unsigned( 25 , 8)),
				 15 => std_logic_vector(to_unsigned( 151 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 114 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 147

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 111 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 222 , 8)),
				 4 => std_logic_vector(to_unsigned( 195 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 167 , 8)),
				 7 => std_logic_vector(to_unsigned( 135 , 8)),
				 8 => std_logic_vector(to_unsigned( 133 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 122 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 122 , 8)),
				 15 => std_logic_vector(to_unsigned( 69 , 8)),
				 16 => std_logic_vector(to_unsigned( 74 , 8)),
				 17 => std_logic_vector(to_unsigned( 232 , 8)),
				 18 => std_logic_vector(to_unsigned( 41 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 80 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 148

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 145 , 8)),
				 1 => std_logic_vector(to_unsigned( 65 , 8)),
				 2 => std_logic_vector(to_unsigned( 129 , 8)),
				 3 => std_logic_vector(to_unsigned( 112 , 8)),
				 4 => std_logic_vector(to_unsigned( 224 , 8)),
				 5 => std_logic_vector(to_unsigned( 35 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 72 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 74 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 74 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 74 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 245 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 149

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 186 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 110 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 235 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 207 , 8)),
				 9 => std_logic_vector(to_unsigned( 183 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 105 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 105 , 8)),
				 17 => std_logic_vector(to_unsigned( 170 , 8)),
				 18 => std_logic_vector(to_unsigned( 65 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 150

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 21 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 140 , 8)),
				 3 => std_logic_vector(to_unsigned( 84 , 8)),
				 4 => std_logic_vector(to_unsigned( 194 , 8)),
				 5 => std_logic_vector(to_unsigned( 239 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 35 , 8)),
				 9 => std_logic_vector(to_unsigned( 38 , 8)),
				 10 => std_logic_vector(to_unsigned( 192 , 8)),
				 11 => std_logic_vector(to_unsigned( 134 , 8)),
				 12 => std_logic_vector(to_unsigned( 96 , 8)),
				 13 => std_logic_vector(to_unsigned( 63 , 8)),
				 14 => std_logic_vector(to_unsigned( 67 , 8)),
				 15 => std_logic_vector(to_unsigned( 94 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 182 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 151

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 60 , 8)),
				 1 => std_logic_vector(to_unsigned( 253 , 8)),
				 2 => std_logic_vector(to_unsigned( 245 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 244 , 8)),
				 5 => std_logic_vector(to_unsigned( 197 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 203 , 8)),
				 8 => std_logic_vector(to_unsigned( 185 , 8)),
				 9 => std_logic_vector(to_unsigned( 242 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 137 , 8)),
				 13 => std_logic_vector(to_unsigned( 118 , 8)),
				 14 => std_logic_vector(to_unsigned( 181 , 8)),
				 15 => std_logic_vector(to_unsigned( 188 , 8)),
				 16 => std_logic_vector(to_unsigned( 246 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 152

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 194 , 8)),
				 2 => std_logic_vector(to_unsigned( 100 , 8)),
				 3 => std_logic_vector(to_unsigned( 224 , 8)),
				 4 => std_logic_vector(to_unsigned( 70 , 8)),
				 5 => std_logic_vector(to_unsigned( 96 , 8)),
				 6 => std_logic_vector(to_unsigned( 171 , 8)),
				 7 => std_logic_vector(to_unsigned( 23 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 95 , 8)),
				 10 => std_logic_vector(to_unsigned( 77 , 8)),
				 11 => std_logic_vector(to_unsigned( 24 , 8)),
				 12 => std_logic_vector(to_unsigned( 147 , 8)),
				 13 => std_logic_vector(to_unsigned( 27 , 8)),
				 14 => std_logic_vector(to_unsigned( 144 , 8)),
				 15 => std_logic_vector(to_unsigned( 53 , 8)),
				 16 => std_logic_vector(to_unsigned( 118 , 8)),
				 17 => std_logic_vector(to_unsigned( 128 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 153

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 20 , 8)),
				 1 => std_logic_vector(to_unsigned( 190 , 8)),
				 2 => std_logic_vector(to_unsigned( 99 , 8)),
				 3 => std_logic_vector(to_unsigned( 231 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 163 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 65 , 8)),
				 9 => std_logic_vector(to_unsigned( 200 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 207 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 138 , 8)),
				 14 => std_logic_vector(to_unsigned( 252 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 218 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 154

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 202 , 8)),
				 2 => std_logic_vector(to_unsigned( 164 , 8)),
				 3 => std_logic_vector(to_unsigned( 153 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 92 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 115 , 8)),
				 10 => std_logic_vector(to_unsigned( 43 , 8)),
				 11 => std_logic_vector(to_unsigned( 128 , 8)),
				 12 => std_logic_vector(to_unsigned( 30 , 8)),
				 13 => std_logic_vector(to_unsigned( 109 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 75 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 155

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 145 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 10 , 8)),
				 3 => std_logic_vector(to_unsigned( 25 , 8)),
				 4 => std_logic_vector(to_unsigned( 28 , 8)),
				 5 => std_logic_vector(to_unsigned( 35 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 50 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 50 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 15 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 227 , 8)),
				 14 => std_logic_vector(to_unsigned( 187 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 109 , 8)),
				 18 => std_logic_vector(to_unsigned( 82 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 156

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 206 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 218 , 8)),
				 3 => std_logic_vector(to_unsigned( 251 , 8)),
				 4 => std_logic_vector(to_unsigned( 207 , 8)),
				 5 => std_logic_vector(to_unsigned( 57 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 31 , 8)),
				 8 => std_logic_vector(to_unsigned( 130 , 8)),
				 9 => std_logic_vector(to_unsigned( 144 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 204 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 114 , 8)),
				 15 => std_logic_vector(to_unsigned( 94 , 8)),
				 16 => std_logic_vector(to_unsigned( 230 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 65 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 157

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 50 , 8)),
				 1 => std_logic_vector(to_unsigned( 17 , 8)),
				 2 => std_logic_vector(to_unsigned( 67 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 27 , 8)),
				 5 => std_logic_vector(to_unsigned( 63 , 8)),
				 6 => std_logic_vector(to_unsigned( 21 , 8)),
				 7 => std_logic_vector(to_unsigned( 35 , 8)),
				 8 => std_logic_vector(to_unsigned( 215 , 8)),
				 9 => std_logic_vector(to_unsigned( 226 , 8)),
				 10 => std_logic_vector(to_unsigned( 70 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 69 , 8)),
				 13 => std_logic_vector(to_unsigned( 30 , 8)),
				 14 => std_logic_vector(to_unsigned( 192 , 8)),
				 15 => std_logic_vector(to_unsigned( 31 , 8)),
				 16 => std_logic_vector(to_unsigned( 191 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 252 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 158

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 22 , 8)),
				 2 => std_logic_vector(to_unsigned( 137 , 8)),
				 3 => std_logic_vector(to_unsigned( 74 , 8)),
				 4 => std_logic_vector(to_unsigned( 85 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 48 , 8)),
				 7 => std_logic_vector(to_unsigned( 74 , 8)),
				 8 => std_logic_vector(to_unsigned( 30 , 8)),
				 9 => std_logic_vector(to_unsigned( 65 , 8)),
				 10 => std_logic_vector(to_unsigned( 151 , 8)),
				 11 => std_logic_vector(to_unsigned( 213 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 192 , 8)),
				 18 => std_logic_vector(to_unsigned( 231 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 159

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 126 , 8)),
				 2 => std_logic_vector(to_unsigned( 120 , 8)),
				 3 => std_logic_vector(to_unsigned( 131 , 8)),
				 4 => std_logic_vector(to_unsigned( 169 , 8)),
				 5 => std_logic_vector(to_unsigned( 134 , 8)),
				 6 => std_logic_vector(to_unsigned( 166 , 8)),
				 7 => std_logic_vector(to_unsigned( 186 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 195 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 81 , 8)),
				 12 => std_logic_vector(to_unsigned( 60 , 8)),
				 13 => std_logic_vector(to_unsigned( 2 , 8)),
				 14 => std_logic_vector(to_unsigned( 255 , 8)),
				 15 => std_logic_vector(to_unsigned( 41 , 8)),
				 16 => std_logic_vector(to_unsigned( 114 , 8)),
				 17 => std_logic_vector(to_unsigned( 84 , 8)),
				 18 => std_logic_vector(to_unsigned( 220 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 160

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 38 , 8)),
				 1 => std_logic_vector(to_unsigned( 123 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 185 , 8)),
				 4 => std_logic_vector(to_unsigned( 87 , 8)),
				 5 => std_logic_vector(to_unsigned( 226 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 204 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 131 , 8)),
				 10 => std_logic_vector(to_unsigned( 142 , 8)),
				 11 => std_logic_vector(to_unsigned( 210 , 8)),
				 12 => std_logic_vector(to_unsigned( 63 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 50 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 48 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 141 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 161

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 215 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 133 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 246 , 8)),
				 6 => std_logic_vector(to_unsigned( 115 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 107 , 8)),
				 9 => std_logic_vector(to_unsigned( 76 , 8)),
				 10 => std_logic_vector(to_unsigned( 176 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 176 , 8)),
				 18 => std_logic_vector(to_unsigned( 54 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 162

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 164 , 8)),
				 1 => std_logic_vector(to_unsigned( 17 , 8)),
				 2 => std_logic_vector(to_unsigned( 72 , 8)),
				 3 => std_logic_vector(to_unsigned( 19 , 8)),
				 4 => std_logic_vector(to_unsigned( 188 , 8)),
				 5 => std_logic_vector(to_unsigned( 183 , 8)),
				 6 => std_logic_vector(to_unsigned( 63 , 8)),
				 7 => std_logic_vector(to_unsigned( 221 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 105 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 24 , 8)),
				 12 => std_logic_vector(to_unsigned( 124 , 8)),
				 13 => std_logic_vector(to_unsigned( 89 , 8)),
				 14 => std_logic_vector(to_unsigned( 208 , 8)),
				 15 => std_logic_vector(to_unsigned( 133 , 8)),
				 16 => std_logic_vector(to_unsigned( 164 , 8)),
				 17 => std_logic_vector(to_unsigned( 124 , 8)),
				 18 => std_logic_vector(to_unsigned( 243 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 163

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 134 , 8)),
				 1 => std_logic_vector(to_unsigned( 62 , 8)),
				 2 => std_logic_vector(to_unsigned( 195 , 8)),
				 3 => std_logic_vector(to_unsigned( 206 , 8)),
				 4 => std_logic_vector(to_unsigned( 51 , 8)),
				 5 => std_logic_vector(to_unsigned( 193 , 8)),
				 6 => std_logic_vector(to_unsigned( 123 , 8)),
				 7 => std_logic_vector(to_unsigned( 183 , 8)),
				 8 => std_logic_vector(to_unsigned( 44 , 8)),
				 9 => std_logic_vector(to_unsigned( 122 , 8)),
				 10 => std_logic_vector(to_unsigned( 147 , 8)),
				 11 => std_logic_vector(to_unsigned( 145 , 8)),
				 12 => std_logic_vector(to_unsigned( 124 , 8)),
				 13 => std_logic_vector(to_unsigned( 27 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 63 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 47 , 8)),
				 18 => std_logic_vector(to_unsigned( 243 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 164

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 140 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 76 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 158 , 8)),
				 9 => std_logic_vector(to_unsigned( 148 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 109 , 8)),
				 12 => std_logic_vector(to_unsigned( 192 , 8)),
				 13 => std_logic_vector(to_unsigned( 182 , 8)),
				 14 => std_logic_vector(to_unsigned( 119 , 8)),
				 15 => std_logic_vector(to_unsigned( 234 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 165

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 4 , 8)),
				 1 => std_logic_vector(to_unsigned( 248 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 12 , 8)),
				 4 => std_logic_vector(to_unsigned( 77 , 8)),
				 5 => std_logic_vector(to_unsigned( 52 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 57 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 213 , 8)),
				 10 => std_logic_vector(to_unsigned( 201 , 8)),
				 11 => std_logic_vector(to_unsigned( 126 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 153 , 8)),
				 14 => std_logic_vector(to_unsigned( 26 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 21 , 8)),
				 17 => std_logic_vector(to_unsigned( 12 , 8)),
				 18 => std_logic_vector(to_unsigned( 74 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 166

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 71 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 6 , 8)),
				 10 => std_logic_vector(to_unsigned( 252 , 8)),
				 11 => std_logic_vector(to_unsigned( 96 , 8)),
				 12 => std_logic_vector(to_unsigned( 162 , 8)),
				 13 => std_logic_vector(to_unsigned( 149 , 8)),
				 14 => std_logic_vector(to_unsigned( 109 , 8)),
				 15 => std_logic_vector(to_unsigned( 155 , 8)),
				 16 => std_logic_vector(to_unsigned( 103 , 8)),
				 17 => std_logic_vector(to_unsigned( 88 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 167

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 191 , 8)),
				 1 => std_logic_vector(to_unsigned( 213 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 213 , 8)),
				 4 => std_logic_vector(to_unsigned( 233 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 223 , 8)),
				 7 => std_logic_vector(to_unsigned( 46 , 8)),
				 8 => std_logic_vector(to_unsigned( 244 , 8)),
				 9 => std_logic_vector(to_unsigned( 88 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 109 , 8)),
				 12 => std_logic_vector(to_unsigned( 89 , 8)),
				 13 => std_logic_vector(to_unsigned( 172 , 8)),
				 14 => std_logic_vector(to_unsigned( 150 , 8)),
				 15 => std_logic_vector(to_unsigned( 180 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 32 , 8)),
				 18 => std_logic_vector(to_unsigned( 237 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 168

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 215 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 97 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 110 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 144 , 8)),
				 8 => std_logic_vector(to_unsigned( 162 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 123 , 8)),
				 11 => std_logic_vector(to_unsigned( 163 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 161 , 8)),
				 14 => std_logic_vector(to_unsigned( 220 , 8)),
				 15 => std_logic_vector(to_unsigned( 161 , 8)),
				 16 => std_logic_vector(to_unsigned( 220 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 143 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 169

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 197 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 215 , 8)),
				 4 => std_logic_vector(to_unsigned( 236 , 8)),
				 5 => std_logic_vector(to_unsigned( 7 , 8)),
				 6 => std_logic_vector(to_unsigned( 169 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 142 , 8)),
				 10 => std_logic_vector(to_unsigned( 226 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 132 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 115 , 8)),
				 17 => std_logic_vector(to_unsigned( 132 , 8)),
				 18 => std_logic_vector(to_unsigned( 204 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 170

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 206 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 95 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 67 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 67 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 61 , 8)),
				 10 => std_logic_vector(to_unsigned( 62 , 8)),
				 11 => std_logic_vector(to_unsigned( 32 , 8)),
				 12 => std_logic_vector(to_unsigned( 209 , 8)),
				 13 => std_logic_vector(to_unsigned( 40 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 36 , 8)),
				 16 => std_logic_vector(to_unsigned( 214 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 34 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 14 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 171

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 206 , 8)),
				 1 => std_logic_vector(to_unsigned( 220 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 75 , 8)),
				 6 => std_logic_vector(to_unsigned( 92 , 8)),
				 7 => std_logic_vector(to_unsigned( 94 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 152 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 111 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 20 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 228 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 172

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 17 , 8)),
				 1 => std_logic_vector(to_unsigned( 50 , 8)),
				 2 => std_logic_vector(to_unsigned( 56 , 8)),
				 3 => std_logic_vector(to_unsigned( 63 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 105 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 105 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 105 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 105 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 255 , 8)),
				 15 => std_logic_vector(to_unsigned( 76 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 54 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 173

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 150 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 60 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 242 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 241 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 240 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 239 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 238 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 157 , 8)),
				 16 => std_logic_vector(to_unsigned( 205 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 13 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 174

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 15 , 8)),
				 2 => std_logic_vector(to_unsigned( 37 , 8)),
				 3 => std_logic_vector(to_unsigned( 27 , 8)),
				 4 => std_logic_vector(to_unsigned( 25 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 119 , 8)),
				 10 => std_logic_vector(to_unsigned( 27 , 8)),
				 11 => std_logic_vector(to_unsigned( 131 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 161 , 8)),
				 16 => std_logic_vector(to_unsigned( 163 , 8)),
				 17 => std_logic_vector(to_unsigned( 211 , 8)),
				 18 => std_logic_vector(to_unsigned( 176 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 175

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 181 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 213 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 5 , 8)),
				 6 => std_logic_vector(to_unsigned( 147 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 220 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 42 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 144 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 176

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 104 , 8)),
				 1 => std_logic_vector(to_unsigned( 219 , 8)),
				 2 => std_logic_vector(to_unsigned( 57 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 182 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 174 , 8)),
				 9 => std_logic_vector(to_unsigned( 177 , 8)),
				 10 => std_logic_vector(to_unsigned( 90 , 8)),
				 11 => std_logic_vector(to_unsigned( 126 , 8)),
				 12 => std_logic_vector(to_unsigned( 209 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 193 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 177

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 22 , 8)),
				 1 => std_logic_vector(to_unsigned( 102 , 8)),
				 2 => std_logic_vector(to_unsigned( 201 , 8)),
				 3 => std_logic_vector(to_unsigned( 14 , 8)),
				 4 => std_logic_vector(to_unsigned( 143 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 116 , 8)),
				 7 => std_logic_vector(to_unsigned( 38 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 230 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 65 , 8)),
				 17 => std_logic_vector(to_unsigned( 44 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 178

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 60 , 8)),
				 2 => std_logic_vector(to_unsigned( 62 , 8)),
				 3 => std_logic_vector(to_unsigned( 101 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 145 , 8)),
				 6 => std_logic_vector(to_unsigned( 132 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 64 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 217 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 13 , 8)),
				 14 => std_logic_vector(to_unsigned( 196 , 8)),
				 15 => std_logic_vector(to_unsigned( 108 , 8)),
				 16 => std_logic_vector(to_unsigned( 251 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 179

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 244 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 131 , 8)),
				 5 => std_logic_vector(to_unsigned( 59 , 8)),
				 6 => std_logic_vector(to_unsigned( 124 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 80 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 154 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 173 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 28 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 180

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 142 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 56 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 164 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 212 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 80 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 86 , 8)),
				 14 => std_logic_vector(to_unsigned( 118 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 67 , 8)),
				 18 => std_logic_vector(to_unsigned( 226 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 181

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 222 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 234 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 100 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 124 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 166 , 8)),
				 12 => std_logic_vector(to_unsigned( 154 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 190 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 151 , 8)),
				 17 => std_logic_vector(to_unsigned( 142 , 8)),
				 18 => std_logic_vector(to_unsigned( 11 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 182

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 87 , 8)),
				 1 => std_logic_vector(to_unsigned( 126 , 8)),
				 2 => std_logic_vector(to_unsigned( 100 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 171 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 134 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 109 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 108 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 103 , 8)),
				 17 => std_logic_vector(to_unsigned( 24 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 183

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 132 , 8)),
				 1 => std_logic_vector(to_unsigned( 10 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 245 , 8)),
				 4 => std_logic_vector(to_unsigned( 198 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 189 , 8)),
				 7 => std_logic_vector(to_unsigned( 74 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 77 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 36 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 104 , 8)),
				 16 => std_logic_vector(to_unsigned( 65 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 184

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 232 , 8)),
				 1 => std_logic_vector(to_unsigned( 11 , 8)),
				 2 => std_logic_vector(to_unsigned( 250 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 139 , 8)),
				 6 => std_logic_vector(to_unsigned( 188 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 197 , 8)),
				 10 => std_logic_vector(to_unsigned( 66 , 8)),
				 11 => std_logic_vector(to_unsigned( 110 , 8)),
				 12 => std_logic_vector(to_unsigned( 65 , 8)),
				 13 => std_logic_vector(to_unsigned( 136 , 8)),
				 14 => std_logic_vector(to_unsigned( 39 , 8)),
				 15 => std_logic_vector(to_unsigned( 162 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 232 , 8)),
				 18 => std_logic_vector(to_unsigned( 93 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 185

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 0 , 8)),
				 1 => std_logic_vector(to_unsigned( 127 , 8)),
				 2 => std_logic_vector(to_unsigned( 77 , 8)),
				 3 => std_logic_vector(to_unsigned( 156 , 8)),
				 4 => std_logic_vector(to_unsigned( 240 , 8)),
				 5 => std_logic_vector(to_unsigned( 212 , 8)),
				 6 => std_logic_vector(to_unsigned( 184 , 8)),
				 7 => std_logic_vector(to_unsigned( 216 , 8)),
				 8 => std_logic_vector(to_unsigned( 180 , 8)),
				 9 => std_logic_vector(to_unsigned( 195 , 8)),
				 10 => std_logic_vector(to_unsigned( 120 , 8)),
				 11 => std_logic_vector(to_unsigned( 208 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 46 , 8)),
				 14 => std_logic_vector(to_unsigned( 99 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 170 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 0 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 186

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 71 , 8)),
				 2 => std_logic_vector(to_unsigned( 111 , 8)),
				 3 => std_logic_vector(to_unsigned( 107 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 193 , 8)),
				 8 => std_logic_vector(to_unsigned( 252 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 248 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 32 , 8)),
				 14 => std_logic_vector(to_unsigned( 19 , 8)),
				 15 => std_logic_vector(to_unsigned( 38 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 20 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 187

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 178 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 74 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 143 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 169 , 8)),
				 8 => std_logic_vector(to_unsigned( 11 , 8)),
				 9 => std_logic_vector(to_unsigned( 179 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 179 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 179 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 210 , 8)),
				 18 => std_logic_vector(to_unsigned( 133 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 178 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 188

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 146 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 0 , 8)),
				 4 => std_logic_vector(to_unsigned( 180 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 125 , 8)),
				 7 => std_logic_vector(to_unsigned( 169 , 8)),
				 8 => std_logic_vector(to_unsigned( 72 , 8)),
				 9 => std_logic_vector(to_unsigned( 183 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 155 , 8)),
				 13 => std_logic_vector(to_unsigned( 109 , 8)),
				 14 => std_logic_vector(to_unsigned( 162 , 8)),
				 15 => std_logic_vector(to_unsigned( 113 , 8)),
				 16 => std_logic_vector(to_unsigned( 14 , 8)),
				 17 => std_logic_vector(to_unsigned( 25 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 189

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 55 , 8)),
				 1 => std_logic_vector(to_unsigned( 158 , 8)),
				 2 => std_logic_vector(to_unsigned( 176 , 8)),
				 3 => std_logic_vector(to_unsigned( 168 , 8)),
				 4 => std_logic_vector(to_unsigned( 166 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 191 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 158 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 168 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 206 , 8)),
				 13 => std_logic_vector(to_unsigned( 16 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 64 , 8)),
				 16 => std_logic_vector(to_unsigned( 30 , 8)),
				 17 => std_logic_vector(to_unsigned( 110 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 190

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 133 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 186 , 8)),
				 6 => std_logic_vector(to_unsigned( 193 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 232 , 8)),
				 9 => std_logic_vector(to_unsigned( 133 , 8)),
				 10 => std_logic_vector(to_unsigned( 206 , 8)),
				 11 => std_logic_vector(to_unsigned( 152 , 8)),
				 12 => std_logic_vector(to_unsigned( 99 , 8)),
				 13 => std_logic_vector(to_unsigned( 190 , 8)),
				 14 => std_logic_vector(to_unsigned( 61 , 8)),
				 15 => std_logic_vector(to_unsigned( 219 , 8)),
				 16 => std_logic_vector(to_unsigned( 198 , 8)),
				 17 => std_logic_vector(to_unsigned( 227 , 8)),
				 18 => std_logic_vector(to_unsigned( 144 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 191

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 222 , 8)),
				 1 => std_logic_vector(to_unsigned( 188 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 99 , 8)),
				 5 => std_logic_vector(to_unsigned( 13 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 170 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 60 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 57 , 8)),
				 13 => std_logic_vector(to_unsigned( 216 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 218 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 59 , 8)),
				 18 => std_logic_vector(to_unsigned( 74 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 192

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 121 , 8)),
				 2 => std_logic_vector(to_unsigned( 109 , 8)),
				 3 => std_logic_vector(to_unsigned( 117 , 8)),
				 4 => std_logic_vector(to_unsigned( 108 , 8)),
				 5 => std_logic_vector(to_unsigned( 39 , 8)),
				 6 => std_logic_vector(to_unsigned( 129 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 134 , 8)),
				 9 => std_logic_vector(to_unsigned( 55 , 8)),
				 10 => std_logic_vector(to_unsigned( 164 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 135 , 8)),
				 14 => std_logic_vector(to_unsigned( 84 , 8)),
				 15 => std_logic_vector(to_unsigned( 2 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 102 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 193

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 150 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 82 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 82 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 242 , 8)),
				 7 => std_logic_vector(to_unsigned( 102 , 8)),
				 8 => std_logic_vector(to_unsigned( 111 , 8)),
				 9 => std_logic_vector(to_unsigned( 149 , 8)),
				 10 => std_logic_vector(to_unsigned( 64 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 95 , 8)),
				 14 => std_logic_vector(to_unsigned( 171 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 194

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 165 , 8)),
				 2 => std_logic_vector(to_unsigned( 109 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 105 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 74 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 166 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 86 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 85 , 8)),
				 17 => std_logic_vector(to_unsigned( 115 , 8)),
				 18 => std_logic_vector(to_unsigned( 146 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 195

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 252 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 64 , 8)),
				 5 => std_logic_vector(to_unsigned( 194 , 8)),
				 6 => std_logic_vector(to_unsigned( 101 , 8)),
				 7 => std_logic_vector(to_unsigned( 203 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 247 , 8)),
				 10 => std_logic_vector(to_unsigned( 86 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 80 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 75 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 196

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 88 , 8)),
				 1 => std_logic_vector(to_unsigned( 60 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 146 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 106 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 92 , 8)),
				 15 => std_logic_vector(to_unsigned( 247 , 8)),
				 16 => std_logic_vector(to_unsigned( 90 , 8)),
				 17 => std_logic_vector(to_unsigned( 188 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 88 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 197

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 109 , 8)),
				 2 => std_logic_vector(to_unsigned( 83 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 48 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 41 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 167 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 159 , 8)),
				 13 => std_logic_vector(to_unsigned( 228 , 8)),
				 14 => std_logic_vector(to_unsigned( 154 , 8)),
				 15 => std_logic_vector(to_unsigned( 193 , 8)),
				 16 => std_logic_vector(to_unsigned( 137 , 8)),
				 17 => std_logic_vector(to_unsigned( 147 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 198

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 252 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 196 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 174 , 8)),
				 8 => std_logic_vector(to_unsigned( 119 , 8)),
				 9 => std_logic_vector(to_unsigned( 230 , 8)),
				 10 => std_logic_vector(to_unsigned( 63 , 8)),
				 11 => std_logic_vector(to_unsigned( 196 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 64 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 233 , 8)),
				 17 => std_logic_vector(to_unsigned( 56 , 8)),
				 18 => std_logic_vector(to_unsigned( 193 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 199

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 202 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 116 , 8)),
				 4 => std_logic_vector(to_unsigned( 67 , 8)),
				 5 => std_logic_vector(to_unsigned( 60 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 84 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 84 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 57 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 35 , 8)),
				 17 => std_logic_vector(to_unsigned( 172 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 200

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 111 , 8)),
				 1 => std_logic_vector(to_unsigned( 31 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 95 , 8)),
				 4 => std_logic_vector(to_unsigned( 27 , 8)),
				 5 => std_logic_vector(to_unsigned( 7 , 8)),
				 6 => std_logic_vector(to_unsigned( 236 , 8)),
				 7 => std_logic_vector(to_unsigned( 214 , 8)),
				 8 => std_logic_vector(to_unsigned( 176 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 159 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 139 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 137 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 16 , 8)),
				 18 => std_logic_vector(to_unsigned( 179 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 201

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 227 , 8)),
				 1 => std_logic_vector(to_unsigned( 157 , 8)),
				 2 => std_logic_vector(to_unsigned( 240 , 8)),
				 3 => std_logic_vector(to_unsigned( 186 , 8)),
				 4 => std_logic_vector(to_unsigned( 211 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 154 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 149 , 8)),
				 11 => std_logic_vector(to_unsigned( 29 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 39 , 8)),
				 14 => std_logic_vector(to_unsigned( 13 , 8)),
				 15 => std_logic_vector(to_unsigned( 148 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 32 , 8)),
				 18 => std_logic_vector(to_unsigned( 129 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 202

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 222 , 8)),
				 2 => std_logic_vector(to_unsigned( 42 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 182 , 8)),
				 6 => std_logic_vector(to_unsigned( 238 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 167 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 166 , 8)),
				 11 => std_logic_vector(to_unsigned( 184 , 8)),
				 12 => std_logic_vector(to_unsigned( 210 , 8)),
				 13 => std_logic_vector(to_unsigned( 44 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 203

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 18 , 8)),
				 1 => std_logic_vector(to_unsigned( 37 , 8)),
				 2 => std_logic_vector(to_unsigned( 18 , 8)),
				 3 => std_logic_vector(to_unsigned( 151 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 111 , 8)),
				 8 => std_logic_vector(to_unsigned( 206 , 8)),
				 9 => std_logic_vector(to_unsigned( 44 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 108 , 8)),
				 12 => std_logic_vector(to_unsigned( 243 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 141 , 8)),
				 15 => std_logic_vector(to_unsigned( 232 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 247 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 204

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 111 , 8)),
				 1 => std_logic_vector(to_unsigned( 2 , 8)),
				 2 => std_logic_vector(to_unsigned( 238 , 8)),
				 3 => std_logic_vector(to_unsigned( 61 , 8)),
				 4 => std_logic_vector(to_unsigned( 180 , 8)),
				 5 => std_logic_vector(to_unsigned( 154 , 8)),
				 6 => std_logic_vector(to_unsigned( 76 , 8)),
				 7 => std_logic_vector(to_unsigned( 187 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 187 , 8)),
				 10 => std_logic_vector(to_unsigned( 43 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 105 , 8)),
				 14 => std_logic_vector(to_unsigned( 126 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 187 , 8)),
				 18 => std_logic_vector(to_unsigned( 106 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 205

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 8 , 8)),
				 1 => std_logic_vector(to_unsigned( 141 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 206 , 8)),
				 5 => std_logic_vector(to_unsigned( 17 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 22 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 197 , 8)),
				 11 => std_logic_vector(to_unsigned( 175 , 8)),
				 12 => std_logic_vector(to_unsigned( 19 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 87 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 79 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 206

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 94 , 8)),
				 1 => std_logic_vector(to_unsigned( 192 , 8)),
				 2 => std_logic_vector(to_unsigned( 180 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 170 , 8)),
				 5 => std_logic_vector(to_unsigned( 196 , 8)),
				 6 => std_logic_vector(to_unsigned( 157 , 8)),
				 7 => std_logic_vector(to_unsigned( 151 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 203 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 207 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 134 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 34 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 207

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 1 , 8)),
				 1 => std_logic_vector(to_unsigned( 123 , 8)),
				 2 => std_logic_vector(to_unsigned( 98 , 8)),
				 3 => std_logic_vector(to_unsigned( 40 , 8)),
				 4 => std_logic_vector(to_unsigned( 11 , 8)),
				 5 => std_logic_vector(to_unsigned( 227 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 123 , 8)),
				 9 => std_logic_vector(to_unsigned( 95 , 8)),
				 10 => std_logic_vector(to_unsigned( 88 , 8)),
				 11 => std_logic_vector(to_unsigned( 13 , 8)),
				 12 => std_logic_vector(to_unsigned( 120 , 8)),
				 13 => std_logic_vector(to_unsigned( 32 , 8)),
				 14 => std_logic_vector(to_unsigned( 122 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 249 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 48 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 208

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 147 , 8)),
				 1 => std_logic_vector(to_unsigned( 212 , 8)),
				 2 => std_logic_vector(to_unsigned( 88 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 71 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 68 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 3 , 8)),
				 10 => std_logic_vector(to_unsigned( 137 , 8)),
				 11 => std_logic_vector(to_unsigned( 139 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 177 , 8)),
				 16 => std_logic_vector(to_unsigned( 235 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 203 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 209

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 115 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 74 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 39 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 155 , 8)),
				 8 => std_logic_vector(to_unsigned( 253 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 88 , 8)),
				 11 => std_logic_vector(to_unsigned( 60 , 8)),
				 12 => std_logic_vector(to_unsigned( 154 , 8)),
				 13 => std_logic_vector(to_unsigned( 92 , 8)),
				 14 => std_logic_vector(to_unsigned( 122 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 168 , 8)),
				 18 => std_logic_vector(to_unsigned( 137 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 210

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 247 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 204 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 219 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 205 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 205 , 8)),
				 9 => std_logic_vector(to_unsigned( 57 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 207 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 197 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 89 , 8)),
				 18 => std_logic_vector(to_unsigned( 16 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 211

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 114 , 8)),
				 3 => std_logic_vector(to_unsigned( 69 , 8)),
				 4 => std_logic_vector(to_unsigned( 125 , 8)),
				 5 => std_logic_vector(to_unsigned( 66 , 8)),
				 6 => std_logic_vector(to_unsigned( 74 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 139 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 118 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 144 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 17 , 8)),
				 18 => std_logic_vector(to_unsigned( 227 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 212

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 143 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 8 , 8)),
				 3 => std_logic_vector(to_unsigned( 105 , 8)),
				 4 => std_logic_vector(to_unsigned( 146 , 8)),
				 5 => std_logic_vector(to_unsigned( 190 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 190 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 190 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 146 , 8)),
				 13 => std_logic_vector(to_unsigned( 227 , 8)),
				 14 => std_logic_vector(to_unsigned( 90 , 8)),
				 15 => std_logic_vector(to_unsigned( 120 , 8)),
				 16 => std_logic_vector(to_unsigned( 126 , 8)),
				 17 => std_logic_vector(to_unsigned( 23 , 8)),
				 18 => std_logic_vector(to_unsigned( 187 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 213

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 64 , 8)),
				 1 => std_logic_vector(to_unsigned( 149 , 8)),
				 2 => std_logic_vector(to_unsigned( 150 , 8)),
				 3 => std_logic_vector(to_unsigned( 213 , 8)),
				 4 => std_logic_vector(to_unsigned( 86 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 58 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 44 , 8)),
				 11 => std_logic_vector(to_unsigned( 123 , 8)),
				 12 => std_logic_vector(to_unsigned( 19 , 8)),
				 13 => std_logic_vector(to_unsigned( 86 , 8)),
				 14 => std_logic_vector(to_unsigned( 35 , 8)),
				 15 => std_logic_vector(to_unsigned( 119 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 43 , 8)),
				 18 => std_logic_vector(to_unsigned( 176 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 214

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 151 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 7 , 8)),
				 3 => std_logic_vector(to_unsigned( 89 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 75 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 175 , 8)),
				 9 => std_logic_vector(to_unsigned( 86 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 62 , 8)),
				 12 => std_logic_vector(to_unsigned( 180 , 8)),
				 13 => std_logic_vector(to_unsigned( 218 , 8)),
				 14 => std_logic_vector(to_unsigned( 240 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 237 , 8)),
				 17 => std_logic_vector(to_unsigned( 18 , 8)),
				 18 => std_logic_vector(to_unsigned( 72 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 215

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 235 , 8)),
				 1 => std_logic_vector(to_unsigned( 23 , 8)),
				 2 => std_logic_vector(to_unsigned( 26 , 8)),
				 3 => std_logic_vector(to_unsigned( 137 , 8)),
				 4 => std_logic_vector(to_unsigned( 241 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 219 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 155 , 8)),
				 9 => std_logic_vector(to_unsigned( 195 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 191 , 8)),
				 12 => std_logic_vector(to_unsigned( 67 , 8)),
				 13 => std_logic_vector(to_unsigned( 194 , 8)),
				 14 => std_logic_vector(to_unsigned( 173 , 8)),
				 15 => std_logic_vector(to_unsigned( 169 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 147 , 8)),
				 18 => std_logic_vector(to_unsigned( 208 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 216

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 113 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 138 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 232 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 250 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 217 , 8)),
				 9 => std_logic_vector(to_unsigned( 139 , 8)),
				 10 => std_logic_vector(to_unsigned( 130 , 8)),
				 11 => std_logic_vector(to_unsigned( 175 , 8)),
				 12 => std_logic_vector(to_unsigned( 94 , 8)),
				 13 => std_logic_vector(to_unsigned( 206 , 8)),
				 14 => std_logic_vector(to_unsigned( 63 , 8)),
				 15 => std_logic_vector(to_unsigned( 118 , 8)),
				 16 => std_logic_vector(to_unsigned( 79 , 8)),
				 17 => std_logic_vector(to_unsigned( 34 , 8)),
				 18 => std_logic_vector(to_unsigned( 240 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 217

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 153 , 8)),
				 2 => std_logic_vector(to_unsigned( 153 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 24 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 155 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 166 , 8)),
				 10 => std_logic_vector(to_unsigned( 150 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 61 , 8)),
				 15 => std_logic_vector(to_unsigned( 75 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 106 , 8)),
				 18 => std_logic_vector(to_unsigned( 32 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 218

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 68 , 8)),
				 1 => std_logic_vector(to_unsigned( 207 , 8)),
				 2 => std_logic_vector(to_unsigned( 189 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 155 , 8)),
				 5 => std_logic_vector(to_unsigned( 140 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 193 , 8)),
				 8 => std_logic_vector(to_unsigned( 30 , 8)),
				 9 => std_logic_vector(to_unsigned( 92 , 8)),
				 10 => std_logic_vector(to_unsigned( 234 , 8)),
				 11 => std_logic_vector(to_unsigned( 62 , 8)),
				 12 => std_logic_vector(to_unsigned( 180 , 8)),
				 13 => std_logic_vector(to_unsigned( 158 , 8)),
				 14 => std_logic_vector(to_unsigned( 35 , 8)),
				 15 => std_logic_vector(to_unsigned( 38 , 8)),
				 16 => std_logic_vector(to_unsigned( 189 , 8)),
				 17 => std_logic_vector(to_unsigned( 129 , 8)),
				 18 => std_logic_vector(to_unsigned( 148 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 219

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 248 , 8)),
				 1 => std_logic_vector(to_unsigned( 82 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 20 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 71 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 79 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 23 , 8)),
				 14 => std_logic_vector(to_unsigned( 235 , 8)),
				 15 => std_logic_vector(to_unsigned( 54 , 8)),
				 16 => std_logic_vector(to_unsigned( 204 , 8)),
				 17 => std_logic_vector(to_unsigned( 43 , 8)),
				 18 => std_logic_vector(to_unsigned( 0 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 220

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 15 , 8)),
				 1 => std_logic_vector(to_unsigned( 115 , 8)),
				 2 => std_logic_vector(to_unsigned( 195 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 189 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 184 , 8)),
				 7 => std_logic_vector(to_unsigned( 40 , 8)),
				 8 => std_logic_vector(to_unsigned( 163 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 201 , 8)),
				 11 => std_logic_vector(to_unsigned( 240 , 8)),
				 12 => std_logic_vector(to_unsigned( 199 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 209 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 166 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 221

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 244 , 8)),
				 1 => std_logic_vector(to_unsigned( 68 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 68 , 8)),
				 4 => std_logic_vector(to_unsigned( 154 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 170 , 8)),
				 9 => std_logic_vector(to_unsigned( 28 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 63 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 6 , 8)),
				 14 => std_logic_vector(to_unsigned( 73 , 8)),
				 15 => std_logic_vector(to_unsigned( 35 , 8)),
				 16 => std_logic_vector(to_unsigned( 44 , 8)),
				 17 => std_logic_vector(to_unsigned( 39 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 222

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 91 , 8)),
				 2 => std_logic_vector(to_unsigned( 93 , 8)),
				 3 => std_logic_vector(to_unsigned( 221 , 8)),
				 4 => std_logic_vector(to_unsigned( 151 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 234 , 8)),
				 8 => std_logic_vector(to_unsigned( 138 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 128 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 87 , 8)),
				 14 => std_logic_vector(to_unsigned( 156 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 229 , 8)),
				 17 => std_logic_vector(to_unsigned( 22 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 223

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 143 , 8)),
				 3 => std_logic_vector(to_unsigned( 95 , 8)),
				 4 => std_logic_vector(to_unsigned( 101 , 8)),
				 5 => std_logic_vector(to_unsigned( 249 , 8)),
				 6 => std_logic_vector(to_unsigned( 170 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 118 , 8)),
				 9 => std_logic_vector(to_unsigned( 200 , 8)),
				 10 => std_logic_vector(to_unsigned( 89 , 8)),
				 11 => std_logic_vector(to_unsigned( 184 , 8)),
				 12 => std_logic_vector(to_unsigned( 218 , 8)),
				 13 => std_logic_vector(to_unsigned( 71 , 8)),
				 14 => std_logic_vector(to_unsigned( 244 , 8)),
				 15 => std_logic_vector(to_unsigned( 1 , 8)),
				 16 => std_logic_vector(to_unsigned( 21 , 8)),
				 17 => std_logic_vector(to_unsigned( 48 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 224

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 90 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 176 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 113 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 96 , 8)),
				 7 => std_logic_vector(to_unsigned( 138 , 8)),
				 8 => std_logic_vector(to_unsigned( 127 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 243 , 8)),
				 18 => std_logic_vector(to_unsigned( 53 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 225

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 48 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 60 , 8)),
				 4 => std_logic_vector(to_unsigned( 215 , 8)),
				 5 => std_logic_vector(to_unsigned( 185 , 8)),
				 6 => std_logic_vector(to_unsigned( 90 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 48 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 20 , 8)),
				 13 => std_logic_vector(to_unsigned( 162 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 210 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 60 , 8)),
				 18 => std_logic_vector(to_unsigned( 179 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 226

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 19 , 8)),
				 1 => std_logic_vector(to_unsigned( 123 , 8)),
				 2 => std_logic_vector(to_unsigned( 19 , 8)),
				 3 => std_logic_vector(to_unsigned( 178 , 8)),
				 4 => std_logic_vector(to_unsigned( 115 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 67 , 8)),
				 10 => std_logic_vector(to_unsigned( 248 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 114 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 104 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 227

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 135 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 36 , 8)),
				 3 => std_logic_vector(to_unsigned( 127 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 131 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 86 , 8)),
				 10 => std_logic_vector(to_unsigned( 214 , 8)),
				 11 => std_logic_vector(to_unsigned( 138 , 8)),
				 12 => std_logic_vector(to_unsigned( 162 , 8)),
				 13 => std_logic_vector(to_unsigned( 72 , 8)),
				 14 => std_logic_vector(to_unsigned( 52 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 135 , 8)),
				 17 => std_logic_vector(to_unsigned( 198 , 8)),
				 18 => std_logic_vector(to_unsigned( 174 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 228

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 34 , 8)),
				 1 => std_logic_vector(to_unsigned( 117 , 8)),
				 2 => std_logic_vector(to_unsigned( 203 , 8)),
				 3 => std_logic_vector(to_unsigned( 128 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 67 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 67 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 16 , 8)),
				 12 => std_logic_vector(to_unsigned( 142 , 8)),
				 13 => std_logic_vector(to_unsigned( 52 , 8)),
				 14 => std_logic_vector(to_unsigned( 106 , 8)),
				 15 => std_logic_vector(to_unsigned( 148 , 8)),
				 16 => std_logic_vector(to_unsigned( 239 , 8)),
				 17 => std_logic_vector(to_unsigned( 109 , 8)),
				 18 => std_logic_vector(to_unsigned( 102 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 229

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 44 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 229 , 8)),
				 5 => std_logic_vector(to_unsigned( 164 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 81 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 101 , 8)),
				 15 => std_logic_vector(to_unsigned( 64 , 8)),
				 16 => std_logic_vector(to_unsigned( 125 , 8)),
				 17 => std_logic_vector(to_unsigned( 183 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 230

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 56 , 8)),
				 3 => std_logic_vector(to_unsigned( 146 , 8)),
				 4 => std_logic_vector(to_unsigned( 108 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 166 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 56 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 66 , 8)),
				 14 => std_logic_vector(to_unsigned( 239 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 96 , 8)),
				 17 => std_logic_vector(to_unsigned( 208 , 8)),
				 18 => std_logic_vector(to_unsigned( 100 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 231

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 73 , 8)),
				 1 => std_logic_vector(to_unsigned( 28 , 8)),
				 2 => std_logic_vector(to_unsigned( 162 , 8)),
				 3 => std_logic_vector(to_unsigned( 113 , 8)),
				 4 => std_logic_vector(to_unsigned( 77 , 8)),
				 5 => std_logic_vector(to_unsigned( 154 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 31 , 8)),
				 9 => std_logic_vector(to_unsigned( 167 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 56 , 8)),
				 13 => std_logic_vector(to_unsigned( 152 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 174 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 191 , 8)),
				 18 => std_logic_vector(to_unsigned( 34 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 232

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 222 , 8)),
				 1 => std_logic_vector(to_unsigned( 212 , 8)),
				 2 => std_logic_vector(to_unsigned( 210 , 8)),
				 3 => std_logic_vector(to_unsigned( 242 , 8)),
				 4 => std_logic_vector(to_unsigned( 180 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 171 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 168 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 168 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 167 , 8)),
				 15 => std_logic_vector(to_unsigned( 99 , 8)),
				 16 => std_logic_vector(to_unsigned( 130 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 81 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 233

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 129 , 8)),
				 3 => std_logic_vector(to_unsigned( 143 , 8)),
				 4 => std_logic_vector(to_unsigned( 100 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 28 , 8)),
				 7 => std_logic_vector(to_unsigned( 239 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 242 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 108 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 67 , 8)),
				 14 => std_logic_vector(to_unsigned( 102 , 8)),
				 15 => std_logic_vector(to_unsigned( 112 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 169 , 8)),
				 18 => std_logic_vector(to_unsigned( 153 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 234

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 177 , 8)),
				 1 => std_logic_vector(to_unsigned( 46 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 53 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 69 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 12 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 19 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 61 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 63 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 63 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 222 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 235

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 161 , 8)),
				 1 => std_logic_vector(to_unsigned( 9 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 54 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 46 , 8)),
				 8 => std_logic_vector(to_unsigned( 217 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 13 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 105 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 106 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 56 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 236

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 39 , 8)),
				 2 => std_logic_vector(to_unsigned( 41 , 8)),
				 3 => std_logic_vector(to_unsigned( 60 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 67 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 97 , 8)),
				 10 => std_logic_vector(to_unsigned( 39 , 8)),
				 11 => std_logic_vector(to_unsigned( 116 , 8)),
				 12 => std_logic_vector(to_unsigned( 20 , 8)),
				 13 => std_logic_vector(to_unsigned( 127 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 164 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 37 , 8)),
				 18 => std_logic_vector(to_unsigned( 60 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 237

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 124 , 8)),
				 1 => std_logic_vector(to_unsigned( 183 , 8)),
				 2 => std_logic_vector(to_unsigned( 253 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 201 , 8)),
				 5 => std_logic_vector(to_unsigned( 189 , 8)),
				 6 => std_logic_vector(to_unsigned( 115 , 8)),
				 7 => std_logic_vector(to_unsigned( 225 , 8)),
				 8 => std_logic_vector(to_unsigned( 79 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 77 , 8)),
				 11 => std_logic_vector(to_unsigned( 107 , 8)),
				 12 => std_logic_vector(to_unsigned( 147 , 8)),
				 13 => std_logic_vector(to_unsigned( 185 , 8)),
				 14 => std_logic_vector(to_unsigned( 69 , 8)),
				 15 => std_logic_vector(to_unsigned( 218 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 20 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 238

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 136 , 8)),
				 1 => std_logic_vector(to_unsigned( 164 , 8)),
				 2 => std_logic_vector(to_unsigned( 144 , 8)),
				 3 => std_logic_vector(to_unsigned( 169 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 73 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 67 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 154 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 249 , 8)),
				 15 => std_logic_vector(to_unsigned( 134 , 8)),
				 16 => std_logic_vector(to_unsigned( 249 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 248 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 239

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 98 , 8)),
				 1 => std_logic_vector(to_unsigned( 164 , 8)),
				 2 => std_logic_vector(to_unsigned( 4 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 148 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 72 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 8 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 71 , 8)),
				 15 => std_logic_vector(to_unsigned( 92 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 217 , 8)),
				 18 => std_logic_vector(to_unsigned( 124 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 240

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 96 , 8)),
				 1 => std_logic_vector(to_unsigned( 197 , 8)),
				 2 => std_logic_vector(to_unsigned( 75 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 131 , 8)),
				 6 => std_logic_vector(to_unsigned( 167 , 8)),
				 7 => std_logic_vector(to_unsigned( 166 , 8)),
				 8 => std_logic_vector(to_unsigned( 132 , 8)),
				 9 => std_logic_vector(to_unsigned( 190 , 8)),
				 10 => std_logic_vector(to_unsigned( 254 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 193 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 192 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 192 , 8)),
				 17 => std_logic_vector(to_unsigned( 135 , 8)),
				 18 => std_logic_vector(to_unsigned( 91 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 241

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 182 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 190 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 116 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 112 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 112 , 8)),
				 11 => std_logic_vector(to_unsigned( 32 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 73 , 8)),
				 14 => std_logic_vector(to_unsigned( 12 , 8)),
				 15 => std_logic_vector(to_unsigned( 79 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 20 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 242

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 30 , 8)),
				 1 => std_logic_vector(to_unsigned( 47 , 8)),
				 2 => std_logic_vector(to_unsigned( 226 , 8)),
				 3 => std_logic_vector(to_unsigned( 78 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 100 , 8)),
				 6 => std_logic_vector(to_unsigned( 21 , 8)),
				 7 => std_logic_vector(to_unsigned( 202 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 72 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 50 , 8)),
				 12 => std_logic_vector(to_unsigned( 147 , 8)),
				 13 => std_logic_vector(to_unsigned( 168 , 8)),
				 14 => std_logic_vector(to_unsigned( 29 , 8)),
				 15 => std_logic_vector(to_unsigned( 187 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 243

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 108 , 8)),
				 2 => std_logic_vector(to_unsigned( 154 , 8)),
				 3 => std_logic_vector(to_unsigned( 127 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 231 , 8)),
				 7 => std_logic_vector(to_unsigned( 17 , 8)),
				 8 => std_logic_vector(to_unsigned( 150 , 8)),
				 9 => std_logic_vector(to_unsigned( 133 , 8)),
				 10 => std_logic_vector(to_unsigned( 34 , 8)),
				 11 => std_logic_vector(to_unsigned( 19 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 197 , 8)),
				 14 => std_logic_vector(to_unsigned( 19 , 8)),
				 15 => std_logic_vector(to_unsigned( 200 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 152 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 244

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 70 , 8)),
				 2 => std_logic_vector(to_unsigned( 115 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 19 , 8)),
				 5 => std_logic_vector(to_unsigned( 175 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 17 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 46 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 144 , 8)),
				 12 => std_logic_vector(to_unsigned( 113 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 164 , 8)),
				 16 => std_logic_vector(to_unsigned( 124 , 8)),
				 17 => std_logic_vector(to_unsigned( 56 , 8)),
				 18 => std_logic_vector(to_unsigned( 238 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 245

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 172 , 8)),
				 1 => std_logic_vector(to_unsigned( 185 , 8)),
				 2 => std_logic_vector(to_unsigned( 20 , 8)),
				 3 => std_logic_vector(to_unsigned( 30 , 8)),
				 4 => std_logic_vector(to_unsigned( 204 , 8)),
				 5 => std_logic_vector(to_unsigned( 145 , 8)),
				 6 => std_logic_vector(to_unsigned( 173 , 8)),
				 7 => std_logic_vector(to_unsigned( 224 , 8)),
				 8 => std_logic_vector(to_unsigned( 216 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 59 , 8)),
				 11 => std_logic_vector(to_unsigned( 22 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 180 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 31 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 246

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 162 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 14 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 8 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 101 , 8)),
				 9 => std_logic_vector(to_unsigned( 117 , 8)),
				 10 => std_logic_vector(to_unsigned( 127 , 8)),
				 11 => std_logic_vector(to_unsigned( 33 , 8)),
				 12 => std_logic_vector(to_unsigned( 76 , 8)),
				 13 => std_logic_vector(to_unsigned( 83 , 8)),
				 14 => std_logic_vector(to_unsigned( 26 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 158 , 8)),
				 18 => std_logic_vector(to_unsigned( 158 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 160 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 247

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 17 , 8)),
				 1 => std_logic_vector(to_unsigned( 18 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 161 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 173 , 8)),
				 6 => std_logic_vector(to_unsigned( 99 , 8)),
				 7 => std_logic_vector(to_unsigned( 111 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 114 , 8)),
				 10 => std_logic_vector(to_unsigned( 207 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 118 , 8)),
				 13 => std_logic_vector(to_unsigned( 85 , 8)),
				 14 => std_logic_vector(to_unsigned( 81 , 8)),
				 15 => std_logic_vector(to_unsigned( 1 , 8)),
				 16 => std_logic_vector(to_unsigned( 161 , 8)),
				 17 => std_logic_vector(to_unsigned( 99 , 8)),
				 18 => std_logic_vector(to_unsigned( 200 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 248

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 142 , 8)),
				 2 => std_logic_vector(to_unsigned( 142 , 8)),
				 3 => std_logic_vector(to_unsigned( 176 , 8)),
				 4 => std_logic_vector(to_unsigned( 108 , 8)),
				 5 => std_logic_vector(to_unsigned( 3 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 110 , 8)),
				 10 => std_logic_vector(to_unsigned( 109 , 8)),
				 11 => std_logic_vector(to_unsigned( 142 , 8)),
				 12 => std_logic_vector(to_unsigned( 77 , 8)),
				 13 => std_logic_vector(to_unsigned( 178 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 189 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 249

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 67 , 8)),
				 2 => std_logic_vector(to_unsigned( 173 , 8)),
				 3 => std_logic_vector(to_unsigned( 146 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 41 , 8)),
				 8 => std_logic_vector(to_unsigned( 45 , 8)),
				 9 => std_logic_vector(to_unsigned( 63 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 177 , 8)),
				 12 => std_logic_vector(to_unsigned( 179 , 8)),
				 13 => std_logic_vector(to_unsigned( 122 , 8)),
				 14 => std_logic_vector(to_unsigned( 225 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 114 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 247 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 250

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 246 , 8)),
				 1 => std_logic_vector(to_unsigned( 37 , 8)),
				 2 => std_logic_vector(to_unsigned( 158 , 8)),
				 3 => std_logic_vector(to_unsigned( 52 , 8)),
				 4 => std_logic_vector(to_unsigned( 143 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 25 , 8)),
				 8 => std_logic_vector(to_unsigned( 128 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 134 , 8)),
				 12 => std_logic_vector(to_unsigned( 19 , 8)),
				 13 => std_logic_vector(to_unsigned( 74 , 8)),
				 14 => std_logic_vector(to_unsigned( 225 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 251

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 32 , 8)),
				 2 => std_logic_vector(to_unsigned( 4 , 8)),
				 3 => std_logic_vector(to_unsigned( 33 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 41 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 41 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 212 , 8)),
				 14 => std_logic_vector(to_unsigned( 71 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 127 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 40 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 252

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 235 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 253 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 49 , 8)),
				 9 => std_logic_vector(to_unsigned( 170 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 180 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 253

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 7 , 8)),
				 2 => std_logic_vector(to_unsigned( 16 , 8)),
				 3 => std_logic_vector(to_unsigned( 22 , 8)),
				 4 => std_logic_vector(to_unsigned( 1 , 8)),
				 5 => std_logic_vector(to_unsigned( 22 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 22 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 22 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 96 , 8)),
				 15 => std_logic_vector(to_unsigned( 35 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 249 , 8)),
				 18 => std_logic_vector(to_unsigned( 118 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 254

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 64 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 12 , 8)),
				 9 => std_logic_vector(to_unsigned( 147 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 155 , 8)),
				 12 => std_logic_vector(to_unsigned( 232 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 150 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 136 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 138 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 255

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 94 , 8)),
				 2 => std_logic_vector(to_unsigned( 100 , 8)),
				 3 => std_logic_vector(to_unsigned( 109 , 8)),
				 4 => std_logic_vector(to_unsigned( 85 , 8)),
				 5 => std_logic_vector(to_unsigned( 212 , 8)),
				 6 => std_logic_vector(to_unsigned( 252 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 231 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 228 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 210 , 8)),
				 13 => std_logic_vector(to_unsigned( 180 , 8)),
				 14 => std_logic_vector(to_unsigned( 251 , 8)),
				 15 => std_logic_vector(to_unsigned( 84 , 8)),
				 16 => std_logic_vector(to_unsigned( 233 , 8)),
				 17 => std_logic_vector(to_unsigned( 169 , 8)),
				 18 => std_logic_vector(to_unsigned( 48 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 256

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 73 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 120 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 95 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 240 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 110 , 8)),
				 9 => std_logic_vector(to_unsigned( 210 , 8)),
				 10 => std_logic_vector(to_unsigned( 36 , 8)),
				 11 => std_logic_vector(to_unsigned( 168 , 8)),
				 12 => std_logic_vector(to_unsigned( 183 , 8)),
				 13 => std_logic_vector(to_unsigned( 120 , 8)),
				 14 => std_logic_vector(to_unsigned( 56 , 8)),
				 15 => std_logic_vector(to_unsigned( 139 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 237 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 257

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 171 , 8)),
				 2 => std_logic_vector(to_unsigned( 59 , 8)),
				 3 => std_logic_vector(to_unsigned( 196 , 8)),
				 4 => std_logic_vector(to_unsigned( 34 , 8)),
				 5 => std_logic_vector(to_unsigned( 206 , 8)),
				 6 => std_logic_vector(to_unsigned( 98 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 102 , 8)),
				 10 => std_logic_vector(to_unsigned( 101 , 8)),
				 11 => std_logic_vector(to_unsigned( 121 , 8)),
				 12 => std_logic_vector(to_unsigned( 82 , 8)),
				 13 => std_logic_vector(to_unsigned( 168 , 8)),
				 14 => std_logic_vector(to_unsigned( 50 , 8)),
				 15 => std_logic_vector(to_unsigned( 230 , 8)),
				 16 => std_logic_vector(to_unsigned( 72 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 251 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 258

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 130 , 8)),
				 1 => std_logic_vector(to_unsigned( 4 , 8)),
				 2 => std_logic_vector(to_unsigned( 97 , 8)),
				 3 => std_logic_vector(to_unsigned( 60 , 8)),
				 4 => std_logic_vector(to_unsigned( 225 , 8)),
				 5 => std_logic_vector(to_unsigned( 145 , 8)),
				 6 => std_logic_vector(to_unsigned( 140 , 8)),
				 7 => std_logic_vector(to_unsigned( 149 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 79 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 115 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 120 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 44 , 8)),
				 16 => std_logic_vector(to_unsigned( 56 , 8)),
				 17 => std_logic_vector(to_unsigned( 5 , 8)),
				 18 => std_logic_vector(to_unsigned( 37 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 259

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 92 , 8)),
				 1 => std_logic_vector(to_unsigned( 15 , 8)),
				 2 => std_logic_vector(to_unsigned( 196 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 76 , 8)),
				 6 => std_logic_vector(to_unsigned( 215 , 8)),
				 7 => std_logic_vector(to_unsigned( 7 , 8)),
				 8 => std_logic_vector(to_unsigned( 44 , 8)),
				 9 => std_logic_vector(to_unsigned( 28 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 32 , 8)),
				 12 => std_logic_vector(to_unsigned( 19 , 8)),
				 13 => std_logic_vector(to_unsigned( 130 , 8)),
				 14 => std_logic_vector(to_unsigned( 91 , 8)),
				 15 => std_logic_vector(to_unsigned( 56 , 8)),
				 16 => std_logic_vector(to_unsigned( 187 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 19 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 260

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 64 , 8)),
				 1 => std_logic_vector(to_unsigned( 139 , 8)),
				 2 => std_logic_vector(to_unsigned( 117 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 59 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 13 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 55 , 8)),
				 12 => std_logic_vector(to_unsigned( 171 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 74 , 8)),
				 18 => std_logic_vector(to_unsigned( 18 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 261

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 80 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 53 , 8)),
				 4 => std_logic_vector(to_unsigned( 120 , 8)),
				 5 => std_logic_vector(to_unsigned( 59 , 8)),
				 6 => std_logic_vector(to_unsigned( 114 , 8)),
				 7 => std_logic_vector(to_unsigned( 120 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 89 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 87 , 8)),
				 16 => std_logic_vector(to_unsigned( 149 , 8)),
				 17 => std_logic_vector(to_unsigned( 226 , 8)),
				 18 => std_logic_vector(to_unsigned( 113 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 262

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 141 , 8)),
				 1 => std_logic_vector(to_unsigned( 223 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 87 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 101 , 8)),
				 6 => std_logic_vector(to_unsigned( 186 , 8)),
				 7 => std_logic_vector(to_unsigned( 126 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 185 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 134 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 48 , 8)),
				 16 => std_logic_vector(to_unsigned( 188 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 180 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 263

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 144 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 71 , 8)),
				 8 => std_logic_vector(to_unsigned( 154 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 115 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 145 , 8)),
				 18 => std_logic_vector(to_unsigned( 96 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 264

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 195 , 8)),
				 1 => std_logic_vector(to_unsigned( 178 , 8)),
				 2 => std_logic_vector(to_unsigned( 2 , 8)),
				 3 => std_logic_vector(to_unsigned( 178 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 35 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 203 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 42 , 8)),
				 10 => std_logic_vector(to_unsigned( 199 , 8)),
				 11 => std_logic_vector(to_unsigned( 159 , 8)),
				 12 => std_logic_vector(to_unsigned( 166 , 8)),
				 13 => std_logic_vector(to_unsigned( 31 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 15 , 8)),
				 16 => std_logic_vector(to_unsigned( 136 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 265

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 138 , 8)),
				 2 => std_logic_vector(to_unsigned( 194 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 82 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 81 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 39 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 240 , 8)),
				 13 => std_logic_vector(to_unsigned( 11 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 89 , 8)),
				 16 => std_logic_vector(to_unsigned( 254 , 8)),
				 17 => std_logic_vector(to_unsigned( 227 , 8)),
				 18 => std_logic_vector(to_unsigned( 204 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 266

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 148 , 8)),
				 1 => std_logic_vector(to_unsigned( 48 , 8)),
				 2 => std_logic_vector(to_unsigned( 133 , 8)),
				 3 => std_logic_vector(to_unsigned( 106 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 194 , 8)),
				 6 => std_logic_vector(to_unsigned( 238 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 191 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 186 , 8)),
				 11 => std_logic_vector(to_unsigned( 250 , 8)),
				 12 => std_logic_vector(to_unsigned( 182 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 177 , 8)),
				 15 => std_logic_vector(to_unsigned( 124 , 8)),
				 16 => std_logic_vector(to_unsigned( 95 , 8)),
				 17 => std_logic_vector(to_unsigned( 250 , 8)),
				 18 => std_logic_vector(to_unsigned( 70 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 267

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 87 , 8)),
				 1 => std_logic_vector(to_unsigned( 25 , 8)),
				 2 => std_logic_vector(to_unsigned( 40 , 8)),
				 3 => std_logic_vector(to_unsigned( 94 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 66 , 8)),
				 6 => std_logic_vector(to_unsigned( 230 , 8)),
				 7 => std_logic_vector(to_unsigned( 117 , 8)),
				 8 => std_logic_vector(to_unsigned( 179 , 8)),
				 9 => std_logic_vector(to_unsigned( 83 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 194 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 158 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 71 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 268

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 136 , 8)),
				 2 => std_logic_vector(to_unsigned( 215 , 8)),
				 3 => std_logic_vector(to_unsigned( 38 , 8)),
				 4 => std_logic_vector(to_unsigned( 92 , 8)),
				 5 => std_logic_vector(to_unsigned( 100 , 8)),
				 6 => std_logic_vector(to_unsigned( 188 , 8)),
				 7 => std_logic_vector(to_unsigned( 4 , 8)),
				 8 => std_logic_vector(to_unsigned( 102 , 8)),
				 9 => std_logic_vector(to_unsigned( 171 , 8)),
				 10 => std_logic_vector(to_unsigned( 239 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 122 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 111 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 195 , 8)),
				 18 => std_logic_vector(to_unsigned( 115 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 269

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 249 , 8)),
				 1 => std_logic_vector(to_unsigned( 150 , 8)),
				 2 => std_logic_vector(to_unsigned( 201 , 8)),
				 3 => std_logic_vector(to_unsigned( 26 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 31 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 1 , 8)),
				 8 => std_logic_vector(to_unsigned( 221 , 8)),
				 9 => std_logic_vector(to_unsigned( 82 , 8)),
				 10 => std_logic_vector(to_unsigned( 115 , 8)),
				 11 => std_logic_vector(to_unsigned( 217 , 8)),
				 12 => std_logic_vector(to_unsigned( 54 , 8)),
				 13 => std_logic_vector(to_unsigned( 81 , 8)),
				 14 => std_logic_vector(to_unsigned( 208 , 8)),
				 15 => std_logic_vector(to_unsigned( 187 , 8)),
				 16 => std_logic_vector(to_unsigned( 102 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 79 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 270

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 180 , 8)),
				 1 => std_logic_vector(to_unsigned( 126 , 8)),
				 2 => std_logic_vector(to_unsigned( 243 , 8)),
				 3 => std_logic_vector(to_unsigned( 222 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 249 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 224 , 8)),
				 9 => std_logic_vector(to_unsigned( 226 , 8)),
				 10 => std_logic_vector(to_unsigned( 122 , 8)),
				 11 => std_logic_vector(to_unsigned( 248 , 8)),
				 12 => std_logic_vector(to_unsigned( 100 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 95 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 94 , 8)),
				 17 => std_logic_vector(to_unsigned( 24 , 8)),
				 18 => std_logic_vector(to_unsigned( 148 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 271

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 249 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 243 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 243 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 243 , 8)),
				 9 => std_logic_vector(to_unsigned( 214 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 221 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 7 , 8)),
				 16 => std_logic_vector(to_unsigned( 233 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 272

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 114 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 9 , 8)),
				 5 => std_logic_vector(to_unsigned( 128 , 8)),
				 6 => std_logic_vector(to_unsigned( 189 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 164 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 203 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 117 , 8)),
				 17 => std_logic_vector(to_unsigned( 97 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 273

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 75 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 106 , 8)),
				 4 => std_logic_vector(to_unsigned( 218 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 97 , 8)),
				 7 => std_logic_vector(to_unsigned( 24 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 68 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 75 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 149 , 8)),
				 14 => std_logic_vector(to_unsigned( 207 , 8)),
				 15 => std_logic_vector(to_unsigned( 7 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 151 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 274

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 142 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 56 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 113 , 8)),
				 10 => std_logic_vector(to_unsigned( 24 , 8)),
				 11 => std_logic_vector(to_unsigned( 55 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 83 , 8)),
				 14 => std_logic_vector(to_unsigned( 50 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 239 , 8)),
				 17 => std_logic_vector(to_unsigned( 85 , 8)),
				 18 => std_logic_vector(to_unsigned( 218 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 275

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 180 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 236 , 8)),
				 5 => std_logic_vector(to_unsigned( 211 , 8)),
				 6 => std_logic_vector(to_unsigned( 87 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 139 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 66 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 71 , 8)),
				 18 => std_logic_vector(to_unsigned( 76 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 276

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 1 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 41 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 4 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 43 , 8)),
				 10 => std_logic_vector(to_unsigned( 122 , 8)),
				 11 => std_logic_vector(to_unsigned( 22 , 8)),
				 12 => std_logic_vector(to_unsigned( 115 , 8)),
				 13 => std_logic_vector(to_unsigned( 55 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 67 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 168 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 277

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 193 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 19 , 8)),
				 7 => std_logic_vector(to_unsigned( 78 , 8)),
				 8 => std_logic_vector(to_unsigned( 162 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 29 , 8)),
				 11 => std_logic_vector(to_unsigned( 215 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 235 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 24 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 278

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 30 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 50 , 8)),
				 5 => std_logic_vector(to_unsigned( 216 , 8)),
				 6 => std_logic_vector(to_unsigned( 127 , 8)),
				 7 => std_logic_vector(to_unsigned( 49 , 8)),
				 8 => std_logic_vector(to_unsigned( 241 , 8)),
				 9 => std_logic_vector(to_unsigned( 108 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 163 , 8)),
				 12 => std_logic_vector(to_unsigned( 195 , 8)),
				 13 => std_logic_vector(to_unsigned( 90 , 8)),
				 14 => std_logic_vector(to_unsigned( 124 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 216 , 8)),
				 17 => std_logic_vector(to_unsigned( 127 , 8)),
				 18 => std_logic_vector(to_unsigned( 147 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 279

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 0 , 8)),
				 2 => std_logic_vector(to_unsigned( 110 , 8)),
				 3 => std_logic_vector(to_unsigned( 81 , 8)),
				 4 => std_logic_vector(to_unsigned( 29 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 95 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 100 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 36 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 37 , 8)),
				 16 => std_logic_vector(to_unsigned( 217 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 280

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 124 , 8)),
				 1 => std_logic_vector(to_unsigned( 248 , 8)),
				 2 => std_logic_vector(to_unsigned( 75 , 8)),
				 3 => std_logic_vector(to_unsigned( 92 , 8)),
				 4 => std_logic_vector(to_unsigned( 69 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 150 , 8)),
				 8 => std_logic_vector(to_unsigned( 183 , 8)),
				 9 => std_logic_vector(to_unsigned( 28 , 8)),
				 10 => std_logic_vector(to_unsigned( 158 , 8)),
				 11 => std_logic_vector(to_unsigned( 170 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 185 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 133 , 8)),
				 16 => std_logic_vector(to_unsigned( 160 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 281

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 132 , 8)),
				 2 => std_logic_vector(to_unsigned( 36 , 8)),
				 3 => std_logic_vector(to_unsigned( 145 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 166 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 207 , 8)),
				 8 => std_logic_vector(to_unsigned( 247 , 8)),
				 9 => std_logic_vector(to_unsigned( 189 , 8)),
				 10 => std_logic_vector(to_unsigned( 173 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 54 , 8)),
				 14 => std_logic_vector(to_unsigned( 43 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 232 , 8)),
				 17 => std_logic_vector(to_unsigned( 19 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 282

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 247 , 8)),
				 1 => std_logic_vector(to_unsigned( 240 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 132 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 128 , 8)),
				 7 => std_logic_vector(to_unsigned( 54 , 8)),
				 8 => std_logic_vector(to_unsigned( 182 , 8)),
				 9 => std_logic_vector(to_unsigned( 46 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 156 , 8)),
				 13 => std_logic_vector(to_unsigned( 235 , 8)),
				 14 => std_logic_vector(to_unsigned( 142 , 8)),
				 15 => std_logic_vector(to_unsigned( 113 , 8)),
				 16 => std_logic_vector(to_unsigned( 20 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 283

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 28 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 208 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 209 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 56 , 8)),
				 12 => std_logic_vector(to_unsigned( 74 , 8)),
				 13 => std_logic_vector(to_unsigned( 8 , 8)),
				 14 => std_logic_vector(to_unsigned( 179 , 8)),
				 15 => std_logic_vector(to_unsigned( 75 , 8)),
				 16 => std_logic_vector(to_unsigned( 112 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 164 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 284

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 162 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 31 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 97 , 8)),
				 8 => std_logic_vector(to_unsigned( 218 , 8)),
				 9 => std_logic_vector(to_unsigned( 70 , 8)),
				 10 => std_logic_vector(to_unsigned( 164 , 8)),
				 11 => std_logic_vector(to_unsigned( 149 , 8)),
				 12 => std_logic_vector(to_unsigned( 45 , 8)),
				 13 => std_logic_vector(to_unsigned( 216 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 217 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 285

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 109 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 135 , 8)),
				 4 => std_logic_vector(to_unsigned( 179 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 90 , 8)),
				 9 => std_logic_vector(to_unsigned( 197 , 8)),
				 10 => std_logic_vector(to_unsigned( 114 , 8)),
				 11 => std_logic_vector(to_unsigned( 205 , 8)),
				 12 => std_logic_vector(to_unsigned( 106 , 8)),
				 13 => std_logic_vector(to_unsigned( 163 , 8)),
				 14 => std_logic_vector(to_unsigned( 114 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 38 , 8)),
				 18 => std_logic_vector(to_unsigned( 19 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 286

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 251 , 8)),
				 1 => std_logic_vector(to_unsigned( 250 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 76 , 8)),
				 4 => std_logic_vector(to_unsigned( 197 , 8)),
				 5 => std_logic_vector(to_unsigned( 144 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 95 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 84 , 8)),
				 10 => std_logic_vector(to_unsigned( 202 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 63 , 8)),
				 13 => std_logic_vector(to_unsigned( 109 , 8)),
				 14 => std_logic_vector(to_unsigned( 69 , 8)),
				 15 => std_logic_vector(to_unsigned( 135 , 8)),
				 16 => std_logic_vector(to_unsigned( 43 , 8)),
				 17 => std_logic_vector(to_unsigned( 220 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 287

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 63 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 196 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 235 , 8)),
				 12 => std_logic_vector(to_unsigned( 61 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 41 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 196 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 288

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 59 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 168 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 17 , 8)),
				 16 => std_logic_vector(to_unsigned( 93 , 8)),
				 17 => std_logic_vector(to_unsigned( 244 , 8)),
				 18 => std_logic_vector(to_unsigned( 124 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 58 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 289

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 191 , 8)),
				 1 => std_logic_vector(to_unsigned( 77 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 53 , 8)),
				 4 => std_logic_vector(to_unsigned( 89 , 8)),
				 5 => std_logic_vector(to_unsigned( 82 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 82 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 11 , 8)),
				 10 => std_logic_vector(to_unsigned( 209 , 8)),
				 11 => std_logic_vector(to_unsigned( 63 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 7 , 8)),
				 14 => std_logic_vector(to_unsigned( 104 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 215 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 167 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 290

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 19 , 8)),
				 2 => std_logic_vector(to_unsigned( 184 , 8)),
				 3 => std_logic_vector(to_unsigned( 200 , 8)),
				 4 => std_logic_vector(to_unsigned( 107 , 8)),
				 5 => std_logic_vector(to_unsigned( 228 , 8)),
				 6 => std_logic_vector(to_unsigned( 176 , 8)),
				 7 => std_logic_vector(to_unsigned( 184 , 8)),
				 8 => std_logic_vector(to_unsigned( 207 , 8)),
				 9 => std_logic_vector(to_unsigned( 90 , 8)),
				 10 => std_logic_vector(to_unsigned( 123 , 8)),
				 11 => std_logic_vector(to_unsigned( 27 , 8)),
				 12 => std_logic_vector(to_unsigned( 68 , 8)),
				 13 => std_logic_vector(to_unsigned( 65 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 116 , 8)),
				 16 => std_logic_vector(to_unsigned( 140 , 8)),
				 17 => std_logic_vector(to_unsigned( 195 , 8)),
				 18 => std_logic_vector(to_unsigned( 86 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 291

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 137 , 8)),
				 1 => std_logic_vector(to_unsigned( 1 , 8)),
				 2 => std_logic_vector(to_unsigned( 66 , 8)),
				 3 => std_logic_vector(to_unsigned( 65 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 66 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 66 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 66 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 66 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 77 , 8)),
				 15 => std_logic_vector(to_unsigned( 54 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 91 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 292

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 77 , 8)),
				 1 => std_logic_vector(to_unsigned( 23 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 16 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 59 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 56 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 79 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 181 , 8)),
				 16 => std_logic_vector(to_unsigned( 159 , 8)),
				 17 => std_logic_vector(to_unsigned( 52 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 293

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 77 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 62 , 8)),
				 5 => std_logic_vector(to_unsigned( 120 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 80 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 137 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 45 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 173 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 294

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 110 , 8)),
				 2 => std_logic_vector(to_unsigned( 242 , 8)),
				 3 => std_logic_vector(to_unsigned( 28 , 8)),
				 4 => std_logic_vector(to_unsigned( 136 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 89 , 8)),
				 7 => std_logic_vector(to_unsigned( 166 , 8)),
				 8 => std_logic_vector(to_unsigned( 59 , 8)),
				 9 => std_logic_vector(to_unsigned( 167 , 8)),
				 10 => std_logic_vector(to_unsigned( 58 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 118 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 72 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 234 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 295

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 117 , 8)),
				 1 => std_logic_vector(to_unsigned( 26 , 8)),
				 2 => std_logic_vector(to_unsigned( 180 , 8)),
				 3 => std_logic_vector(to_unsigned( 169 , 8)),
				 4 => std_logic_vector(to_unsigned( 37 , 8)),
				 5 => std_logic_vector(to_unsigned( 175 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 65 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 68 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 233 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 235 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 296

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 174 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 50 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 240 , 8)),
				 9 => std_logic_vector(to_unsigned( 216 , 8)),
				 10 => std_logic_vector(to_unsigned( 90 , 8)),
				 11 => std_logic_vector(to_unsigned( 215 , 8)),
				 12 => std_logic_vector(to_unsigned( 247 , 8)),
				 13 => std_logic_vector(to_unsigned( 126 , 8)),
				 14 => std_logic_vector(to_unsigned( 73 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 208 , 8)),
				 17 => std_logic_vector(to_unsigned( 90 , 8)),
				 18 => std_logic_vector(to_unsigned( 46 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 297

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 245 , 8)),
				 2 => std_logic_vector(to_unsigned( 32 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 187 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 219 , 8)),
				 7 => std_logic_vector(to_unsigned( 101 , 8)),
				 8 => std_logic_vector(to_unsigned( 213 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 204 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 166 , 8)),
				 13 => std_logic_vector(to_unsigned( 4 , 8)),
				 14 => std_logic_vector(to_unsigned( 158 , 8)),
				 15 => std_logic_vector(to_unsigned( 55 , 8)),
				 16 => std_logic_vector(to_unsigned( 107 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 1 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 298

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 150 , 8)),
				 3 => std_logic_vector(to_unsigned( 142 , 8)),
				 4 => std_logic_vector(to_unsigned( 113 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 170 , 8)),
				 7 => std_logic_vector(to_unsigned( 73 , 8)),
				 8 => std_logic_vector(to_unsigned( 155 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 181 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 239 , 8)),
				 14 => std_logic_vector(to_unsigned( 140 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 133 , 8)),
				 17 => std_logic_vector(to_unsigned( 37 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 299

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 55 , 8)),
				 1 => std_logic_vector(to_unsigned( 39 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 224 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 210 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 230 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 225 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 217 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 215 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 234 , 8)),
				 18 => std_logic_vector(to_unsigned( 50 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 300

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 98 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 163 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 147 , 8)),
				 7 => std_logic_vector(to_unsigned( 54 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 78 , 8)),
				 10 => std_logic_vector(to_unsigned( 27 , 8)),
				 11 => std_logic_vector(to_unsigned( 103 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 104 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 68 , 8)),
				 16 => std_logic_vector(to_unsigned( 163 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 301

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 191 , 8)),
				 1 => std_logic_vector(to_unsigned( 21 , 8)),
				 2 => std_logic_vector(to_unsigned( 26 , 8)),
				 3 => std_logic_vector(to_unsigned( 61 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 44 , 8)),
				 6 => std_logic_vector(to_unsigned( 200 , 8)),
				 7 => std_logic_vector(to_unsigned( 92 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 202 , 8)),
				 12 => std_logic_vector(to_unsigned( 159 , 8)),
				 13 => std_logic_vector(to_unsigned( 206 , 8)),
				 14 => std_logic_vector(to_unsigned( 155 , 8)),
				 15 => std_logic_vector(to_unsigned( 171 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 302

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 70 , 8)),
				 1 => std_logic_vector(to_unsigned( 163 , 8)),
				 2 => std_logic_vector(to_unsigned( 60 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 76 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 42 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 212 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 111 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 303

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 151 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 75 , 8)),
				 3 => std_logic_vector(to_unsigned( 111 , 8)),
				 4 => std_logic_vector(to_unsigned( 54 , 8)),
				 5 => std_logic_vector(to_unsigned( 115 , 8)),
				 6 => std_logic_vector(to_unsigned( 50 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 51 , 8)),
				 10 => std_logic_vector(to_unsigned( 30 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 190 , 8)),
				 13 => std_logic_vector(to_unsigned( 209 , 8)),
				 14 => std_logic_vector(to_unsigned( 87 , 8)),
				 15 => std_logic_vector(to_unsigned( 31 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 255 , 8)),
				 18 => std_logic_vector(to_unsigned( 86 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 7 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 304

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 74 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 76 , 8)),
				 4 => std_logic_vector(to_unsigned( 1 , 8)),
				 5 => std_logic_vector(to_unsigned( 76 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 32 , 8)),
				 8 => std_logic_vector(to_unsigned( 141 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 108 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 20 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 193 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 141 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 112 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 305

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 212 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 55 , 8)),
				 6 => std_logic_vector(to_unsigned( 164 , 8)),
				 7 => std_logic_vector(to_unsigned( 0 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 192 , 8)),
				 11 => std_logic_vector(to_unsigned( 243 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 2 , 8)),
				 14 => std_logic_vector(to_unsigned( 37 , 8)),
				 15 => std_logic_vector(to_unsigned( 28 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 306

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 199 , 8)),
				 1 => std_logic_vector(to_unsigned( 66 , 8)),
				 2 => std_logic_vector(to_unsigned( 232 , 8)),
				 3 => std_logic_vector(to_unsigned( 105 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 79 , 8)),
				 7 => std_logic_vector(to_unsigned( 75 , 8)),
				 8 => std_logic_vector(to_unsigned( 167 , 8)),
				 9 => std_logic_vector(to_unsigned( 234 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 154 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 234 , 8)),
				 18 => std_logic_vector(to_unsigned( 2 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 307

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 161 , 8)),
				 3 => std_logic_vector(to_unsigned( 215 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 192 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 189 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 187 , 8)),
				 11 => std_logic_vector(to_unsigned( 42 , 8)),
				 12 => std_logic_vector(to_unsigned( 97 , 8)),
				 13 => std_logic_vector(to_unsigned( 77 , 8)),
				 14 => std_logic_vector(to_unsigned( 62 , 8)),
				 15 => std_logic_vector(to_unsigned( 130 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 244 , 8)),
				 18 => std_logic_vector(to_unsigned( 96 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 308

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 155 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 132 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 19 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 110 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 247 , 8)),
				 13 => std_logic_vector(to_unsigned( 140 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 144 , 8)),
				 16 => std_logic_vector(to_unsigned( 116 , 8)),
				 17 => std_logic_vector(to_unsigned( 107 , 8)),
				 18 => std_logic_vector(to_unsigned( 104 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 309

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 29 , 8)),
				 2 => std_logic_vector(to_unsigned( 242 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 48 , 8)),
				 8 => std_logic_vector(to_unsigned( 119 , 8)),
				 9 => std_logic_vector(to_unsigned( 84 , 8)),
				 10 => std_logic_vector(to_unsigned( 83 , 8)),
				 11 => std_logic_vector(to_unsigned( 102 , 8)),
				 12 => std_logic_vector(to_unsigned( 65 , 8)),
				 13 => std_logic_vector(to_unsigned( 127 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 50 , 8)),
				 16 => std_logic_vector(to_unsigned( 242 , 8)),
				 17 => std_logic_vector(to_unsigned( 44 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 112 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 310

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 60 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 65 , 8)),
				 4 => std_logic_vector(to_unsigned( 225 , 8)),
				 5 => std_logic_vector(to_unsigned( 81 , 8)),
				 6 => std_logic_vector(to_unsigned( 209 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 165 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 158 , 8)),
				 12 => std_logic_vector(to_unsigned( 184 , 8)),
				 13 => std_logic_vector(to_unsigned( 61 , 8)),
				 14 => std_logic_vector(to_unsigned( 231 , 8)),
				 15 => std_logic_vector(to_unsigned( 160 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 220 , 8)),
				 18 => std_logic_vector(to_unsigned( 50 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 311

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 9 , 8)),
				 2 => std_logic_vector(to_unsigned( 243 , 8)),
				 3 => std_logic_vector(to_unsigned( 103 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 121 , 8)),
				 6 => std_logic_vector(to_unsigned( 121 , 8)),
				 7 => std_logic_vector(to_unsigned( 182 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 69 , 8)),
				 10 => std_logic_vector(to_unsigned( 253 , 8)),
				 11 => std_logic_vector(to_unsigned( 179 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 70 , 8)),
				 15 => std_logic_vector(to_unsigned( 22 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 236 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 312

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 182 , 8)),
				 3 => std_logic_vector(to_unsigned( 198 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 227 , 8)),
				 6 => std_logic_vector(to_unsigned( 80 , 8)),
				 7 => std_logic_vector(to_unsigned( 14 , 8)),
				 8 => std_logic_vector(to_unsigned( 68 , 8)),
				 9 => std_logic_vector(to_unsigned( 32 , 8)),
				 10 => std_logic_vector(to_unsigned( 50 , 8)),
				 11 => std_logic_vector(to_unsigned( 42 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 76 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 77 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 161 , 8)),
				 18 => std_logic_vector(to_unsigned( 125 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 313

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 80 , 8)),
				 1 => std_logic_vector(to_unsigned( 194 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 198 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 238 , 8)),
				 8 => std_logic_vector(to_unsigned( 159 , 8)),
				 9 => std_logic_vector(to_unsigned( 112 , 8)),
				 10 => std_logic_vector(to_unsigned( 155 , 8)),
				 11 => std_logic_vector(to_unsigned( 181 , 8)),
				 12 => std_logic_vector(to_unsigned( 193 , 8)),
				 13 => std_logic_vector(to_unsigned( 183 , 8)),
				 14 => std_logic_vector(to_unsigned( 191 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 159 , 8)),
				 17 => std_logic_vector(to_unsigned( 14 , 8)),
				 18 => std_logic_vector(to_unsigned( 220 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 314

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 253 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 124 , 8)),
				 5 => std_logic_vector(to_unsigned( 92 , 8)),
				 6 => std_logic_vector(to_unsigned( 107 , 8)),
				 7 => std_logic_vector(to_unsigned( 166 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 173 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 97 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 234 , 8)),
				 16 => std_logic_vector(to_unsigned( 142 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 315

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 23 , 8)),
				 2 => std_logic_vector(to_unsigned( 150 , 8)),
				 3 => std_logic_vector(to_unsigned( 73 , 8)),
				 4 => std_logic_vector(to_unsigned( 100 , 8)),
				 5 => std_logic_vector(to_unsigned( 135 , 8)),
				 6 => std_logic_vector(to_unsigned( 38 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 217 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 94 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 48 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 316

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 149 , 8)),
				 2 => std_logic_vector(to_unsigned( 44 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 27 , 8)),
				 5 => std_logic_vector(to_unsigned( 169 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 192 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 192 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 164 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 317

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 70 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 71 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 226 , 8)),
				 8 => std_logic_vector(to_unsigned( 35 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 135 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 12 , 8)),
				 16 => std_logic_vector(to_unsigned( 208 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 194 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 318

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 7 , 8)),
				 1 => std_logic_vector(to_unsigned( 25 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 114 , 8)),
				 4 => std_logic_vector(to_unsigned( 48 , 8)),
				 5 => std_logic_vector(to_unsigned( 119 , 8)),
				 6 => std_logic_vector(to_unsigned( 43 , 8)),
				 7 => std_logic_vector(to_unsigned( 154 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 157 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 150 , 8)),
				 14 => std_logic_vector(to_unsigned( 208 , 8)),
				 15 => std_logic_vector(to_unsigned( 6 , 8)),
				 16 => std_logic_vector(to_unsigned( 149 , 8)),
				 17 => std_logic_vector(to_unsigned( 177 , 8)),
				 18 => std_logic_vector(to_unsigned( 229 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 319

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 115 , 8)),
				 1 => std_logic_vector(to_unsigned( 252 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 175 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 174 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 174 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 7 , 8)),
				 12 => std_logic_vector(to_unsigned( 166 , 8)),
				 13 => std_logic_vector(to_unsigned( 12 , 8)),
				 14 => std_logic_vector(to_unsigned( 116 , 8)),
				 15 => std_logic_vector(to_unsigned( 83 , 8)),
				 16 => std_logic_vector(to_unsigned( 45 , 8)),
				 17 => std_logic_vector(to_unsigned( 149 , 8)),
				 18 => std_logic_vector(to_unsigned( 115 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 320

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 164 , 8)),
				 2 => std_logic_vector(to_unsigned( 170 , 8)),
				 3 => std_logic_vector(to_unsigned( 195 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 182 , 8)),
				 6 => std_logic_vector(to_unsigned( 54 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 107 , 8)),
				 11 => std_logic_vector(to_unsigned( 185 , 8)),
				 12 => std_logic_vector(to_unsigned( 198 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 158 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 128 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 321

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 76 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 81 , 8)),
				 5 => std_logic_vector(to_unsigned( 238 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 1 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 134 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 99 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 83 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 120 , 8)),
				 18 => std_logic_vector(to_unsigned( 72 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 322

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 36 , 8)),
				 1 => std_logic_vector(to_unsigned( 22 , 8)),
				 2 => std_logic_vector(to_unsigned( 183 , 8)),
				 3 => std_logic_vector(to_unsigned( 37 , 8)),
				 4 => std_logic_vector(to_unsigned( 168 , 8)),
				 5 => std_logic_vector(to_unsigned( 133 , 8)),
				 6 => std_logic_vector(to_unsigned( 203 , 8)),
				 7 => std_logic_vector(to_unsigned( 164 , 8)),
				 8 => std_logic_vector(to_unsigned( 172 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 193 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 193 , 8)),
				 13 => std_logic_vector(to_unsigned( 57 , 8)),
				 14 => std_logic_vector(to_unsigned( 26 , 8)),
				 15 => std_logic_vector(to_unsigned( 4 , 8)),
				 16 => std_logic_vector(to_unsigned( 204 , 8)),
				 17 => std_logic_vector(to_unsigned( 70 , 8)),
				 18 => std_logic_vector(to_unsigned( 155 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 323

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 15 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 151 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 21 , 8)),
				 7 => std_logic_vector(to_unsigned( 180 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 50 , 8)),
				 10 => std_logic_vector(to_unsigned( 115 , 8)),
				 11 => std_logic_vector(to_unsigned( 87 , 8)),
				 12 => std_logic_vector(to_unsigned( 171 , 8)),
				 13 => std_logic_vector(to_unsigned( 234 , 8)),
				 14 => std_logic_vector(to_unsigned( 24 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 12 , 8)),
				 17 => std_logic_vector(to_unsigned( 48 , 8)),
				 18 => std_logic_vector(to_unsigned( 87 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 324

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 207 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 45 , 8)),
				 5 => std_logic_vector(to_unsigned( 239 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 17 , 8)),
				 13 => std_logic_vector(to_unsigned( 114 , 8)),
				 14 => std_logic_vector(to_unsigned( 146 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 88 , 8)),
				 17 => std_logic_vector(to_unsigned( 125 , 8)),
				 18 => std_logic_vector(to_unsigned( 104 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 325

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 154 , 8)),
				 1 => std_logic_vector(to_unsigned( 185 , 8)),
				 2 => std_logic_vector(to_unsigned( 244 , 8)),
				 3 => std_logic_vector(to_unsigned( 86 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 36 , 8)),
				 6 => std_logic_vector(to_unsigned( 230 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 198 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 195 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 194 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 237 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 326

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 150 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 203 , 8)),
				 4 => std_logic_vector(to_unsigned( 217 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 205 , 8)),
				 7 => std_logic_vector(to_unsigned( 129 , 8)),
				 8 => std_logic_vector(to_unsigned( 232 , 8)),
				 9 => std_logic_vector(to_unsigned( 39 , 8)),
				 10 => std_logic_vector(to_unsigned( 156 , 8)),
				 11 => std_logic_vector(to_unsigned( 21 , 8)),
				 12 => std_logic_vector(to_unsigned( 169 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 134 , 8)),
				 16 => std_logic_vector(to_unsigned( 56 , 8)),
				 17 => std_logic_vector(to_unsigned( 218 , 8)),
				 18 => std_logic_vector(to_unsigned( 110 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 327

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 7 , 8)),
				 4 => std_logic_vector(to_unsigned( 197 , 8)),
				 5 => std_logic_vector(to_unsigned( 49 , 8)),
				 6 => std_logic_vector(to_unsigned( 251 , 8)),
				 7 => std_logic_vector(to_unsigned( 11 , 8)),
				 8 => std_logic_vector(to_unsigned( 153 , 8)),
				 9 => std_logic_vector(to_unsigned( 161 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 163 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 163 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 10 , 8)),
				 16 => std_logic_vector(to_unsigned( 56 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 328

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 166 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 205 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 39 , 8)),
				 6 => std_logic_vector(to_unsigned( 132 , 8)),
				 7 => std_logic_vector(to_unsigned( 111 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 148 , 8)),
				 10 => std_logic_vector(to_unsigned( 242 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 47 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 91 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 329

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 50 , 8)),
				 2 => std_logic_vector(to_unsigned( 146 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 16 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 217 , 8)),
				 8 => std_logic_vector(to_unsigned( 40 , 8)),
				 9 => std_logic_vector(to_unsigned( 182 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 73 , 8)),
				 14 => std_logic_vector(to_unsigned( 122 , 8)),
				 15 => std_logic_vector(to_unsigned( 120 , 8)),
				 16 => std_logic_vector(to_unsigned( 75 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 194 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 330

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 76 , 8)),
				 3 => std_logic_vector(to_unsigned( 10 , 8)),
				 4 => std_logic_vector(to_unsigned( 145 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 114 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 30 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 86 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 331

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 222 , 8)),
				 2 => std_logic_vector(to_unsigned( 174 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 144 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 142 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 201 , 8)),
				 11 => std_logic_vector(to_unsigned( 218 , 8)),
				 12 => std_logic_vector(to_unsigned( 142 , 8)),
				 13 => std_logic_vector(to_unsigned( 230 , 8)),
				 14 => std_logic_vector(to_unsigned( 130 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 220 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 236 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 332

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 203 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 198 , 8)),
				 5 => std_logic_vector(to_unsigned( 20 , 8)),
				 6 => std_logic_vector(to_unsigned( 108 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 254 , 8)),
				 9 => std_logic_vector(to_unsigned( 110 , 8)),
				 10 => std_logic_vector(to_unsigned( 251 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 138 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 138 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 237 , 8)),
				 18 => std_logic_vector(to_unsigned( 183 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 333

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 97 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 228 , 8)),
				 3 => std_logic_vector(to_unsigned( 40 , 8)),
				 4 => std_logic_vector(to_unsigned( 221 , 8)),
				 5 => std_logic_vector(to_unsigned( 59 , 8)),
				 6 => std_logic_vector(to_unsigned( 234 , 8)),
				 7 => std_logic_vector(to_unsigned( 27 , 8)),
				 8 => std_logic_vector(to_unsigned( 50 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 172 , 8)),
				 14 => std_logic_vector(to_unsigned( 96 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 131 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 164 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 334

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 103 , 8)),
				 4 => std_logic_vector(to_unsigned( 118 , 8)),
				 5 => std_logic_vector(to_unsigned( 105 , 8)),
				 6 => std_logic_vector(to_unsigned( 116 , 8)),
				 7 => std_logic_vector(to_unsigned( 118 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 220 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 88 , 8)),
				 12 => std_logic_vector(to_unsigned( 57 , 8)),
				 13 => std_logic_vector(to_unsigned( 46 , 8)),
				 14 => std_logic_vector(to_unsigned( 190 , 8)),
				 15 => std_logic_vector(to_unsigned( 60 , 8)),
				 16 => std_logic_vector(to_unsigned( 240 , 8)),
				 17 => std_logic_vector(to_unsigned( 97 , 8)),
				 18 => std_logic_vector(to_unsigned( 193 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 335

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 36 , 8)),
				 3 => std_logic_vector(to_unsigned( 176 , 8)),
				 4 => std_logic_vector(to_unsigned( 68 , 8)),
				 5 => std_logic_vector(to_unsigned( 178 , 8)),
				 6 => std_logic_vector(to_unsigned( 66 , 8)),
				 7 => std_logic_vector(to_unsigned( 216 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 44 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 48 , 8)),
				 12 => std_logic_vector(to_unsigned( 14 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 121 , 8)),
				 15 => std_logic_vector(to_unsigned( 31 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 178 , 8)),
				 18 => std_logic_vector(to_unsigned( 92 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 336

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 179 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 228 , 8)),
				 3 => std_logic_vector(to_unsigned( 157 , 8)),
				 4 => std_logic_vector(to_unsigned( 99 , 8)),
				 5 => std_logic_vector(to_unsigned( 32 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 15 , 8)),
				 8 => std_logic_vector(to_unsigned( 185 , 8)),
				 9 => std_logic_vector(to_unsigned( 169 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 114 , 8)),
				 18 => std_logic_vector(to_unsigned( 52 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 337

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 77 , 8)),
				 1 => std_logic_vector(to_unsigned( 231 , 8)),
				 2 => std_logic_vector(to_unsigned( 248 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 231 , 8)),
				 5 => std_logic_vector(to_unsigned( 12 , 8)),
				 6 => std_logic_vector(to_unsigned( 138 , 8)),
				 7 => std_logic_vector(to_unsigned( 98 , 8)),
				 8 => std_logic_vector(to_unsigned( 23 , 8)),
				 9 => std_logic_vector(to_unsigned( 119 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 33 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 43 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 247 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 338

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 205 , 8)),
				 1 => std_logic_vector(to_unsigned( 163 , 8)),
				 2 => std_logic_vector(to_unsigned( 77 , 8)),
				 3 => std_logic_vector(to_unsigned( 111 , 8)),
				 4 => std_logic_vector(to_unsigned( 8 , 8)),
				 5 => std_logic_vector(to_unsigned( 31 , 8)),
				 6 => std_logic_vector(to_unsigned( 58 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 114 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 112 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 112 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 110 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 252 , 8)),
				 17 => std_logic_vector(to_unsigned( 4 , 8)),
				 18 => std_logic_vector(to_unsigned( 32 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 339

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 234 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 123 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 226 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 151 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 115 , 8)),
				 13 => std_logic_vector(to_unsigned( 106 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 136 , 8)),
				 16 => std_logic_vector(to_unsigned( 25 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 340

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 29 , 8)),
				 1 => std_logic_vector(to_unsigned( 31 , 8)),
				 2 => std_logic_vector(to_unsigned( 246 , 8)),
				 3 => std_logic_vector(to_unsigned( 131 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 141 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 4 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 92 , 8)),
				 11 => std_logic_vector(to_unsigned( 181 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 152 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 187 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 84 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 341

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 189 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 131 , 8)),
				 7 => std_logic_vector(to_unsigned( 189 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 80 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 68 , 8)),
				 15 => std_logic_vector(to_unsigned( 58 , 8)),
				 16 => std_logic_vector(to_unsigned( 215 , 8)),
				 17 => std_logic_vector(to_unsigned( 145 , 8)),
				 18 => std_logic_vector(to_unsigned( 134 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 342

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 144 , 8)),
				 1 => std_logic_vector(to_unsigned( 153 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 151 , 8)),
				 4 => std_logic_vector(to_unsigned( 150 , 8)),
				 5 => std_logic_vector(to_unsigned( 177 , 8)),
				 6 => std_logic_vector(to_unsigned( 198 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 148 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 219 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 143 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 138 , 8)),
				 17 => std_logic_vector(to_unsigned( 133 , 8)),
				 18 => std_logic_vector(to_unsigned( 10 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 343

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 219 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 12 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 89 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 246 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 220 , 8)),
				 13 => std_logic_vector(to_unsigned( 79 , 8)),
				 14 => std_logic_vector(to_unsigned( 182 , 8)),
				 15 => std_logic_vector(to_unsigned( 13 , 8)),
				 16 => std_logic_vector(to_unsigned( 146 , 8)),
				 17 => std_logic_vector(to_unsigned( 244 , 8)),
				 18 => std_logic_vector(to_unsigned( 252 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 344

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 159 , 8)),
				 1 => std_logic_vector(to_unsigned( 207 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 21 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 39 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 58 , 8)),
				 12 => std_logic_vector(to_unsigned( 152 , 8)),
				 13 => std_logic_vector(to_unsigned( 142 , 8)),
				 14 => std_logic_vector(to_unsigned( 68 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 141 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 103 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 345

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 250 , 8)),
				 1 => std_logic_vector(to_unsigned( 200 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 153 , 8)),
				 4 => std_logic_vector(to_unsigned( 202 , 8)),
				 5 => std_logic_vector(to_unsigned( 36 , 8)),
				 6 => std_logic_vector(to_unsigned( 65 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 49 , 8)),
				 9 => std_logic_vector(to_unsigned( 147 , 8)),
				 10 => std_logic_vector(to_unsigned( 201 , 8)),
				 11 => std_logic_vector(to_unsigned( 215 , 8)),
				 12 => std_logic_vector(to_unsigned( 133 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 103 , 8)),
				 15 => std_logic_vector(to_unsigned( 9 , 8)),
				 16 => std_logic_vector(to_unsigned( 220 , 8)),
				 17 => std_logic_vector(to_unsigned( 182 , 8)),
				 18 => std_logic_vector(to_unsigned( 174 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 346

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 128 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 82 , 8)),
				 4 => std_logic_vector(to_unsigned( 242 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 95 , 8)),
				 7 => std_logic_vector(to_unsigned( 206 , 8)),
				 8 => std_logic_vector(to_unsigned( 89 , 8)),
				 9 => std_logic_vector(to_unsigned( 209 , 8)),
				 10 => std_logic_vector(to_unsigned( 86 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 121 , 8)),
				 13 => std_logic_vector(to_unsigned( 36 , 8)),
				 14 => std_logic_vector(to_unsigned( 192 , 8)),
				 15 => std_logic_vector(to_unsigned( 159 , 8)),
				 16 => std_logic_vector(to_unsigned( 61 , 8)),
				 17 => std_logic_vector(to_unsigned( 149 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 347

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 75 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 247 , 8)),
				 3 => std_logic_vector(to_unsigned( 149 , 8)),
				 4 => std_logic_vector(to_unsigned( 186 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 136 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 88 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 81 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 80 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 80 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 80 , 8)),
				 17 => std_logic_vector(to_unsigned( 171 , 8)),
				 18 => std_logic_vector(to_unsigned( 89 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 348

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 204 , 8)),
				 1 => std_logic_vector(to_unsigned( 183 , 8)),
				 2 => std_logic_vector(to_unsigned( 206 , 8)),
				 3 => std_logic_vector(to_unsigned( 93 , 8)),
				 4 => std_logic_vector(to_unsigned( 59 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 234 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 11 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 14 , 8)),
				 14 => std_logic_vector(to_unsigned( 67 , 8)),
				 15 => std_logic_vector(to_unsigned( 181 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 135 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 349

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 132 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 99 , 8)),
				 5 => std_logic_vector(to_unsigned( 166 , 8)),
				 6 => std_logic_vector(to_unsigned( 58 , 8)),
				 7 => std_logic_vector(to_unsigned( 192 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 58 , 8)),
				 10 => std_logic_vector(to_unsigned( 81 , 8)),
				 11 => std_logic_vector(to_unsigned( 78 , 8)),
				 12 => std_logic_vector(to_unsigned( 35 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 22 , 8)),
				 15 => std_logic_vector(to_unsigned( 102 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 212 , 8)),
				 18 => std_logic_vector(to_unsigned( 26 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 350

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 119 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 60 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 237 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 37 , 8)),
				 15 => std_logic_vector(to_unsigned( 125 , 8)),
				 16 => std_logic_vector(to_unsigned( 180 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 351

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 189 , 8)),
				 4 => std_logic_vector(to_unsigned( 75 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 29 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 85 , 8)),
				 9 => std_logic_vector(to_unsigned( 74 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 112 , 8)),
				 12 => std_logic_vector(to_unsigned( 18 , 8)),
				 13 => std_logic_vector(to_unsigned( 113 , 8)),
				 14 => std_logic_vector(to_unsigned( 17 , 8)),
				 15 => std_logic_vector(to_unsigned( 116 , 8)),
				 16 => std_logic_vector(to_unsigned( 14 , 8)),
				 17 => std_logic_vector(to_unsigned( 131 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 352

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 214 , 8)),
				 1 => std_logic_vector(to_unsigned( 102 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 77 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 222 , 8)),
				 6 => std_logic_vector(to_unsigned( 215 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 191 , 8)),
				 9 => std_logic_vector(to_unsigned( 15 , 8)),
				 10 => std_logic_vector(to_unsigned( 83 , 8)),
				 11 => std_logic_vector(to_unsigned( 28 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 62 , 8)),
				 14 => std_logic_vector(to_unsigned( 159 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 353

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 9 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 202 , 8)),
				 3 => std_logic_vector(to_unsigned( 242 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 159 , 8)),
				 7 => std_logic_vector(to_unsigned( 201 , 8)),
				 8 => std_logic_vector(to_unsigned( 214 , 8)),
				 9 => std_logic_vector(to_unsigned( 38 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 224 , 8)),
				 13 => std_logic_vector(to_unsigned( 182 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 120 , 8)),
				 16 => std_logic_vector(to_unsigned( 27 , 8)),
				 17 => std_logic_vector(to_unsigned( 97 , 8)),
				 18 => std_logic_vector(to_unsigned( 243 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 354

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 151 , 8)),
				 2 => std_logic_vector(to_unsigned( 48 , 8)),
				 3 => std_logic_vector(to_unsigned( 178 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 249 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 175 , 8)),
				 9 => std_logic_vector(to_unsigned( 201 , 8)),
				 10 => std_logic_vector(to_unsigned( 237 , 8)),
				 11 => std_logic_vector(to_unsigned( 52 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 174 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 101 , 8)),
				 16 => std_logic_vector(to_unsigned( 208 , 8)),
				 17 => std_logic_vector(to_unsigned( 218 , 8)),
				 18 => std_logic_vector(to_unsigned( 146 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 355

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 223 , 8)),
				 2 => std_logic_vector(to_unsigned( 247 , 8)),
				 3 => std_logic_vector(to_unsigned( 97 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 162 , 8)),
				 8 => std_logic_vector(to_unsigned( 190 , 8)),
				 9 => std_logic_vector(to_unsigned( 6 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 67 , 8)),
				 12 => std_logic_vector(to_unsigned( 249 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 91 , 8)),
				 15 => std_logic_vector(to_unsigned( 0 , 8)),
				 16 => std_logic_vector(to_unsigned( 85 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 94 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 356

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 10 , 8)),
				 1 => std_logic_vector(to_unsigned( 79 , 8)),
				 2 => std_logic_vector(to_unsigned( 108 , 8)),
				 3 => std_logic_vector(to_unsigned( 157 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 69 , 8)),
				 6 => std_logic_vector(to_unsigned( 182 , 8)),
				 7 => std_logic_vector(to_unsigned( 181 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 248 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 170 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 91 , 8)),
				 17 => std_logic_vector(to_unsigned( 13 , 8)),
				 18 => std_logic_vector(to_unsigned( 215 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 357

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 172 , 8)),
				 1 => std_logic_vector(to_unsigned( 75 , 8)),
				 2 => std_logic_vector(to_unsigned( 68 , 8)),
				 3 => std_logic_vector(to_unsigned( 106 , 8)),
				 4 => std_logic_vector(to_unsigned( 37 , 8)),
				 5 => std_logic_vector(to_unsigned( 121 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 185 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 152 , 8)),
				 11 => std_logic_vector(to_unsigned( 233 , 8)),
				 12 => std_logic_vector(to_unsigned( 123 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 109 , 8)),
				 15 => std_logic_vector(to_unsigned( 119 , 8)),
				 16 => std_logic_vector(to_unsigned( 93 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 358

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 238 , 8)),
				 1 => std_logic_vector(to_unsigned( 148 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 155 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 156 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 202 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 157 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 110 , 8)),
				 13 => std_logic_vector(to_unsigned( 86 , 8)),
				 14 => std_logic_vector(to_unsigned( 244 , 8)),
				 15 => std_logic_vector(to_unsigned( 130 , 8)),
				 16 => std_logic_vector(to_unsigned( 200 , 8)),
				 17 => std_logic_vector(to_unsigned( 40 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 359

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 120 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 160 , 8)),
				 4 => std_logic_vector(to_unsigned( 18 , 8)),
				 5 => std_logic_vector(to_unsigned( 177 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 237 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 114 , 8)),
				 10 => std_logic_vector(to_unsigned( 142 , 8)),
				 11 => std_logic_vector(to_unsigned( 229 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 32 , 8)),
				 14 => std_logic_vector(to_unsigned( 80 , 8)),
				 15 => std_logic_vector(to_unsigned( 55 , 8)),
				 16 => std_logic_vector(to_unsigned( 243 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 245 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 360

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 59 , 8)),
				 1 => std_logic_vector(to_unsigned( 249 , 8)),
				 2 => std_logic_vector(to_unsigned( 182 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 182 , 8)),
				 5 => std_logic_vector(to_unsigned( 11 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 18 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 24 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 97 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 66 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 50 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 361

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 136 , 8)),
				 2 => std_logic_vector(to_unsigned( 134 , 8)),
				 3 => std_logic_vector(to_unsigned( 176 , 8)),
				 4 => std_logic_vector(to_unsigned( 94 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 207 , 8)),
				 8 => std_logic_vector(to_unsigned( 227 , 8)),
				 9 => std_logic_vector(to_unsigned( 36 , 8)),
				 10 => std_logic_vector(to_unsigned( 229 , 8)),
				 11 => std_logic_vector(to_unsigned( 127 , 8)),
				 12 => std_logic_vector(to_unsigned( 138 , 8)),
				 13 => std_logic_vector(to_unsigned( 137 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 54 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 362

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 107 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 48 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 197 , 8)),
				 5 => std_logic_vector(to_unsigned( 237 , 8)),
				 6 => std_logic_vector(to_unsigned( 121 , 8)),
				 7 => std_logic_vector(to_unsigned( 131 , 8)),
				 8 => std_logic_vector(to_unsigned( 170 , 8)),
				 9 => std_logic_vector(to_unsigned( 106 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 131 , 8)),
				 12 => std_logic_vector(to_unsigned( 96 , 8)),
				 13 => std_logic_vector(to_unsigned( 178 , 8)),
				 14 => std_logic_vector(to_unsigned( 49 , 8)),
				 15 => std_logic_vector(to_unsigned( 65 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 44 , 8)),
				 18 => std_logic_vector(to_unsigned( 187 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 363

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 239 , 8)),
				 1 => std_logic_vector(to_unsigned( 92 , 8)),
				 2 => std_logic_vector(to_unsigned( 214 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 255 , 8)),
				 5 => std_logic_vector(to_unsigned( 217 , 8)),
				 6 => std_logic_vector(to_unsigned( 21 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 101 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 47 , 8)),
				 12 => std_logic_vector(to_unsigned( 188 , 8)),
				 13 => std_logic_vector(to_unsigned( 89 , 8)),
				 14 => std_logic_vector(to_unsigned( 146 , 8)),
				 15 => std_logic_vector(to_unsigned( 110 , 8)),
				 16 => std_logic_vector(to_unsigned( 125 , 8)),
				 17 => std_logic_vector(to_unsigned( 246 , 8)),
				 18 => std_logic_vector(to_unsigned( 193 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 364

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 83 , 8)),
				 2 => std_logic_vector(to_unsigned( 237 , 8)),
				 3 => std_logic_vector(to_unsigned( 126 , 8)),
				 4 => std_logic_vector(to_unsigned( 194 , 8)),
				 5 => std_logic_vector(to_unsigned( 176 , 8)),
				 6 => std_logic_vector(to_unsigned( 144 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 125 , 8)),
				 9 => std_logic_vector(to_unsigned( 150 , 8)),
				 10 => std_logic_vector(to_unsigned( 179 , 8)),
				 11 => std_logic_vector(to_unsigned( 63 , 8)),
				 12 => std_logic_vector(to_unsigned( 216 , 8)),
				 13 => std_logic_vector(to_unsigned( 64 , 8)),
				 14 => std_logic_vector(to_unsigned( 227 , 8)),
				 15 => std_logic_vector(to_unsigned( 190 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 202 , 8)),
				 18 => std_logic_vector(to_unsigned( 4 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 365

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 1 , 8)),
				 1 => std_logic_vector(to_unsigned( 222 , 8)),
				 2 => std_logic_vector(to_unsigned( 221 , 8)),
				 3 => std_logic_vector(to_unsigned( 158 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 208 , 8)),
				 11 => std_logic_vector(to_unsigned( 161 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 191 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 189 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 366

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 77 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 137 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 78 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 78 , 8)),
				 7 => std_logic_vector(to_unsigned( 164 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 194 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 32 , 8)),
				 12 => std_logic_vector(to_unsigned( 172 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 63 , 8)),
				 15 => std_logic_vector(to_unsigned( 171 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 194 , 8)),
				 18 => std_logic_vector(to_unsigned( 26 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 367

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 122 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 38 , 8)),
				 4 => std_logic_vector(to_unsigned( 221 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 228 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 35 , 8)),
				 10 => std_logic_vector(to_unsigned( 21 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 35 , 8)),
				 13 => std_logic_vector(to_unsigned( 50 , 8)),
				 14 => std_logic_vector(to_unsigned( 24 , 8)),
				 15 => std_logic_vector(to_unsigned( 67 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 42 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 368

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 213 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 37 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 207 , 8)),
				 8 => std_logic_vector(to_unsigned( 245 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 151 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 151 , 8)),
				 13 => std_logic_vector(to_unsigned( 20 , 8)),
				 14 => std_logic_vector(to_unsigned( 137 , 8)),
				 15 => std_logic_vector(to_unsigned( 11 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 245 , 8)),
				 18 => std_logic_vector(to_unsigned( 166 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 369

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 66 , 8)),
				 2 => std_logic_vector(to_unsigned( 210 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 143 , 8)),
				 8 => std_logic_vector(to_unsigned( 83 , 8)),
				 9 => std_logic_vector(to_unsigned( 148 , 8)),
				 10 => std_logic_vector(to_unsigned( 78 , 8)),
				 11 => std_logic_vector(to_unsigned( 15 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 72 , 8)),
				 14 => std_logic_vector(to_unsigned( 134 , 8)),
				 15 => std_logic_vector(to_unsigned( 209 , 8)),
				 16 => std_logic_vector(to_unsigned( 107 , 8)),
				 17 => std_logic_vector(to_unsigned( 24 , 8)),
				 18 => std_logic_vector(to_unsigned( 211 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 370

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 146 , 8)),
				 1 => std_logic_vector(to_unsigned( 242 , 8)),
				 2 => std_logic_vector(to_unsigned( 113 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 127 , 8)),
				 5 => std_logic_vector(to_unsigned( 197 , 8)),
				 6 => std_logic_vector(to_unsigned( 68 , 8)),
				 7 => std_logic_vector(to_unsigned( 232 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 48 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 29 , 8)),
				 14 => std_logic_vector(to_unsigned( 161 , 8)),
				 15 => std_logic_vector(to_unsigned( 39 , 8)),
				 16 => std_logic_vector(to_unsigned( 165 , 8)),
				 17 => std_logic_vector(to_unsigned( 165 , 8)),
				 18 => std_logic_vector(to_unsigned( 209 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 371

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 228 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 112 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 124 , 8)),
				 5 => std_logic_vector(to_unsigned( 230 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 118 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 56 , 8)),
				 13 => std_logic_vector(to_unsigned( 58 , 8)),
				 14 => std_logic_vector(to_unsigned( 203 , 8)),
				 15 => std_logic_vector(to_unsigned( 86 , 8)),
				 16 => std_logic_vector(to_unsigned( 48 , 8)),
				 17 => std_logic_vector(to_unsigned( 214 , 8)),
				 18 => std_logic_vector(to_unsigned( 136 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 372

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 215 , 8)),
				 1 => std_logic_vector(to_unsigned( 58 , 8)),
				 2 => std_logic_vector(to_unsigned( 158 , 8)),
				 3 => std_logic_vector(to_unsigned( 133 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 131 , 8)),
				 6 => std_logic_vector(to_unsigned( 127 , 8)),
				 7 => std_logic_vector(to_unsigned( 147 , 8)),
				 8 => std_logic_vector(to_unsigned( 111 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 96 , 8)),
				 12 => std_logic_vector(to_unsigned( 165 , 8)),
				 13 => std_logic_vector(to_unsigned( 122 , 8)),
				 14 => std_logic_vector(to_unsigned( 139 , 8)),
				 15 => std_logic_vector(to_unsigned( 120 , 8)),
				 16 => std_logic_vector(to_unsigned( 131 , 8)),
				 17 => std_logic_vector(to_unsigned( 18 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 373

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 58 , 8)),
				 2 => std_logic_vector(to_unsigned( 215 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 68 , 8)),
				 10 => std_logic_vector(to_unsigned( 31 , 8)),
				 11 => std_logic_vector(to_unsigned( 74 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 95 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 81 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 34 , 8)),
				 18 => std_logic_vector(to_unsigned( 117 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 374

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 104 , 8)),
				 2 => std_logic_vector(to_unsigned( 18 , 8)),
				 3 => std_logic_vector(to_unsigned( 74 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 81 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 85 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 128 , 8)),
				 10 => std_logic_vector(to_unsigned( 37 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 55 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 36 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 375

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 201 , 8)),
				 2 => std_logic_vector(to_unsigned( 216 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 153 , 8)),
				 5 => std_logic_vector(to_unsigned( 176 , 8)),
				 6 => std_logic_vector(to_unsigned( 149 , 8)),
				 7 => std_logic_vector(to_unsigned( 182 , 8)),
				 8 => std_logic_vector(to_unsigned( 143 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 73 , 8)),
				 13 => std_logic_vector(to_unsigned( 97 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 194 , 8)),
				 16 => std_logic_vector(to_unsigned( 156 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 136 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 10 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 376

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 76 , 8)),
				 1 => std_logic_vector(to_unsigned( 132 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 191 , 8)),
				 4 => std_logic_vector(to_unsigned( 25 , 8)),
				 5 => std_logic_vector(to_unsigned( 118 , 8)),
				 6 => std_logic_vector(to_unsigned( 75 , 8)),
				 7 => std_logic_vector(to_unsigned( 206 , 8)),
				 8 => std_logic_vector(to_unsigned( 184 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 133 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 132 , 8)),
				 13 => std_logic_vector(to_unsigned( 121 , 8)),
				 14 => std_logic_vector(to_unsigned( 231 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 58 , 8)),
				 17 => std_logic_vector(to_unsigned( 27 , 8)),
				 18 => std_logic_vector(to_unsigned( 197 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 377

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 18 , 8)),
				 2 => std_logic_vector(to_unsigned( 157 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 78 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 62 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 62 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 94 , 8)),
				 11 => std_logic_vector(to_unsigned( 49 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 181 , 8)),
				 14 => std_logic_vector(to_unsigned( 127 , 8)),
				 15 => std_logic_vector(to_unsigned( 199 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 244 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 378

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 44 , 8)),
				 1 => std_logic_vector(to_unsigned( 26 , 8)),
				 2 => std_logic_vector(to_unsigned( 158 , 8)),
				 3 => std_logic_vector(to_unsigned( 0 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 244 , 8)),
				 7 => std_logic_vector(to_unsigned( 68 , 8)),
				 8 => std_logic_vector(to_unsigned( 27 , 8)),
				 9 => std_logic_vector(to_unsigned( 90 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 92 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 93 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 112 , 8)),
				 17 => std_logic_vector(to_unsigned( 67 , 8)),
				 18 => std_logic_vector(to_unsigned( 35 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 379

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 147 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 97 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 81 , 8)),
				 7 => std_logic_vector(to_unsigned( 130 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 43 , 8)),
				 10 => std_logic_vector(to_unsigned( 215 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 86 , 8)),
				 16 => std_logic_vector(to_unsigned( 70 , 8)),
				 17 => std_logic_vector(to_unsigned( 23 , 8)),
				 18 => std_logic_vector(to_unsigned( 94 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 380

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 94 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 94 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 197 , 8)),
				 7 => std_logic_vector(to_unsigned( 190 , 8)),
				 8 => std_logic_vector(to_unsigned( 184 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 181 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 85 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 229 , 8)),
				 18 => std_logic_vector(to_unsigned( 174 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 381

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 52 , 8)),
				 1 => std_logic_vector(to_unsigned( 104 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 108 , 8)),
				 4 => std_logic_vector(to_unsigned( 51 , 8)),
				 5 => std_logic_vector(to_unsigned( 157 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 242 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 164 , 8)),
				 13 => std_logic_vector(to_unsigned( 167 , 8)),
				 14 => std_logic_vector(to_unsigned( 53 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 44 , 8)),
				 17 => std_logic_vector(to_unsigned( 42 , 8)),
				 18 => std_logic_vector(to_unsigned( 191 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 382

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 12 , 8)),
				 1 => std_logic_vector(to_unsigned( 214 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 182 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 180 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 177 , 8)),
				 9 => std_logic_vector(to_unsigned( 60 , 8)),
				 10 => std_logic_vector(to_unsigned( 173 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 157 , 8)),
				 13 => std_logic_vector(to_unsigned( 82 , 8)),
				 14 => std_logic_vector(to_unsigned( 151 , 8)),
				 15 => std_logic_vector(to_unsigned( 101 , 8)),
				 16 => std_logic_vector(to_unsigned( 231 , 8)),
				 17 => std_logic_vector(to_unsigned( 48 , 8)),
				 18 => std_logic_vector(to_unsigned( 134 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 383

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 58 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 114 , 8)),
				 4 => std_logic_vector(to_unsigned( 184 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 49 , 8)),
				 9 => std_logic_vector(to_unsigned( 11 , 8)),
				 10 => std_logic_vector(to_unsigned( 53 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 233 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 138 , 8)),
				 15 => std_logic_vector(to_unsigned( 217 , 8)),
				 16 => std_logic_vector(to_unsigned( 164 , 8)),
				 17 => std_logic_vector(to_unsigned( 87 , 8)),
				 18 => std_logic_vector(to_unsigned( 59 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 384

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 76 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 224 , 8)),
				 3 => std_logic_vector(to_unsigned( 230 , 8)),
				 4 => std_logic_vector(to_unsigned( 196 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 181 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 54 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 79 , 8)),
				 14 => std_logic_vector(to_unsigned( 143 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 64 , 8)),
				 17 => std_logic_vector(to_unsigned( 115 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 385

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 195 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 30 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 35 , 8)),
				 6 => std_logic_vector(to_unsigned( 240 , 8)),
				 7 => std_logic_vector(to_unsigned( 160 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 167 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 190 , 8)),
				 12 => std_logic_vector(to_unsigned( 215 , 8)),
				 13 => std_logic_vector(to_unsigned( 201 , 8)),
				 14 => std_logic_vector(to_unsigned( 204 , 8)),
				 15 => std_logic_vector(to_unsigned( 223 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 245 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 386

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 148 , 8)),
				 2 => std_logic_vector(to_unsigned( 75 , 8)),
				 3 => std_logic_vector(to_unsigned( 190 , 8)),
				 4 => std_logic_vector(to_unsigned( 33 , 8)),
				 5 => std_logic_vector(to_unsigned( 205 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 233 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 149 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 125 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 124 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 123 , 8)),
				 17 => std_logic_vector(to_unsigned( 62 , 8)),
				 18 => std_logic_vector(to_unsigned( 133 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 387

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 190 , 8)),
				 1 => std_logic_vector(to_unsigned( 242 , 8)),
				 2 => std_logic_vector(to_unsigned( 90 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 131 , 8)),
				 7 => std_logic_vector(to_unsigned( 49 , 8)),
				 8 => std_logic_vector(to_unsigned( 169 , 8)),
				 9 => std_logic_vector(to_unsigned( 15 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 26 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 202 , 8)),
				 14 => std_logic_vector(to_unsigned( 226 , 8)),
				 15 => std_logic_vector(to_unsigned( 106 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 176 , 8)),
				 18 => std_logic_vector(to_unsigned( 191 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 388

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 11 , 8)),
				 6 => std_logic_vector(to_unsigned( 51 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 167 , 8)),
				 9 => std_logic_vector(to_unsigned( 202 , 8)),
				 10 => std_logic_vector(to_unsigned( 20 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 80 , 8)),
				 14 => std_logic_vector(to_unsigned( 32 , 8)),
				 15 => std_logic_vector(to_unsigned( 108 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 95 , 8)),
				 18 => std_logic_vector(to_unsigned( 244 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 389

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 237 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 49 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 177 , 8)),
				 10 => std_logic_vector(to_unsigned( 241 , 8)),
				 11 => std_logic_vector(to_unsigned( 191 , 8)),
				 12 => std_logic_vector(to_unsigned( 227 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 148 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 95 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 390

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 142 , 8)),
				 3 => std_logic_vector(to_unsigned( 120 , 8)),
				 4 => std_logic_vector(to_unsigned( 134 , 8)),
				 5 => std_logic_vector(to_unsigned( 152 , 8)),
				 6 => std_logic_vector(to_unsigned( 102 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 27 , 8)),
				 9 => std_logic_vector(to_unsigned( 24 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 52 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 62 , 8)),
				 14 => std_logic_vector(to_unsigned( 53 , 8)),
				 15 => std_logic_vector(to_unsigned( 175 , 8)),
				 16 => std_logic_vector(to_unsigned( 145 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 391

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 16 , 8)),
				 1 => std_logic_vector(to_unsigned( 192 , 8)),
				 2 => std_logic_vector(to_unsigned( 109 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 65 , 8)),
				 5 => std_logic_vector(to_unsigned( 54 , 8)),
				 6 => std_logic_vector(to_unsigned( 73 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 19 , 8)),
				 11 => std_logic_vector(to_unsigned( 111 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 114 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 239 , 8)),
				 17 => std_logic_vector(to_unsigned( 67 , 8)),
				 18 => std_logic_vector(to_unsigned( 52 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 392

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 192 , 8)),
				 1 => std_logic_vector(to_unsigned( 57 , 8)),
				 2 => std_logic_vector(to_unsigned( 99 , 8)),
				 3 => std_logic_vector(to_unsigned( 69 , 8)),
				 4 => std_logic_vector(to_unsigned( 87 , 8)),
				 5 => std_logic_vector(to_unsigned( 100 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 120 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 39 , 8)),
				 10 => std_logic_vector(to_unsigned( 197 , 8)),
				 11 => std_logic_vector(to_unsigned( 48 , 8)),
				 12 => std_logic_vector(to_unsigned( 188 , 8)),
				 13 => std_logic_vector(to_unsigned( 26 , 8)),
				 14 => std_logic_vector(to_unsigned( 217 , 8)),
				 15 => std_logic_vector(to_unsigned( 105 , 8)),
				 16 => std_logic_vector(to_unsigned( 120 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 196 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 393

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 178 , 8)),
				 1 => std_logic_vector(to_unsigned( 129 , 8)),
				 2 => std_logic_vector(to_unsigned( 210 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 218 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 211 , 8)),
				 8 => std_logic_vector(to_unsigned( 14 , 8)),
				 9 => std_logic_vector(to_unsigned( 56 , 8)),
				 10 => std_logic_vector(to_unsigned( 71 , 8)),
				 11 => std_logic_vector(to_unsigned( 87 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 90 , 8)),
				 14 => std_logic_vector(to_unsigned( 216 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 105 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 254 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 394

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 238 , 8)),
				 1 => std_logic_vector(to_unsigned( 138 , 8)),
				 2 => std_logic_vector(to_unsigned( 25 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 94 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 191 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 199 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 108 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 121 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 164 , 8)),
				 18 => std_logic_vector(to_unsigned( 148 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 395

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 42 , 8)),
				 2 => std_logic_vector(to_unsigned( 145 , 8)),
				 3 => std_logic_vector(to_unsigned( 130 , 8)),
				 4 => std_logic_vector(to_unsigned( 57 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 218 , 8)),
				 7 => std_logic_vector(to_unsigned( 176 , 8)),
				 8 => std_logic_vector(to_unsigned( 207 , 8)),
				 9 => std_logic_vector(to_unsigned( 4 , 8)),
				 10 => std_logic_vector(to_unsigned( 246 , 8)),
				 11 => std_logic_vector(to_unsigned( 71 , 8)),
				 12 => std_logic_vector(to_unsigned( 179 , 8)),
				 13 => std_logic_vector(to_unsigned( 159 , 8)),
				 14 => std_logic_vector(to_unsigned( 92 , 8)),
				 15 => std_logic_vector(to_unsigned( 144 , 8)),
				 16 => std_logic_vector(to_unsigned( 30 , 8)),
				 17 => std_logic_vector(to_unsigned( 24 , 8)),
				 18 => std_logic_vector(to_unsigned( 121 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 396

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 216 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 29 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 167 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 105 , 8)),
				 9 => std_logic_vector(to_unsigned( 150 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 16 , 8)),
				 12 => std_logic_vector(to_unsigned( 185 , 8)),
				 13 => std_logic_vector(to_unsigned( 190 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 5 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 397

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 31 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 36 , 8)),
				 4 => std_logic_vector(to_unsigned( 68 , 8)),
				 5 => std_logic_vector(to_unsigned( 37 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 162 , 8)),
				 8 => std_logic_vector(to_unsigned( 93 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 62 , 8)),
				 11 => std_logic_vector(to_unsigned( 120 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 179 , 8)),
				 14 => std_logic_vector(to_unsigned( 58 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 117 , 8)),
				 18 => std_logic_vector(to_unsigned( 232 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 398

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 239 , 8)),
				 1 => std_logic_vector(to_unsigned( 235 , 8)),
				 2 => std_logic_vector(to_unsigned( 220 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 208 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 252 , 8)),
				 7 => std_logic_vector(to_unsigned( 35 , 8)),
				 8 => std_logic_vector(to_unsigned( 76 , 8)),
				 9 => std_logic_vector(to_unsigned( 74 , 8)),
				 10 => std_logic_vector(to_unsigned( 37 , 8)),
				 11 => std_logic_vector(to_unsigned( 86 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 61 , 8)),
				 14 => std_logic_vector(to_unsigned( 17 , 8)),
				 15 => std_logic_vector(to_unsigned( 66 , 8)),
				 16 => std_logic_vector(to_unsigned( 12 , 8)),
				 17 => std_logic_vector(to_unsigned( 224 , 8)),
				 18 => std_logic_vector(to_unsigned( 35 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 399

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 216 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 226 , 8)),
				 6 => std_logic_vector(to_unsigned( 163 , 8)),
				 7 => std_logic_vector(to_unsigned( 59 , 8)),
				 8 => std_logic_vector(to_unsigned( 247 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 18 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 100 , 8)),
				 14 => std_logic_vector(to_unsigned( 19 , 8)),
				 15 => std_logic_vector(to_unsigned( 109 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 120 , 8)),
				 18 => std_logic_vector(to_unsigned( 73 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 400

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 21 , 8)),
				 1 => std_logic_vector(to_unsigned( 56 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 81 , 8)),
				 4 => std_logic_vector(to_unsigned( 80 , 8)),
				 5 => std_logic_vector(to_unsigned( 138 , 8)),
				 6 => std_logic_vector(to_unsigned( 62 , 8)),
				 7 => std_logic_vector(to_unsigned( 179 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 240 , 8)),
				 11 => std_logic_vector(to_unsigned( 180 , 8)),
				 12 => std_logic_vector(to_unsigned( 235 , 8)),
				 13 => std_logic_vector(to_unsigned( 147 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 95 , 8)),
				 17 => std_logic_vector(to_unsigned( 14 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 401

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 120 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 89 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 146 , 8)),
				 6 => std_logic_vector(to_unsigned( 230 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 177 , 8)),
				 9 => std_logic_vector(to_unsigned( 108 , 8)),
				 10 => std_logic_vector(to_unsigned( 253 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 182 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 170 , 8)),
				 18 => std_logic_vector(to_unsigned( 211 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 402

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 47 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 108 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 107 , 8)),
				 10 => std_logic_vector(to_unsigned( 224 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 125 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 117 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 206 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 403

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 60 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 148 , 8)),
				 5 => std_logic_vector(to_unsigned( 93 , 8)),
				 6 => std_logic_vector(to_unsigned( 131 , 8)),
				 7 => std_logic_vector(to_unsigned( 168 , 8)),
				 8 => std_logic_vector(to_unsigned( 137 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 50 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 50 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 83 , 8)),
				 15 => std_logic_vector(to_unsigned( 232 , 8)),
				 16 => std_logic_vector(to_unsigned( 250 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 166 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 404

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 178 , 8)),
				 1 => std_logic_vector(to_unsigned( 47 , 8)),
				 2 => std_logic_vector(to_unsigned( 240 , 8)),
				 3 => std_logic_vector(to_unsigned( 160 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 171 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 180 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 209 , 8)),
				 11 => std_logic_vector(to_unsigned( 167 , 8)),
				 12 => std_logic_vector(to_unsigned( 132 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 75 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 63 , 8)),
				 17 => std_logic_vector(to_unsigned( 250 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 405

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 189 , 8)),
				 5 => std_logic_vector(to_unsigned( 237 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 17 , 8)),
				 8 => std_logic_vector(to_unsigned( 127 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 209 , 8)),
				 11 => std_logic_vector(to_unsigned( 177 , 8)),
				 12 => std_logic_vector(to_unsigned( 159 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 138 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 111 , 8)),
				 17 => std_logic_vector(to_unsigned( 99 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 80 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 406

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 62 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 66 , 8)),
				 5 => std_logic_vector(to_unsigned( 87 , 8)),
				 6 => std_logic_vector(to_unsigned( 119 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 214 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 165 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 165 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 161 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 160 , 8)),
				 17 => std_logic_vector(to_unsigned( 2 , 8)),
				 18 => std_logic_vector(to_unsigned( 85 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 407

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 57 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 138 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 143 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 146 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 146 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 59 , 8)),
				 14 => std_logic_vector(to_unsigned( 139 , 8)),
				 15 => std_logic_vector(to_unsigned( 83 , 8)),
				 16 => std_logic_vector(to_unsigned( 195 , 8)),
				 17 => std_logic_vector(to_unsigned( 19 , 8)),
				 18 => std_logic_vector(to_unsigned( 126 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 408

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 24 , 8)),
				 3 => std_logic_vector(to_unsigned( 44 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 97 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 101 , 8)),
				 8 => std_logic_vector(to_unsigned( 14 , 8)),
				 9 => std_logic_vector(to_unsigned( 109 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 54 , 8)),
				 12 => std_logic_vector(to_unsigned( 230 , 8)),
				 13 => std_logic_vector(to_unsigned( 106 , 8)),
				 14 => std_logic_vector(to_unsigned( 163 , 8)),
				 15 => std_logic_vector(to_unsigned( 193 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 2 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 409

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 99 , 8)),
				 1 => std_logic_vector(to_unsigned( 179 , 8)),
				 2 => std_logic_vector(to_unsigned( 148 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 78 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 203 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 209 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 35 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 104 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 410

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 241 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 169 , 8)),
				 5 => std_logic_vector(to_unsigned( 131 , 8)),
				 6 => std_logic_vector(to_unsigned( 95 , 8)),
				 7 => std_logic_vector(to_unsigned( 150 , 8)),
				 8 => std_logic_vector(to_unsigned( 76 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 28 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 150 , 8)),
				 14 => std_logic_vector(to_unsigned( 178 , 8)),
				 15 => std_logic_vector(to_unsigned( 202 , 8)),
				 16 => std_logic_vector(to_unsigned( 126 , 8)),
				 17 => std_logic_vector(to_unsigned( 244 , 8)),
				 18 => std_logic_vector(to_unsigned( 251 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 411

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 113 , 8)),
				 2 => std_logic_vector(to_unsigned( 87 , 8)),
				 3 => std_logic_vector(to_unsigned( 133 , 8)),
				 4 => std_logic_vector(to_unsigned( 138 , 8)),
				 5 => std_logic_vector(to_unsigned( 58 , 8)),
				 6 => std_logic_vector(to_unsigned( 142 , 8)),
				 7 => std_logic_vector(to_unsigned( 149 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 237 , 8)),
				 12 => std_logic_vector(to_unsigned( 99 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 94 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 412

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 165 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 217 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 65 , 8)),
				 8 => std_logic_vector(to_unsigned( 218 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 55 , 8)),
				 11 => std_logic_vector(to_unsigned( 47 , 8)),
				 12 => std_logic_vector(to_unsigned( 96 , 8)),
				 13 => std_logic_vector(to_unsigned( 186 , 8)),
				 14 => std_logic_vector(to_unsigned( 144 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 81 , 8)),
				 17 => std_logic_vector(to_unsigned( 117 , 8)),
				 18 => std_logic_vector(to_unsigned( 93 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 413

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 193 , 8)),
				 3 => std_logic_vector(to_unsigned( 182 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 211 , 8)),
				 6 => std_logic_vector(to_unsigned( 97 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 64 , 8)),
				 9 => std_logic_vector(to_unsigned( 70 , 8)),
				 10 => std_logic_vector(to_unsigned( 169 , 8)),
				 11 => std_logic_vector(to_unsigned( 157 , 8)),
				 12 => std_logic_vector(to_unsigned( 67 , 8)),
				 13 => std_logic_vector(to_unsigned( 179 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 43 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 65 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 414

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 229 , 8)),
				 1 => std_logic_vector(to_unsigned( 151 , 8)),
				 2 => std_logic_vector(to_unsigned( 107 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 196 , 8)),
				 5 => std_logic_vector(to_unsigned( 177 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 135 , 8)),
				 9 => std_logic_vector(to_unsigned( 185 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 46 , 8)),
				 13 => std_logic_vector(to_unsigned( 48 , 8)),
				 14 => std_logic_vector(to_unsigned( 243 , 8)),
				 15 => std_logic_vector(to_unsigned( 182 , 8)),
				 16 => std_logic_vector(to_unsigned( 109 , 8)),
				 17 => std_logic_vector(to_unsigned( 198 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 415

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 130 , 8)),
				 1 => std_logic_vector(to_unsigned( 61 , 8)),
				 2 => std_logic_vector(to_unsigned( 35 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 250 , 8)),
				 5 => std_logic_vector(to_unsigned( 144 , 8)),
				 6 => std_logic_vector(to_unsigned( 163 , 8)),
				 7 => std_logic_vector(to_unsigned( 24 , 8)),
				 8 => std_logic_vector(to_unsigned( 245 , 8)),
				 9 => std_logic_vector(to_unsigned( 216 , 8)),
				 10 => std_logic_vector(to_unsigned( 53 , 8)),
				 11 => std_logic_vector(to_unsigned( 66 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 177 , 8)),
				 14 => std_logic_vector(to_unsigned( 196 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 146 , 8)),
				 17 => std_logic_vector(to_unsigned( 1 , 8)),
				 18 => std_logic_vector(to_unsigned( 216 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 416

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 96 , 8)),
				 1 => std_logic_vector(to_unsigned( 192 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 175 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 232 , 8)),
				 7 => std_logic_vector(to_unsigned( 238 , 8)),
				 8 => std_logic_vector(to_unsigned( 201 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 200 , 8)),
				 11 => std_logic_vector(to_unsigned( 17 , 8)),
				 12 => std_logic_vector(to_unsigned( 86 , 8)),
				 13 => std_logic_vector(to_unsigned( 46 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 24 , 8)),
				 16 => std_logic_vector(to_unsigned( 89 , 8)),
				 17 => std_logic_vector(to_unsigned( 183 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 417

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 247 , 8)),
				 1 => std_logic_vector(to_unsigned( 253 , 8)),
				 2 => std_logic_vector(to_unsigned( 179 , 8)),
				 3 => std_logic_vector(to_unsigned( 12 , 8)),
				 4 => std_logic_vector(to_unsigned( 74 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 112 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 218 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 17 , 8)),
				 16 => std_logic_vector(to_unsigned( 45 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 112 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 418

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 63 , 8)),
				 2 => std_logic_vector(to_unsigned( 52 , 8)),
				 3 => std_logic_vector(to_unsigned( 94 , 8)),
				 4 => std_logic_vector(to_unsigned( 184 , 8)),
				 5 => std_logic_vector(to_unsigned( 119 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 204 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 104 , 8)),
				 10 => std_logic_vector(to_unsigned( 253 , 8)),
				 11 => std_logic_vector(to_unsigned( 147 , 8)),
				 12 => std_logic_vector(to_unsigned( 210 , 8)),
				 13 => std_logic_vector(to_unsigned( 184 , 8)),
				 14 => std_logic_vector(to_unsigned( 173 , 8)),
				 15 => std_logic_vector(to_unsigned( 162 , 8)),
				 16 => std_logic_vector(to_unsigned( 225 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 246 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 419

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 250 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 30 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 68 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 179 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 73 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 42 , 8)),
				 13 => std_logic_vector(to_unsigned( 126 , 8)),
				 14 => std_logic_vector(to_unsigned( 101 , 8)),
				 15 => std_logic_vector(to_unsigned( 145 , 8)),
				 16 => std_logic_vector(to_unsigned( 82 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 45 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 420

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 95 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 62 , 8)),
				 6 => std_logic_vector(to_unsigned( 209 , 8)),
				 7 => std_logic_vector(to_unsigned( 169 , 8)),
				 8 => std_logic_vector(to_unsigned( 102 , 8)),
				 9 => std_logic_vector(to_unsigned( 222 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 154 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 247 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 48 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 421

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 58 , 8)),
				 1 => std_logic_vector(to_unsigned( 165 , 8)),
				 2 => std_logic_vector(to_unsigned( 123 , 8)),
				 3 => std_logic_vector(to_unsigned( 176 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 152 , 8)),
				 8 => std_logic_vector(to_unsigned( 31 , 8)),
				 9 => std_logic_vector(to_unsigned( 176 , 8)),
				 10 => std_logic_vector(to_unsigned( 82 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 32 , 8)),
				 13 => std_logic_vector(to_unsigned( 118 , 8)),
				 14 => std_logic_vector(to_unsigned( 90 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 151 , 8)),
				 18 => std_logic_vector(to_unsigned( 200 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 422

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 186 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 41 , 8)),
				 7 => std_logic_vector(to_unsigned( 174 , 8)),
				 8 => std_logic_vector(to_unsigned( 34 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 209 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 85 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 83 , 8)),
				 17 => std_logic_vector(to_unsigned( 21 , 8)),
				 18 => std_logic_vector(to_unsigned( 48 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 423

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 39 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 107 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 99 , 8)),
				 7 => std_logic_vector(to_unsigned( 31 , 8)),
				 8 => std_logic_vector(to_unsigned( 77 , 8)),
				 9 => std_logic_vector(to_unsigned( 81 , 8)),
				 10 => std_logic_vector(to_unsigned( 27 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 26 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 144 , 8)),
				 16 => std_logic_vector(to_unsigned( 158 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 9 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 424

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 63 , 8)),
				 1 => std_logic_vector(to_unsigned( 213 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 219 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 34 , 8)),
				 12 => std_logic_vector(to_unsigned( 158 , 8)),
				 13 => std_logic_vector(to_unsigned( 114 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 82 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 150 , 8)),
				 18 => std_logic_vector(to_unsigned( 237 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 425

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 107 , 8)),
				 1 => std_logic_vector(to_unsigned( 70 , 8)),
				 2 => std_logic_vector(to_unsigned( 236 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 126 , 8)),
				 5 => std_logic_vector(to_unsigned( 103 , 8)),
				 6 => std_logic_vector(to_unsigned( 66 , 8)),
				 7 => std_logic_vector(to_unsigned( 163 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 165 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 86 , 8)),
				 12 => std_logic_vector(to_unsigned( 154 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 42 , 8)),
				 15 => std_logic_vector(to_unsigned( 211 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 8 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 426

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 18 , 8)),
				 1 => std_logic_vector(to_unsigned( 243 , 8)),
				 2 => std_logic_vector(to_unsigned( 201 , 8)),
				 3 => std_logic_vector(to_unsigned( 6 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 86 , 8)),
				 9 => std_logic_vector(to_unsigned( 81 , 8)),
				 10 => std_logic_vector(to_unsigned( 195 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 220 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 168 , 8)),
				 17 => std_logic_vector(to_unsigned( 96 , 8)),
				 18 => std_logic_vector(to_unsigned( 187 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 427

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 194 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 228 , 8)),
				 5 => std_logic_vector(to_unsigned( 130 , 8)),
				 6 => std_logic_vector(to_unsigned( 70 , 8)),
				 7 => std_logic_vector(to_unsigned( 181 , 8)),
				 8 => std_logic_vector(to_unsigned( 183 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 6 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 8 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 10 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 229 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 428

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 242 , 8)),
				 3 => std_logic_vector(to_unsigned( 99 , 8)),
				 4 => std_logic_vector(to_unsigned( 233 , 8)),
				 5 => std_logic_vector(to_unsigned( 30 , 8)),
				 6 => std_logic_vector(to_unsigned( 195 , 8)),
				 7 => std_logic_vector(to_unsigned( 70 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 100 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 105 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 106 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 59 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 429

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 140 , 8)),
				 1 => std_logic_vector(to_unsigned( 4 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 129 , 8)),
				 4 => std_logic_vector(to_unsigned( 163 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 58 , 8)),
				 7 => std_logic_vector(to_unsigned( 25 , 8)),
				 8 => std_logic_vector(to_unsigned( 243 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 60 , 8)),
				 11 => std_logic_vector(to_unsigned( 71 , 8)),
				 12 => std_logic_vector(to_unsigned( 42 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 113 , 8)),
				 15 => std_logic_vector(to_unsigned( 175 , 8)),
				 16 => std_logic_vector(to_unsigned( 156 , 8)),
				 17 => std_logic_vector(to_unsigned( 235 , 8)),
				 18 => std_logic_vector(to_unsigned( 76 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 430

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 69 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 147 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 112 , 8)),
				 6 => std_logic_vector(to_unsigned( 67 , 8)),
				 7 => std_logic_vector(to_unsigned( 138 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 178 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 14 , 8)),
				 12 => std_logic_vector(to_unsigned( 106 , 8)),
				 13 => std_logic_vector(to_unsigned( 1 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 4 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 62 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 431

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 5 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 66 , 8)),
				 3 => std_logic_vector(to_unsigned( 198 , 8)),
				 4 => std_logic_vector(to_unsigned( 220 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 195 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 106 , 8)),
				 9 => std_logic_vector(to_unsigned( 25 , 8)),
				 10 => std_logic_vector(to_unsigned( 149 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 198 , 8)),
				 13 => std_logic_vector(to_unsigned( 105 , 8)),
				 14 => std_logic_vector(to_unsigned( 223 , 8)),
				 15 => std_logic_vector(to_unsigned( 14 , 8)),
				 16 => std_logic_vector(to_unsigned( 233 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 432

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 138 , 8)),
				 3 => std_logic_vector(to_unsigned( 85 , 8)),
				 4 => std_logic_vector(to_unsigned( 67 , 8)),
				 5 => std_logic_vector(to_unsigned( 97 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 208 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 85 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 118 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 124 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 166 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 5 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 433

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 121 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 143 , 8)),
				 6 => std_logic_vector(to_unsigned( 68 , 8)),
				 7 => std_logic_vector(to_unsigned( 206 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 203 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 94 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 83 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 208 , 8)),
				 17 => std_logic_vector(to_unsigned( 112 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 434

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 49 , 8)),
				 2 => std_logic_vector(to_unsigned( 140 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 12 , 8)),
				 5 => std_logic_vector(to_unsigned( 145 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 135 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 166 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 167 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 99 , 8)),
				 16 => std_logic_vector(to_unsigned( 245 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 435

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 2 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 125 , 8)),
				 3 => std_logic_vector(to_unsigned( 77 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 80 , 8)),
				 6 => std_logic_vector(to_unsigned( 28 , 8)),
				 7 => std_logic_vector(to_unsigned( 131 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 188 , 8)),
				 10 => std_logic_vector(to_unsigned( 153 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 29 , 8)),
				 14 => std_logic_vector(to_unsigned( 225 , 8)),
				 15 => std_logic_vector(to_unsigned( 127 , 8)),
				 16 => std_logic_vector(to_unsigned( 127 , 8)),
				 17 => std_logic_vector(to_unsigned( 178 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 436

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 199 , 8)),
				 1 => std_logic_vector(to_unsigned( 167 , 8)),
				 2 => std_logic_vector(to_unsigned( 210 , 8)),
				 3 => std_logic_vector(to_unsigned( 200 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 238 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 180 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 2 , 8)),
				 10 => std_logic_vector(to_unsigned( 186 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 68 , 8)),
				 14 => std_logic_vector(to_unsigned( 139 , 8)),
				 15 => std_logic_vector(to_unsigned( 181 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 214 , 8)),
				 18 => std_logic_vector(to_unsigned( 253 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 437

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 155 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 136 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 152 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 175 , 8)),
				 12 => std_logic_vector(to_unsigned( 50 , 8)),
				 13 => std_logic_vector(to_unsigned( 215 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 165 , 8)),
				 17 => std_logic_vector(to_unsigned( 157 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 438

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 219 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 11 , 8)),
				 5 => std_logic_vector(to_unsigned( 81 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 81 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 17 , 8)),
				 12 => std_logic_vector(to_unsigned( 242 , 8)),
				 13 => std_logic_vector(to_unsigned( 107 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 217 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 97 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 439

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 220 , 8)),
				 1 => std_logic_vector(to_unsigned( 121 , 8)),
				 2 => std_logic_vector(to_unsigned( 43 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 247 , 8)),
				 5 => std_logic_vector(to_unsigned( 86 , 8)),
				 6 => std_logic_vector(to_unsigned( 21 , 8)),
				 7 => std_logic_vector(to_unsigned( 177 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 82 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 77 , 8)),
				 12 => std_logic_vector(to_unsigned( 229 , 8)),
				 13 => std_logic_vector(to_unsigned( 105 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 7 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 219 , 8)),
				 18 => std_logic_vector(to_unsigned( 216 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 440

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 76 , 8)),
				 2 => std_logic_vector(to_unsigned( 126 , 8)),
				 3 => std_logic_vector(to_unsigned( 138 , 8)),
				 4 => std_logic_vector(to_unsigned( 200 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 97 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 251 , 8)),
				 11 => std_logic_vector(to_unsigned( 126 , 8)),
				 12 => std_logic_vector(to_unsigned( 168 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 234 , 8)),
				 17 => std_logic_vector(to_unsigned( 62 , 8)),
				 18 => std_logic_vector(to_unsigned( 241 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 441

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 61 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 221 , 8)),
				 4 => std_logic_vector(to_unsigned( 111 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 97 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 108 , 8)),
				 10 => std_logic_vector(to_unsigned( 108 , 8)),
				 11 => std_logic_vector(to_unsigned( 161 , 8)),
				 12 => std_logic_vector(to_unsigned( 55 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 197 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 442

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 75 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 213 , 8)),
				 3 => std_logic_vector(to_unsigned( 73 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 32 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 111 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 200 , 8)),
				 10 => std_logic_vector(to_unsigned( 115 , 8)),
				 11 => std_logic_vector(to_unsigned( 229 , 8)),
				 12 => std_logic_vector(to_unsigned( 86 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 67 , 8)),
				 15 => std_logic_vector(to_unsigned( 59 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 20 , 8)),
				 18 => std_logic_vector(to_unsigned( 172 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 443

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 113 , 8)),
				 1 => std_logic_vector(to_unsigned( 181 , 8)),
				 2 => std_logic_vector(to_unsigned( 154 , 8)),
				 3 => std_logic_vector(to_unsigned( 213 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 138 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 151 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 73 , 8)),
				 12 => std_logic_vector(to_unsigned( 212 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 32 , 8)),
				 15 => std_logic_vector(to_unsigned( 14 , 8)),
				 16 => std_logic_vector(to_unsigned( 84 , 8)),
				 17 => std_logic_vector(to_unsigned( 87 , 8)),
				 18 => std_logic_vector(to_unsigned( 49 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 444

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 157 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 95 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 128 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 114 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 113 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 106 , 8)),
				 13 => std_logic_vector(to_unsigned( 16 , 8)),
				 14 => std_logic_vector(to_unsigned( 102 , 8)),
				 15 => std_logic_vector(to_unsigned( 86 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 164 , 8)),
				 18 => std_logic_vector(to_unsigned( 216 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 445

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 115 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 1 , 8)),
				 5 => std_logic_vector(to_unsigned( 237 , 8)),
				 6 => std_logic_vector(to_unsigned( 240 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 183 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 68 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 58 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 94 , 8)),
				 16 => std_logic_vector(to_unsigned( 72 , 8)),
				 17 => std_logic_vector(to_unsigned( 72 , 8)),
				 18 => std_logic_vector(to_unsigned( 16 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 446

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 229 , 8)),
				 1 => std_logic_vector(to_unsigned( 233 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 84 , 8)),
				 4 => std_logic_vector(to_unsigned( 119 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 160 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 166 , 8)),
				 10 => std_logic_vector(to_unsigned( 37 , 8)),
				 11 => std_logic_vector(to_unsigned( 191 , 8)),
				 12 => std_logic_vector(to_unsigned( 63 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 196 , 8)),
				 15 => std_logic_vector(to_unsigned( 199 , 8)),
				 16 => std_logic_vector(to_unsigned( 88 , 8)),
				 17 => std_logic_vector(to_unsigned( 94 , 8)),
				 18 => std_logic_vector(to_unsigned( 160 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 447

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 88 , 8)),
				 1 => std_logic_vector(to_unsigned( 211 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 180 , 8)),
				 6 => std_logic_vector(to_unsigned( 250 , 8)),
				 7 => std_logic_vector(to_unsigned( 182 , 8)),
				 8 => std_logic_vector(to_unsigned( 248 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 232 , 8)),
				 11 => std_logic_vector(to_unsigned( 166 , 8)),
				 12 => std_logic_vector(to_unsigned( 14 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 71 , 8)),
				 15 => std_logic_vector(to_unsigned( 174 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 448

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 130 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 171 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 196 , 8)),
				 6 => std_logic_vector(to_unsigned( 28 , 8)),
				 7 => std_logic_vector(to_unsigned( 204 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 223 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 237 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 56 , 8)),
				 14 => std_logic_vector(to_unsigned( 75 , 8)),
				 15 => std_logic_vector(to_unsigned( 85 , 8)),
				 16 => std_logic_vector(to_unsigned( 46 , 8)),
				 17 => std_logic_vector(to_unsigned( 40 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 449

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 69 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 170 , 8)),
				 3 => std_logic_vector(to_unsigned( 104 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 87 , 8)),
				 6 => std_logic_vector(to_unsigned( 90 , 8)),
				 7 => std_logic_vector(to_unsigned( 85 , 8)),
				 8 => std_logic_vector(to_unsigned( 125 , 8)),
				 9 => std_logic_vector(to_unsigned( 40 , 8)),
				 10 => std_logic_vector(to_unsigned( 89 , 8)),
				 11 => std_logic_vector(to_unsigned( 47 , 8)),
				 12 => std_logic_vector(to_unsigned( 82 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 210 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 228 , 8)),
				 18 => std_logic_vector(to_unsigned( 113 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 450

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 155 , 8)),
				 1 => std_logic_vector(to_unsigned( 59 , 8)),
				 2 => std_logic_vector(to_unsigned( 161 , 8)),
				 3 => std_logic_vector(to_unsigned( 232 , 8)),
				 4 => std_logic_vector(to_unsigned( 232 , 8)),
				 5 => std_logic_vector(to_unsigned( 146 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 26 , 8)),
				 8 => std_logic_vector(to_unsigned( 138 , 8)),
				 9 => std_logic_vector(to_unsigned( 86 , 8)),
				 10 => std_logic_vector(to_unsigned( 78 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 199 , 8)),
				 13 => std_logic_vector(to_unsigned( 201 , 8)),
				 14 => std_logic_vector(to_unsigned( 171 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 127 , 8)),
				 17 => std_logic_vector(to_unsigned( 39 , 8)),
				 18 => std_logic_vector(to_unsigned( 57 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 451

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 12 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 66 , 8)),
				 5 => std_logic_vector(to_unsigned( 158 , 8)),
				 6 => std_logic_vector(to_unsigned( 32 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 238 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 236 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 236 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 236 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 72 , 8)),
				 18 => std_logic_vector(to_unsigned( 8 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 452

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 52 , 8)),
				 1 => std_logic_vector(to_unsigned( 43 , 8)),
				 2 => std_logic_vector(to_unsigned( 89 , 8)),
				 3 => std_logic_vector(to_unsigned( 46 , 8)),
				 4 => std_logic_vector(to_unsigned( 0 , 8)),
				 5 => std_logic_vector(to_unsigned( 26 , 8)),
				 6 => std_logic_vector(to_unsigned( 231 , 8)),
				 7 => std_logic_vector(to_unsigned( 39 , 8)),
				 8 => std_logic_vector(to_unsigned( 197 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 98 , 8)),
				 11 => std_logic_vector(to_unsigned( 69 , 8)),
				 12 => std_logic_vector(to_unsigned( 183 , 8)),
				 13 => std_logic_vector(to_unsigned( 227 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 82 , 8)),
				 16 => std_logic_vector(to_unsigned( 82 , 8)),
				 17 => std_logic_vector(to_unsigned( 85 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 453

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 47 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 88 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 179 , 8)),
				 7 => std_logic_vector(to_unsigned( 176 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 85 , 8)),
				 12 => std_logic_vector(to_unsigned( 97 , 8)),
				 13 => std_logic_vector(to_unsigned( 152 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 42 , 8)),
				 18 => std_logic_vector(to_unsigned( 96 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 454

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 127 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 203 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 224 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 229 , 8)),
				 10 => std_logic_vector(to_unsigned( 135 , 8)),
				 11 => std_logic_vector(to_unsigned( 240 , 8)),
				 12 => std_logic_vector(to_unsigned( 124 , 8)),
				 13 => std_logic_vector(to_unsigned( 34 , 8)),
				 14 => std_logic_vector(to_unsigned( 150 , 8)),
				 15 => std_logic_vector(to_unsigned( 132 , 8)),
				 16 => std_logic_vector(to_unsigned( 142 , 8)),
				 17 => std_logic_vector(to_unsigned( 26 , 8)),
				 18 => std_logic_vector(to_unsigned( 255 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 455

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 174 , 8)),
				 2 => std_logic_vector(to_unsigned( 192 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 248 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 193 , 8)),
				 9 => std_logic_vector(to_unsigned( 11 , 8)),
				 10 => std_logic_vector(to_unsigned( 142 , 8)),
				 11 => std_logic_vector(to_unsigned( 152 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 152 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 152 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 456

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 58 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 49 , 8)),
				 4 => std_logic_vector(to_unsigned( 28 , 8)),
				 5 => std_logic_vector(to_unsigned( 147 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 149 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 151 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 189 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 27 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 107 , 8)),
				 17 => std_logic_vector(to_unsigned( 27 , 8)),
				 18 => std_logic_vector(to_unsigned( 0 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 457

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 160 , 8)),
				 1 => std_logic_vector(to_unsigned( 229 , 8)),
				 2 => std_logic_vector(to_unsigned( 72 , 8)),
				 3 => std_logic_vector(to_unsigned( 56 , 8)),
				 4 => std_logic_vector(to_unsigned( 235 , 8)),
				 5 => std_logic_vector(to_unsigned( 220 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 69 , 8)),
				 9 => std_logic_vector(to_unsigned( 181 , 8)),
				 10 => std_logic_vector(to_unsigned( 133 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 84 , 8)),
				 13 => std_logic_vector(to_unsigned( 82 , 8)),
				 14 => std_logic_vector(to_unsigned( 93 , 8)),
				 15 => std_logic_vector(to_unsigned( 88 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 107 , 8)),
				 18 => std_logic_vector(to_unsigned( 215 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 458

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 121 , 8)),
				 1 => std_logic_vector(to_unsigned( 144 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 195 , 8)),
				 4 => std_logic_vector(to_unsigned( 127 , 8)),
				 5 => std_logic_vector(to_unsigned( 224 , 8)),
				 6 => std_logic_vector(to_unsigned( 98 , 8)),
				 7 => std_logic_vector(to_unsigned( 221 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 222 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 102 , 8)),
				 14 => std_logic_vector(to_unsigned( 73 , 8)),
				 15 => std_logic_vector(to_unsigned( 185 , 8)),
				 16 => std_logic_vector(to_unsigned( 59 , 8)),
				 17 => std_logic_vector(to_unsigned( 165 , 8)),
				 18 => std_logic_vector(to_unsigned( 254 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 459

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 31 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 152 , 8)),
				 3 => std_logic_vector(to_unsigned( 28 , 8)),
				 4 => std_logic_vector(to_unsigned( 132 , 8)),
				 5 => std_logic_vector(to_unsigned( 103 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 36 , 8)),
				 12 => std_logic_vector(to_unsigned( 249 , 8)),
				 13 => std_logic_vector(to_unsigned( 117 , 8)),
				 14 => std_logic_vector(to_unsigned( 168 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 71 , 8)),
				 17 => std_logic_vector(to_unsigned( 180 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 460

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 24 , 8)),
				 3 => std_logic_vector(to_unsigned( 60 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 28 , 8)),
				 6 => std_logic_vector(to_unsigned( 170 , 8)),
				 7 => std_logic_vector(to_unsigned( 165 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 59 , 8)),
				 10 => std_logic_vector(to_unsigned( 54 , 8)),
				 11 => std_logic_vector(to_unsigned( 116 , 8)),
				 12 => std_logic_vector(to_unsigned( 125 , 8)),
				 13 => std_logic_vector(to_unsigned( 104 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 212 , 8)),
				 16 => std_logic_vector(to_unsigned( 216 , 8)),
				 17 => std_logic_vector(to_unsigned( 130 , 8)),
				 18 => std_logic_vector(to_unsigned( 71 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 461

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 136 , 8)),
				 2 => std_logic_vector(to_unsigned( 89 , 8)),
				 3 => std_logic_vector(to_unsigned( 213 , 8)),
				 4 => std_logic_vector(to_unsigned( 12 , 8)),
				 5 => std_logic_vector(to_unsigned( 217 , 8)),
				 6 => std_logic_vector(to_unsigned( 8 , 8)),
				 7 => std_logic_vector(to_unsigned( 222 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 226 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 90 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 229 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 462

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 1 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 1 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 2 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 3 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 144 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 205 , 8)),
				 12 => std_logic_vector(to_unsigned( 139 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 90 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 89 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 115 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 463

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 19 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 87 , 8)),
				 3 => std_logic_vector(to_unsigned( 238 , 8)),
				 4 => std_logic_vector(to_unsigned( 45 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 42 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 213 , 8)),
				 10 => std_logic_vector(to_unsigned( 58 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 464

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 239 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 25 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 125 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 52 , 8)),
				 8 => std_logic_vector(to_unsigned( 57 , 8)),
				 9 => std_logic_vector(to_unsigned( 87 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 38 , 8)),
				 12 => std_logic_vector(to_unsigned( 144 , 8)),
				 13 => std_logic_vector(to_unsigned( 157 , 8)),
				 14 => std_logic_vector(to_unsigned( 25 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 0 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 465

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 152 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 145 , 8)),
				 5 => std_logic_vector(to_unsigned( 178 , 8)),
				 6 => std_logic_vector(to_unsigned( 94 , 8)),
				 7 => std_logic_vector(to_unsigned( 81 , 8)),
				 8 => std_logic_vector(to_unsigned( 237 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 64 , 8)),
				 11 => std_logic_vector(to_unsigned( 117 , 8)),
				 12 => std_logic_vector(to_unsigned( 146 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 104 , 8)),
				 16 => std_logic_vector(to_unsigned( 19 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 466

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 141 , 8)),
				 1 => std_logic_vector(to_unsigned( 192 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 188 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 189 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 27 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 158 , 8)),
				 18 => std_logic_vector(to_unsigned( 160 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 467

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 61 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 182 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 69 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 224 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 65 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 230 , 8)),
				 14 => std_logic_vector(to_unsigned( 112 , 8)),
				 15 => std_logic_vector(to_unsigned( 232 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 24 , 8)),
				 18 => std_logic_vector(to_unsigned( 215 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 468

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 251 , 8)),
				 1 => std_logic_vector(to_unsigned( 251 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 165 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 77 , 8)),
				 9 => std_logic_vector(to_unsigned( 209 , 8)),
				 10 => std_logic_vector(to_unsigned( 73 , 8)),
				 11 => std_logic_vector(to_unsigned( 180 , 8)),
				 12 => std_logic_vector(to_unsigned( 36 , 8)),
				 13 => std_logic_vector(to_unsigned( 134 , 8)),
				 14 => std_logic_vector(to_unsigned( 160 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 102 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 39 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 469

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 182 , 8)),
				 1 => std_logic_vector(to_unsigned( 89 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 20 , 8)),
				 4 => std_logic_vector(to_unsigned( 223 , 8)),
				 5 => std_logic_vector(to_unsigned( 44 , 8)),
				 6 => std_logic_vector(to_unsigned( 49 , 8)),
				 7 => std_logic_vector(to_unsigned( 44 , 8)),
				 8 => std_logic_vector(to_unsigned( 49 , 8)),
				 9 => std_logic_vector(to_unsigned( 77 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 31 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 159 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 99 , 8)),
				 17 => std_logic_vector(to_unsigned( 5 , 8)),
				 18 => std_logic_vector(to_unsigned( 153 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 470

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 209 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 89 , 8)),
				 7 => std_logic_vector(to_unsigned( 116 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 158 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 28 , 8)),
				 12 => std_logic_vector(to_unsigned( 162 , 8)),
				 13 => std_logic_vector(to_unsigned( 116 , 8)),
				 14 => std_logic_vector(to_unsigned( 74 , 8)),
				 15 => std_logic_vector(to_unsigned( 147 , 8)),
				 16 => std_logic_vector(to_unsigned( 43 , 8)),
				 17 => std_logic_vector(to_unsigned( 93 , 8)),
				 18 => std_logic_vector(to_unsigned( 178 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 471

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 25 , 8)),
				 1 => std_logic_vector(to_unsigned( 104 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 51 , 8)),
				 5 => std_logic_vector(to_unsigned( 19 , 8)),
				 6 => std_logic_vector(to_unsigned( 100 , 8)),
				 7 => std_logic_vector(to_unsigned( 53 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 118 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 157 , 8)),
				 13 => std_logic_vector(to_unsigned( 92 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 92 , 8)),
				 16 => std_logic_vector(to_unsigned( 18 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 472

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 191 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 146 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 145 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 141 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 137 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 137 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 229 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 45 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 473

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 5 , 8)),
				 1 => std_logic_vector(to_unsigned( 58 , 8)),
				 2 => std_logic_vector(to_unsigned( 193 , 8)),
				 3 => std_logic_vector(to_unsigned( 160 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 183 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 89 , 8)),
				 10 => std_logic_vector(to_unsigned( 92 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 254 , 8)),
				 13 => std_logic_vector(to_unsigned( 168 , 8)),
				 14 => std_logic_vector(to_unsigned( 246 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 181 , 8)),
				 17 => std_logic_vector(to_unsigned( 174 , 8)),
				 18 => std_logic_vector(to_unsigned( 211 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 474

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 199 , 8)),
				 1 => std_logic_vector(to_unsigned( 174 , 8)),
				 2 => std_logic_vector(to_unsigned( 186 , 8)),
				 3 => std_logic_vector(to_unsigned( 217 , 8)),
				 4 => std_logic_vector(to_unsigned( 143 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 176 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 208 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 201 , 8)),
				 14 => std_logic_vector(to_unsigned( 105 , 8)),
				 15 => std_logic_vector(to_unsigned( 218 , 8)),
				 16 => std_logic_vector(to_unsigned( 88 , 8)),
				 17 => std_logic_vector(to_unsigned( 228 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 475

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 63 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 232 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 144 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 70 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 157 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 175 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 476

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 35 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 46 , 8)),
				 3 => std_logic_vector(to_unsigned( 8 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 12 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 61 , 8)),
				 13 => std_logic_vector(to_unsigned( 202 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 96 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 73 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 477

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 44 , 8)),
				 1 => std_logic_vector(to_unsigned( 248 , 8)),
				 2 => std_logic_vector(to_unsigned( 251 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 245 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 245 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 245 , 8)),
				 9 => std_logic_vector(to_unsigned( 110 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 128 , 8)),
				 13 => std_logic_vector(to_unsigned( 234 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 156 , 8)),
				 16 => std_logic_vector(to_unsigned( 84 , 8)),
				 17 => std_logic_vector(to_unsigned( 227 , 8)),
				 18 => std_logic_vector(to_unsigned( 94 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 478

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 61 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 72 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 42 , 8)),
				 5 => std_logic_vector(to_unsigned( 147 , 8)),
				 6 => std_logic_vector(to_unsigned( 122 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 207 , 8)),
				 9 => std_logic_vector(to_unsigned( 229 , 8)),
				 10 => std_logic_vector(to_unsigned( 27 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 104 , 8)),
				 14 => std_logic_vector(to_unsigned( 28 , 8)),
				 15 => std_logic_vector(to_unsigned( 224 , 8)),
				 16 => std_logic_vector(to_unsigned( 212 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 176 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 479

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 164 , 8)),
				 2 => std_logic_vector(to_unsigned( 103 , 8)),
				 3 => std_logic_vector(to_unsigned( 203 , 8)),
				 4 => std_logic_vector(to_unsigned( 64 , 8)),
				 5 => std_logic_vector(to_unsigned( 212 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 19 , 8)),
				 8 => std_logic_vector(to_unsigned( 244 , 8)),
				 9 => std_logic_vector(to_unsigned( 60 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 214 , 8)),
				 12 => std_logic_vector(to_unsigned( 218 , 8)),
				 13 => std_logic_vector(to_unsigned( 108 , 8)),
				 14 => std_logic_vector(to_unsigned( 230 , 8)),
				 15 => std_logic_vector(to_unsigned( 92 , 8)),
				 16 => std_logic_vector(to_unsigned( 232 , 8)),
				 17 => std_logic_vector(to_unsigned( 249 , 8)),
				 18 => std_logic_vector(to_unsigned( 16 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 480

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 161 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 230 , 8)),
				 5 => std_logic_vector(to_unsigned( 88 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 110 , 8)),
				 8 => std_logic_vector(to_unsigned( 62 , 8)),
				 9 => std_logic_vector(to_unsigned( 123 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 95 , 8)),
				 12 => std_logic_vector(to_unsigned( 119 , 8)),
				 13 => std_logic_vector(to_unsigned( 187 , 8)),
				 14 => std_logic_vector(to_unsigned( 27 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 104 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 481

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 124 , 8)),
				 2 => std_logic_vector(to_unsigned( 220 , 8)),
				 3 => std_logic_vector(to_unsigned( 169 , 8)),
				 4 => std_logic_vector(to_unsigned( 175 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 138 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 199 , 8)),
				 9 => std_logic_vector(to_unsigned( 35 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 39 , 8)),
				 12 => std_logic_vector(to_unsigned( 115 , 8)),
				 13 => std_logic_vector(to_unsigned( 153 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 220 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 193 , 8)),
				 18 => std_logic_vector(to_unsigned( 49 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 482

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 143 , 8)),
				 3 => std_logic_vector(to_unsigned( 4 , 8)),
				 4 => std_logic_vector(to_unsigned( 171 , 8)),
				 5 => std_logic_vector(to_unsigned( 49 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 121 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 173 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 173 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 96 , 8)),
				 18 => std_logic_vector(to_unsigned( 156 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 483

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 107 , 8)),
				 1 => std_logic_vector(to_unsigned( 54 , 8)),
				 2 => std_logic_vector(to_unsigned( 115 , 8)),
				 3 => std_logic_vector(to_unsigned( 210 , 8)),
				 4 => std_logic_vector(to_unsigned( 128 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 239 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 202 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 87 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 246 , 8)),
				 18 => std_logic_vector(to_unsigned( 40 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 484

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 40 , 8)),
				 1 => std_logic_vector(to_unsigned( 79 , 8)),
				 2 => std_logic_vector(to_unsigned( 193 , 8)),
				 3 => std_logic_vector(to_unsigned( 112 , 8)),
				 4 => std_logic_vector(to_unsigned( 160 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 63 , 8)),
				 7 => std_logic_vector(to_unsigned( 230 , 8)),
				 8 => std_logic_vector(to_unsigned( 42 , 8)),
				 9 => std_logic_vector(to_unsigned( 53 , 8)),
				 10 => std_logic_vector(to_unsigned( 70 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 52 , 8)),
				 14 => std_logic_vector(to_unsigned( 245 , 8)),
				 15 => std_logic_vector(to_unsigned( 145 , 8)),
				 16 => std_logic_vector(to_unsigned( 45 , 8)),
				 17 => std_logic_vector(to_unsigned( 245 , 8)),
				 18 => std_logic_vector(to_unsigned( 133 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 485

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 145 , 8)),
				 1 => std_logic_vector(to_unsigned( 149 , 8)),
				 2 => std_logic_vector(to_unsigned( 151 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 60 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 59 , 8)),
				 8 => std_logic_vector(to_unsigned( 230 , 8)),
				 9 => std_logic_vector(to_unsigned( 133 , 8)),
				 10 => std_logic_vector(to_unsigned( 156 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 24 , 8)),
				 16 => std_logic_vector(to_unsigned( 14 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 142 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 486

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 203 , 8)),
				 4 => std_logic_vector(to_unsigned( 238 , 8)),
				 5 => std_logic_vector(to_unsigned( 197 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 119 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 135 , 8)),
				 13 => std_logic_vector(to_unsigned( 75 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 82 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 130 , 8)),
				 18 => std_logic_vector(to_unsigned( 214 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 487

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 215 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 251 , 8)),
				 3 => std_logic_vector(to_unsigned( 58 , 8)),
				 4 => std_logic_vector(to_unsigned( 252 , 8)),
				 5 => std_logic_vector(to_unsigned( 84 , 8)),
				 6 => std_logic_vector(to_unsigned( 226 , 8)),
				 7 => std_logic_vector(to_unsigned( 137 , 8)),
				 8 => std_logic_vector(to_unsigned( 173 , 8)),
				 9 => std_logic_vector(to_unsigned( 209 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 146 , 8)),
				 16 => std_logic_vector(to_unsigned( 201 , 8)),
				 17 => std_logic_vector(to_unsigned( 89 , 8)),
				 18 => std_logic_vector(to_unsigned( 50 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 488

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 35 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 138 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 126 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 124 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 124 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 186 , 8)),
				 12 => std_logic_vector(to_unsigned( 202 , 8)),
				 13 => std_logic_vector(to_unsigned( 217 , 8)),
				 14 => std_logic_vector(to_unsigned( 171 , 8)),
				 15 => std_logic_vector(to_unsigned( 152 , 8)),
				 16 => std_logic_vector(to_unsigned( 108 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 111 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 489

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 78 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 186 , 8)),
				 5 => std_logic_vector(to_unsigned( 82 , 8)),
				 6 => std_logic_vector(to_unsigned( 174 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 63 , 8)),
				 9 => std_logic_vector(to_unsigned( 123 , 8)),
				 10 => std_logic_vector(to_unsigned( 36 , 8)),
				 11 => std_logic_vector(to_unsigned( 154 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 56 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 177 , 8)),
				 18 => std_logic_vector(to_unsigned( 2 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 490

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 224 , 8)),
				 1 => std_logic_vector(to_unsigned( 164 , 8)),
				 2 => std_logic_vector(to_unsigned( 5 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 166 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 66 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 204 , 8)),
				 15 => std_logic_vector(to_unsigned( 232 , 8)),
				 16 => std_logic_vector(to_unsigned( 204 , 8)),
				 17 => std_logic_vector(to_unsigned( 80 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 224 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 491

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 228 , 8)),
				 1 => std_logic_vector(to_unsigned( 193 , 8)),
				 2 => std_logic_vector(to_unsigned( 163 , 8)),
				 3 => std_logic_vector(to_unsigned( 223 , 8)),
				 4 => std_logic_vector(to_unsigned( 133 , 8)),
				 5 => std_logic_vector(to_unsigned( 16 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 37 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 38 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 45 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 90 , 8)),
				 18 => std_logic_vector(to_unsigned( 220 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 228 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 492

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 59 , 8)),
				 1 => std_logic_vector(to_unsigned( 166 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 99 , 8)),
				 4 => std_logic_vector(to_unsigned( 159 , 8)),
				 5 => std_logic_vector(to_unsigned( 60 , 8)),
				 6 => std_logic_vector(to_unsigned( 207 , 8)),
				 7 => std_logic_vector(to_unsigned( 160 , 8)),
				 8 => std_logic_vector(to_unsigned( 107 , 8)),
				 9 => std_logic_vector(to_unsigned( 212 , 8)),
				 10 => std_logic_vector(to_unsigned( 167 , 8)),
				 11 => std_logic_vector(to_unsigned( 232 , 8)),
				 12 => std_logic_vector(to_unsigned( 147 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 129 , 8)),
				 15 => std_logic_vector(to_unsigned( 151 , 8)),
				 16 => std_logic_vector(to_unsigned( 100 , 8)),
				 17 => std_logic_vector(to_unsigned( 51 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 493

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 247 , 8)),
				 1 => std_logic_vector(to_unsigned( 46 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 252 , 8)),
				 5 => std_logic_vector(to_unsigned( 77 , 8)),
				 6 => std_logic_vector(to_unsigned( 136 , 8)),
				 7 => std_logic_vector(to_unsigned( 23 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 23 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 88 , 8)),
				 12 => std_logic_vector(to_unsigned( 29 , 8)),
				 13 => std_logic_vector(to_unsigned( 108 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 112 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 224 , 8)),
				 18 => std_logic_vector(to_unsigned( 43 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 224 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 494

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 251 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 140 , 8)),
				 6 => std_logic_vector(to_unsigned( 60 , 8)),
				 7 => std_logic_vector(to_unsigned( 206 , 8)),
				 8 => std_logic_vector(to_unsigned( 187 , 8)),
				 9 => std_logic_vector(to_unsigned( 113 , 8)),
				 10 => std_logic_vector(to_unsigned( 139 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 227 , 8)),
				 15 => std_logic_vector(to_unsigned( 23 , 8)),
				 16 => std_logic_vector(to_unsigned( 253 , 8)),
				 17 => std_logic_vector(to_unsigned( 17 , 8)),
				 18 => std_logic_vector(to_unsigned( 208 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 495

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 208 , 8)),
				 1 => std_logic_vector(to_unsigned( 150 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 231 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 76 , 8)),
				 6 => std_logic_vector(to_unsigned( 182 , 8)),
				 7 => std_logic_vector(to_unsigned( 55 , 8)),
				 8 => std_logic_vector(to_unsigned( 229 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 124 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 125 , 8)),
				 14 => std_logic_vector(to_unsigned( 159 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 178 , 8)),
				 18 => std_logic_vector(to_unsigned( 191 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 496

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 94 , 8)),
				 1 => std_logic_vector(to_unsigned( 109 , 8)),
				 2 => std_logic_vector(to_unsigned( 201 , 8)),
				 3 => std_logic_vector(to_unsigned( 207 , 8)),
				 4 => std_logic_vector(to_unsigned( 103 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 102 , 8)),
				 7 => std_logic_vector(to_unsigned( 132 , 8)),
				 8 => std_logic_vector(to_unsigned( 106 , 8)),
				 9 => std_logic_vector(to_unsigned( 18 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 117 , 8)),
				 12 => std_logic_vector(to_unsigned( 248 , 8)),
				 13 => std_logic_vector(to_unsigned( 179 , 8)),
				 14 => std_logic_vector(to_unsigned( 83 , 8)),
				 15 => std_logic_vector(to_unsigned( 10 , 8)),
				 16 => std_logic_vector(to_unsigned( 231 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 231 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 497

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 30 , 8)),
				 1 => std_logic_vector(to_unsigned( 158 , 8)),
				 2 => std_logic_vector(to_unsigned( 153 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 85 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 164 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 70 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 196 , 8)),
				 14 => std_logic_vector(to_unsigned( 88 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 81 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 242 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 498

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 175 , 8)),
				 2 => std_logic_vector(to_unsigned( 166 , 8)),
				 3 => std_logic_vector(to_unsigned( 79 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 46 , 8)),
				 6 => std_logic_vector(to_unsigned( 180 , 8)),
				 7 => std_logic_vector(to_unsigned( 206 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 217 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 224 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 109 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 499

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 226 , 8)),
				 1 => std_logic_vector(to_unsigned( 185 , 8)),
				 2 => std_logic_vector(to_unsigned( 203 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 140 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 21 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 20 , 8)),
				 11 => std_logic_vector(to_unsigned( 19 , 8)),
				 12 => std_logic_vector(to_unsigned( 220 , 8)),
				 13 => std_logic_vector(to_unsigned( 33 , 8)),
				 14 => std_logic_vector(to_unsigned( 206 , 8)),
				 15 => std_logic_vector(to_unsigned( 49 , 8)),
				 16 => std_logic_vector(to_unsigned( 190 , 8)),
				 17 => std_logic_vector(to_unsigned( 102 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 500

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 161 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 143 , 8)),
				 3 => std_logic_vector(to_unsigned( 93 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 138 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 140 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 146 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 146 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 219 , 8)),
				 14 => std_logic_vector(to_unsigned( 62 , 8)),
				 15 => std_logic_vector(to_unsigned( 41 , 8)),
				 16 => std_logic_vector(to_unsigned( 156 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 44 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 501

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 93 , 8)),
				 1 => std_logic_vector(to_unsigned( 223 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 246 , 8)),
				 7 => std_logic_vector(to_unsigned( 130 , 8)),
				 8 => std_logic_vector(to_unsigned( 206 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 168 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 89 , 8)),
				 13 => std_logic_vector(to_unsigned( 68 , 8)),
				 14 => std_logic_vector(to_unsigned( 176 , 8)),
				 15 => std_logic_vector(to_unsigned( 106 , 8)),
				 16 => std_logic_vector(to_unsigned( 140 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 225 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 502

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 204 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 183 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 31 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 209 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 213 , 8)),
				 10 => std_logic_vector(to_unsigned( 88 , 8)),
				 11 => std_logic_vector(to_unsigned( 222 , 8)),
				 12 => std_logic_vector(to_unsigned( 79 , 8)),
				 13 => std_logic_vector(to_unsigned( 234 , 8)),
				 14 => std_logic_vector(to_unsigned( 67 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 57 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 503

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 192 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 68 , 8)),
				 11 => std_logic_vector(to_unsigned( 58 , 8)),
				 12 => std_logic_vector(to_unsigned( 254 , 8)),
				 13 => std_logic_vector(to_unsigned( 59 , 8)),
				 14 => std_logic_vector(to_unsigned( 253 , 8)),
				 15 => std_logic_vector(to_unsigned( 98 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 8 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 504

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 124 , 8)),
				 1 => std_logic_vector(to_unsigned( 41 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 158 , 8)),
				 5 => std_logic_vector(to_unsigned( 75 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 78 , 8)),
				 8 => std_logic_vector(to_unsigned( 123 , 8)),
				 9 => std_logic_vector(to_unsigned( 178 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 100 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 110 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 125 , 8)),
				 16 => std_logic_vector(to_unsigned( 23 , 8)),
				 17 => std_logic_vector(to_unsigned( 62 , 8)),
				 18 => std_logic_vector(to_unsigned( 232 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 505

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 59 , 8)),
				 4 => std_logic_vector(to_unsigned( 165 , 8)),
				 5 => std_logic_vector(to_unsigned( 78 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 79 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 80 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 64 , 8)),
				 12 => std_logic_vector(to_unsigned( 113 , 8)),
				 13 => std_logic_vector(to_unsigned( 131 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 144 , 8)),
				 16 => std_logic_vector(to_unsigned( 33 , 8)),
				 17 => std_logic_vector(to_unsigned( 36 , 8)),
				 18 => std_logic_vector(to_unsigned( 25 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 506

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 20 , 8)),
				 1 => std_logic_vector(to_unsigned( 175 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 91 , 8)),
				 6 => std_logic_vector(to_unsigned( 48 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 129 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 190 , 8)),
				 12 => std_logic_vector(to_unsigned( 99 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 198 , 8)),
				 18 => std_logic_vector(to_unsigned( 218 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 20 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 507

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 92 , 8)),
				 2 => std_logic_vector(to_unsigned( 18 , 8)),
				 3 => std_logic_vector(to_unsigned( 50 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 87 , 8)),
				 6 => std_logic_vector(to_unsigned( 162 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 153 , 8)),
				 9 => std_logic_vector(to_unsigned( 105 , 8)),
				 10 => std_logic_vector(to_unsigned( 57 , 8)),
				 11 => std_logic_vector(to_unsigned( 188 , 8)),
				 12 => std_logic_vector(to_unsigned( 39 , 8)),
				 13 => std_logic_vector(to_unsigned( 191 , 8)),
				 14 => std_logic_vector(to_unsigned( 36 , 8)),
				 15 => std_logic_vector(to_unsigned( 210 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 73 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 508

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 137 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 137 , 8)),
				 4 => std_logic_vector(to_unsigned( 1 , 8)),
				 5 => std_logic_vector(to_unsigned( 137 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 137 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 62 , 8)),
				 10 => std_logic_vector(to_unsigned( 82 , 8)),
				 11 => std_logic_vector(to_unsigned( 66 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 244 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 13 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 221 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 9 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 509

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 16 , 8)),
				 1 => std_logic_vector(to_unsigned( 200 , 8)),
				 2 => std_logic_vector(to_unsigned( 173 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 11 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 163 , 8)),
				 10 => std_logic_vector(to_unsigned( 128 , 8)),
				 11 => std_logic_vector(to_unsigned( 182 , 8)),
				 12 => std_logic_vector(to_unsigned( 109 , 8)),
				 13 => std_logic_vector(to_unsigned( 112 , 8)),
				 14 => std_logic_vector(to_unsigned( 131 , 8)),
				 15 => std_logic_vector(to_unsigned( 114 , 8)),
				 16 => std_logic_vector(to_unsigned( 129 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 252 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 510

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 127 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 216 , 8)),
				 4 => std_logic_vector(to_unsigned( 218 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 192 , 8)),
				 7 => std_logic_vector(to_unsigned( 43 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 202 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 146 , 8)),
				 13 => std_logic_vector(to_unsigned( 81 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 234 , 8)),
				 16 => std_logic_vector(to_unsigned( 203 , 8)),
				 17 => std_logic_vector(to_unsigned( 67 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 511

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 51 , 8)),
				 1 => std_logic_vector(to_unsigned( 119 , 8)),
				 2 => std_logic_vector(to_unsigned( 78 , 8)),
				 3 => std_logic_vector(to_unsigned( 49 , 8)),
				 4 => std_logic_vector(to_unsigned( 112 , 8)),
				 5 => std_logic_vector(to_unsigned( 114 , 8)),
				 6 => std_logic_vector(to_unsigned( 47 , 8)),
				 7 => std_logic_vector(to_unsigned( 20 , 8)),
				 8 => std_logic_vector(to_unsigned( 217 , 8)),
				 9 => std_logic_vector(to_unsigned( 12 , 8)),
				 10 => std_logic_vector(to_unsigned( 139 , 8)),
				 11 => std_logic_vector(to_unsigned( 68 , 8)),
				 12 => std_logic_vector(to_unsigned( 83 , 8)),
				 13 => std_logic_vector(to_unsigned( 77 , 8)),
				 14 => std_logic_vector(to_unsigned( 74 , 8)),
				 15 => std_logic_vector(to_unsigned( 28 , 8)),
				 16 => std_logic_vector(to_unsigned( 181 , 8)),
				 17 => std_logic_vector(to_unsigned( 148 , 8)),
				 18 => std_logic_vector(to_unsigned( 227 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 512

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 120 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 237 , 8)),
				 3 => std_logic_vector(to_unsigned( 85 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 59 , 8)),
				 6 => std_logic_vector(to_unsigned( 245 , 8)),
				 7 => std_logic_vector(to_unsigned( 215 , 8)),
				 8 => std_logic_vector(to_unsigned( 89 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 85 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 81 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 79 , 8)),
				 17 => std_logic_vector(to_unsigned( 123 , 8)),
				 18 => std_logic_vector(to_unsigned( 5 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 513

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 191 , 8)),
				 2 => std_logic_vector(to_unsigned( 224 , 8)),
				 3 => std_logic_vector(to_unsigned( 159 , 8)),
				 4 => std_logic_vector(to_unsigned( 34 , 8)),
				 5 => std_logic_vector(to_unsigned( 168 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 77 , 8)),
				 8 => std_logic_vector(to_unsigned( 193 , 8)),
				 9 => std_logic_vector(to_unsigned( 2 , 8)),
				 10 => std_logic_vector(to_unsigned( 137 , 8)),
				 11 => std_logic_vector(to_unsigned( 70 , 8)),
				 12 => std_logic_vector(to_unsigned( 69 , 8)),
				 13 => std_logic_vector(to_unsigned( 110 , 8)),
				 14 => std_logic_vector(to_unsigned( 129 , 8)),
				 15 => std_logic_vector(to_unsigned( 222 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 88 , 8)),
				 18 => std_logic_vector(to_unsigned( 244 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 514

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 222 , 8)),
				 1 => std_logic_vector(to_unsigned( 104 , 8)),
				 2 => std_logic_vector(to_unsigned( 201 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 52 , 8)),
				 5 => std_logic_vector(to_unsigned( 23 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 67 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 99 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 49 , 8)),
				 14 => std_logic_vector(to_unsigned( 220 , 8)),
				 15 => std_logic_vector(to_unsigned( 69 , 8)),
				 16 => std_logic_vector(to_unsigned( 46 , 8)),
				 17 => std_logic_vector(to_unsigned( 80 , 8)),
				 18 => std_logic_vector(to_unsigned( 245 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 515

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 38 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 201 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 172 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 222 , 8)),
				 9 => std_logic_vector(to_unsigned( 147 , 8)),
				 10 => std_logic_vector(to_unsigned( 202 , 8)),
				 11 => std_logic_vector(to_unsigned( 71 , 8)),
				 12 => std_logic_vector(to_unsigned( 89 , 8)),
				 13 => std_logic_vector(to_unsigned( 215 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 57 , 8)),
				 17 => std_logic_vector(to_unsigned( 212 , 8)),
				 18 => std_logic_vector(to_unsigned( 72 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 516

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 196 , 8)),
				 3 => std_logic_vector(to_unsigned( 150 , 8)),
				 4 => std_logic_vector(to_unsigned( 190 , 8)),
				 5 => std_logic_vector(to_unsigned( 181 , 8)),
				 6 => std_logic_vector(to_unsigned( 159 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 89 , 8)),
				 11 => std_logic_vector(to_unsigned( 168 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 169 , 8)),
				 14 => std_logic_vector(to_unsigned( 196 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 162 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 62 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 517

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 214 , 8)),
				 1 => std_logic_vector(to_unsigned( 254 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 84 , 8)),
				 5 => std_logic_vector(to_unsigned( 124 , 8)),
				 6 => std_logic_vector(to_unsigned( 48 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 169 , 8)),
				 9 => std_logic_vector(to_unsigned( 65 , 8)),
				 10 => std_logic_vector(to_unsigned( 39 , 8)),
				 11 => std_logic_vector(to_unsigned( 94 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 0 , 8)),
				 14 => std_logic_vector(to_unsigned( 86 , 8)),
				 15 => std_logic_vector(to_unsigned( 57 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 180 , 8)),
				 18 => std_logic_vector(to_unsigned( 95 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 518

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 82 , 8)),
				 1 => std_logic_vector(to_unsigned( 145 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 187 , 8)),
				 5 => std_logic_vector(to_unsigned( 185 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 219 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 186 , 8)),
				 10 => std_logic_vector(to_unsigned( 57 , 8)),
				 11 => std_logic_vector(to_unsigned( 134 , 8)),
				 12 => std_logic_vector(to_unsigned( 44 , 8)),
				 13 => std_logic_vector(to_unsigned( 144 , 8)),
				 14 => std_logic_vector(to_unsigned( 34 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 28 , 8)),
				 17 => std_logic_vector(to_unsigned( 145 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 519

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 198 , 8)),
				 1 => std_logic_vector(to_unsigned( 218 , 8)),
				 2 => std_logic_vector(to_unsigned( 104 , 8)),
				 3 => std_logic_vector(to_unsigned( 3 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 68 , 8)),
				 6 => std_logic_vector(to_unsigned( 51 , 8)),
				 7 => std_logic_vector(to_unsigned( 23 , 8)),
				 8 => std_logic_vector(to_unsigned( 189 , 8)),
				 9 => std_logic_vector(to_unsigned( 107 , 8)),
				 10 => std_logic_vector(to_unsigned( 105 , 8)),
				 11 => std_logic_vector(to_unsigned( 209 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 209 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 115 , 8)),
				 16 => std_logic_vector(to_unsigned( 25 , 8)),
				 17 => std_logic_vector(to_unsigned( 84 , 8)),
				 18 => std_logic_vector(to_unsigned( 126 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 520

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 39 , 8)),
				 1 => std_logic_vector(to_unsigned( 117 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 208 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 149 , 8)),
				 6 => std_logic_vector(to_unsigned( 82 , 8)),
				 7 => std_logic_vector(to_unsigned( 201 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 36 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 92 , 8)),
				 14 => std_logic_vector(to_unsigned( 58 , 8)),
				 15 => std_logic_vector(to_unsigned( 142 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 521

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 161 , 8)),
				 1 => std_logic_vector(to_unsigned( 246 , 8)),
				 2 => std_logic_vector(to_unsigned( 16 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 8 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 210 , 8)),
				 8 => std_logic_vector(to_unsigned( 122 , 8)),
				 9 => std_logic_vector(to_unsigned( 229 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 30 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 19 , 8)),
				 15 => std_logic_vector(to_unsigned( 99 , 8)),
				 16 => std_logic_vector(to_unsigned( 216 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 522

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 145 , 8)),
				 4 => std_logic_vector(to_unsigned( 55 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 192 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 0 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 130 , 8)),
				 12 => std_logic_vector(to_unsigned( 88 , 8)),
				 13 => std_logic_vector(to_unsigned( 204 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 246 , 8)),
				 17 => std_logic_vector(to_unsigned( 118 , 8)),
				 18 => std_logic_vector(to_unsigned( 79 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 523

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 118 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 148 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 177 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 79 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 72 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 143 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 114 , 8)),
				 17 => std_logic_vector(to_unsigned( 133 , 8)),
				 18 => std_logic_vector(to_unsigned( 64 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 524

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 218 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 212 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 211 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 140 , 8)),
				 9 => std_logic_vector(to_unsigned( 62 , 8)),
				 10 => std_logic_vector(to_unsigned( 164 , 8)),
				 11 => std_logic_vector(to_unsigned( 144 , 8)),
				 12 => std_logic_vector(to_unsigned( 82 , 8)),
				 13 => std_logic_vector(to_unsigned( 158 , 8)),
				 14 => std_logic_vector(to_unsigned( 20 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 89 , 8)),
				 18 => std_logic_vector(to_unsigned( 80 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 525

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 239 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 0 , 8)),
				 6 => std_logic_vector(to_unsigned( 217 , 8)),
				 7 => std_logic_vector(to_unsigned( 176 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 116 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 124 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 17 , 8)),
				 15 => std_logic_vector(to_unsigned( 9 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 203 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 526

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 120 , 8)),
				 1 => std_logic_vector(to_unsigned( 253 , 8)),
				 2 => std_logic_vector(to_unsigned( 40 , 8)),
				 3 => std_logic_vector(to_unsigned( 203 , 8)),
				 4 => std_logic_vector(to_unsigned( 88 , 8)),
				 5 => std_logic_vector(to_unsigned( 212 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 221 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 92 , 8)),
				 10 => std_logic_vector(to_unsigned( 122 , 8)),
				 11 => std_logic_vector(to_unsigned( 133 , 8)),
				 12 => std_logic_vector(to_unsigned( 81 , 8)),
				 13 => std_logic_vector(to_unsigned( 186 , 8)),
				 14 => std_logic_vector(to_unsigned( 28 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 527

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 40 , 8)),
				 1 => std_logic_vector(to_unsigned( 58 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 103 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 96 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 133 , 8)),
				 9 => std_logic_vector(to_unsigned( 59 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 61 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 16 , 8)),
				 14 => std_logic_vector(to_unsigned( 169 , 8)),
				 15 => std_logic_vector(to_unsigned( 169 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 230 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 40 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 528

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 27 , 8)),
				 1 => std_logic_vector(to_unsigned( 52 , 8)),
				 2 => std_logic_vector(to_unsigned( 200 , 8)),
				 3 => std_logic_vector(to_unsigned( 61 , 8)),
				 4 => std_logic_vector(to_unsigned( 184 , 8)),
				 5 => std_logic_vector(to_unsigned( 184 , 8)),
				 6 => std_logic_vector(to_unsigned( 148 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 97 , 8)),
				 9 => std_logic_vector(to_unsigned( 197 , 8)),
				 10 => std_logic_vector(to_unsigned( 178 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 164 , 8)),
				 14 => std_logic_vector(to_unsigned( 233 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 45 , 8)),
				 17 => std_logic_vector(to_unsigned( 196 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 529

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 51 , 8)),
				 3 => std_logic_vector(to_unsigned( 123 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 194 , 8)),
				 8 => std_logic_vector(to_unsigned( 153 , 8)),
				 9 => std_logic_vector(to_unsigned( 139 , 8)),
				 10 => std_logic_vector(to_unsigned( 19 , 8)),
				 11 => std_logic_vector(to_unsigned( 15 , 8)),
				 12 => std_logic_vector(to_unsigned( 210 , 8)),
				 13 => std_logic_vector(to_unsigned( 196 , 8)),
				 14 => std_logic_vector(to_unsigned( 29 , 8)),
				 15 => std_logic_vector(to_unsigned( 75 , 8)),
				 16 => std_logic_vector(to_unsigned( 203 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 241 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 530

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 143 , 8)),
				 1 => std_logic_vector(to_unsigned( 5 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 67 , 8)),
				 4 => std_logic_vector(to_unsigned( 143 , 8)),
				 5 => std_logic_vector(to_unsigned( 88 , 8)),
				 6 => std_logic_vector(to_unsigned( 122 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 114 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 92 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 92 , 8)),
				 17 => std_logic_vector(to_unsigned( 215 , 8)),
				 18 => std_logic_vector(to_unsigned( 60 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 136 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 531

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 42 , 8)),
				 2 => std_logic_vector(to_unsigned( 202 , 8)),
				 3 => std_logic_vector(to_unsigned( 67 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 185 , 8)),
				 6 => std_logic_vector(to_unsigned( 59 , 8)),
				 7 => std_logic_vector(to_unsigned( 226 , 8)),
				 8 => std_logic_vector(to_unsigned( 18 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 240 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 12 , 8)),
				 16 => std_logic_vector(to_unsigned( 117 , 8)),
				 17 => std_logic_vector(to_unsigned( 39 , 8)),
				 18 => std_logic_vector(to_unsigned( 63 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 532

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 60 , 8)),
				 2 => std_logic_vector(to_unsigned( 37 , 8)),
				 3 => std_logic_vector(to_unsigned( 184 , 8)),
				 4 => std_logic_vector(to_unsigned( 16 , 8)),
				 5 => std_logic_vector(to_unsigned( 198 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 12 , 8)),
				 15 => std_logic_vector(to_unsigned( 233 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 232 , 8)),
				 18 => std_logic_vector(to_unsigned( 110 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 533

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 155 , 8)),
				 3 => std_logic_vector(to_unsigned( 118 , 8)),
				 4 => std_logic_vector(to_unsigned( 118 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 28 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 178 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 180 , 8)),
				 14 => std_logic_vector(to_unsigned( 39 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 58 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 534

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 253 , 8)),
				 2 => std_logic_vector(to_unsigned( 29 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 29 , 8)),
				 5 => std_logic_vector(to_unsigned( 152 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 22 , 8)),
				 8 => std_logic_vector(to_unsigned( 152 , 8)),
				 9 => std_logic_vector(to_unsigned( 69 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 211 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 171 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 53 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 535

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 26 , 8)),
				 1 => std_logic_vector(to_unsigned( 138 , 8)),
				 2 => std_logic_vector(to_unsigned( 88 , 8)),
				 3 => std_logic_vector(to_unsigned( 130 , 8)),
				 4 => std_logic_vector(to_unsigned( 216 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 80 , 8)),
				 7 => std_logic_vector(to_unsigned( 5 , 8)),
				 8 => std_logic_vector(to_unsigned( 100 , 8)),
				 9 => std_logic_vector(to_unsigned( 223 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 233 , 8)),
				 12 => std_logic_vector(to_unsigned( 59 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 39 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 37 , 8)),
				 17 => std_logic_vector(to_unsigned( 173 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 536

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 110 , 8)),
				 1 => std_logic_vector(to_unsigned( 149 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 183 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 50 , 8)),
				 8 => std_logic_vector(to_unsigned( 132 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 60 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 167 , 8)),
				 15 => std_logic_vector(to_unsigned( 247 , 8)),
				 16 => std_logic_vector(to_unsigned( 140 , 8)),
				 17 => std_logic_vector(to_unsigned( 234 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 537

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 97 , 8)),
				 1 => std_logic_vector(to_unsigned( 4 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 22 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 33 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 75 , 8)),
				 8 => std_logic_vector(to_unsigned( 135 , 8)),
				 9 => std_logic_vector(to_unsigned( 124 , 8)),
				 10 => std_logic_vector(to_unsigned( 86 , 8)),
				 11 => std_logic_vector(to_unsigned( 85 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 154 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 229 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 89 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 538

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 18 , 8)),
				 1 => std_logic_vector(to_unsigned( 25 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 85 , 8)),
				 4 => std_logic_vector(to_unsigned( 162 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 156 , 8)),
				 8 => std_logic_vector(to_unsigned( 146 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 182 , 8)),
				 12 => std_logic_vector(to_unsigned( 216 , 8)),
				 13 => std_logic_vector(to_unsigned( 83 , 8)),
				 14 => std_logic_vector(to_unsigned( 189 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 71 , 8)),
				 17 => std_logic_vector(to_unsigned( 126 , 8)),
				 18 => std_logic_vector(to_unsigned( 82 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 539

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 98 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 228 , 8)),
				 3 => std_logic_vector(to_unsigned( 193 , 8)),
				 4 => std_logic_vector(to_unsigned( 68 , 8)),
				 5 => std_logic_vector(to_unsigned( 214 , 8)),
				 6 => std_logic_vector(to_unsigned( 47 , 8)),
				 7 => std_logic_vector(to_unsigned( 201 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 201 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 231 , 8)),
				 15 => std_logic_vector(to_unsigned( 211 , 8)),
				 16 => std_logic_vector(to_unsigned( 228 , 8)),
				 17 => std_logic_vector(to_unsigned( 234 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 540

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 179 , 8)),
				 2 => std_logic_vector(to_unsigned( 15 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 254 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 188 , 8)),
				 7 => std_logic_vector(to_unsigned( 194 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 41 , 8)),
				 10 => std_logic_vector(to_unsigned( 12 , 8)),
				 11 => std_logic_vector(to_unsigned( 44 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 162 , 8)),
				 15 => std_logic_vector(to_unsigned( 200 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 164 , 8)),
				 18 => std_logic_vector(to_unsigned( 39 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 541

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 89 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 188 , 8)),
				 3 => std_logic_vector(to_unsigned( 15 , 8)),
				 4 => std_logic_vector(to_unsigned( 44 , 8)),
				 5 => std_logic_vector(to_unsigned( 27 , 8)),
				 6 => std_logic_vector(to_unsigned( 32 , 8)),
				 7 => std_logic_vector(to_unsigned( 52 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 55 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 58 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 90 , 8)),
				 15 => std_logic_vector(to_unsigned( 246 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 153 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 542

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 154 , 8)),
				 3 => std_logic_vector(to_unsigned( 145 , 8)),
				 4 => std_logic_vector(to_unsigned( 111 , 8)),
				 5 => std_logic_vector(to_unsigned( 21 , 8)),
				 6 => std_logic_vector(to_unsigned( 24 , 8)),
				 7 => std_logic_vector(to_unsigned( 40 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 40 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 40 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 72 , 8)),
				 14 => std_logic_vector(to_unsigned( 239 , 8)),
				 15 => std_logic_vector(to_unsigned( 243 , 8)),
				 16 => std_logic_vector(to_unsigned( 183 , 8)),
				 17 => std_logic_vector(to_unsigned( 241 , 8)),
				 18 => std_logic_vector(to_unsigned( 116 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 543

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 40 , 8)),
				 1 => std_logic_vector(to_unsigned( 144 , 8)),
				 2 => std_logic_vector(to_unsigned( 151 , 8)),
				 3 => std_logic_vector(to_unsigned( 153 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 193 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 128 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 25 , 8)),
				 12 => std_logic_vector(to_unsigned( 152 , 8)),
				 13 => std_logic_vector(to_unsigned( 120 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 155 , 8)),
				 16 => std_logic_vector(to_unsigned( 64 , 8)),
				 17 => std_logic_vector(to_unsigned( 200 , 8)),
				 18 => std_logic_vector(to_unsigned( 27 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 544

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 71 , 8)),
				 1 => std_logic_vector(to_unsigned( 245 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 1 , 8)),
				 4 => std_logic_vector(to_unsigned( 176 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 128 , 8)),
				 11 => std_logic_vector(to_unsigned( 169 , 8)),
				 12 => std_logic_vector(to_unsigned( 89 , 8)),
				 13 => std_logic_vector(to_unsigned( 189 , 8)),
				 14 => std_logic_vector(to_unsigned( 69 , 8)),
				 15 => std_logic_vector(to_unsigned( 129 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 12 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 545

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 211 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 203 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 48 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 13 , 8)),
				 11 => std_logic_vector(to_unsigned( 134 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 137 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 143 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 0 , 8)),
				 18 => std_logic_vector(to_unsigned( 248 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 546

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 155 , 8)),
				 1 => std_logic_vector(to_unsigned( 239 , 8)),
				 2 => std_logic_vector(to_unsigned( 40 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 141 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 92 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 54 , 8)),
				 10 => std_logic_vector(to_unsigned( 209 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 20 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 40 , 8)),
				 18 => std_logic_vector(to_unsigned( 100 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 547

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 6 , 8)),
				 1 => std_logic_vector(to_unsigned( 41 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 113 , 8)),
				 4 => std_logic_vector(to_unsigned( 138 , 8)),
				 5 => std_logic_vector(to_unsigned( 177 , 8)),
				 6 => std_logic_vector(to_unsigned( 74 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 236 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 548

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 186 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 243 , 8)),
				 4 => std_logic_vector(to_unsigned( 154 , 8)),
				 5 => std_logic_vector(to_unsigned( 16 , 8)),
				 6 => std_logic_vector(to_unsigned( 231 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 187 , 8)),
				 9 => std_logic_vector(to_unsigned( 97 , 8)),
				 10 => std_logic_vector(to_unsigned( 150 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 81 , 8)),
				 16 => std_logic_vector(to_unsigned( 222 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 20 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 549

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 77 , 8)),
				 2 => std_logic_vector(to_unsigned( 29 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 68 , 8)),
				 5 => std_logic_vector(to_unsigned( 35 , 8)),
				 6 => std_logic_vector(to_unsigned( 227 , 8)),
				 7 => std_logic_vector(to_unsigned( 42 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 169 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 169 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 169 , 8)),
				 17 => std_logic_vector(to_unsigned( 150 , 8)),
				 18 => std_logic_vector(to_unsigned( 170 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 550

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 7 , 8)),
				 1 => std_logic_vector(to_unsigned( 110 , 8)),
				 2 => std_logic_vector(to_unsigned( 226 , 8)),
				 3 => std_logic_vector(to_unsigned( 40 , 8)),
				 4 => std_logic_vector(to_unsigned( 230 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 208 , 8)),
				 7 => std_logic_vector(to_unsigned( 1 , 8)),
				 8 => std_logic_vector(to_unsigned( 153 , 8)),
				 9 => std_logic_vector(to_unsigned( 39 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 101 , 8)),
				 12 => std_logic_vector(to_unsigned( 85 , 8)),
				 13 => std_logic_vector(to_unsigned( 116 , 8)),
				 14 => std_logic_vector(to_unsigned( 70 , 8)),
				 15 => std_logic_vector(to_unsigned( 188 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 68 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 551

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 236 , 8)),
				 1 => std_logic_vector(to_unsigned( 213 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 189 , 8)),
				 4 => std_logic_vector(to_unsigned( 52 , 8)),
				 5 => std_logic_vector(to_unsigned( 216 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 216 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 206 , 8)),
				 10 => std_logic_vector(to_unsigned( 105 , 8)),
				 11 => std_logic_vector(to_unsigned( 121 , 8)),
				 12 => std_logic_vector(to_unsigned( 31 , 8)),
				 13 => std_logic_vector(to_unsigned( 142 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 552

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 81 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 112 , 8)),
				 9 => std_logic_vector(to_unsigned( 229 , 8)),
				 10 => std_logic_vector(to_unsigned( 221 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 201 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 199 , 8)),
				 15 => std_logic_vector(to_unsigned( 112 , 8)),
				 16 => std_logic_vector(to_unsigned( 77 , 8)),
				 17 => std_logic_vector(to_unsigned( 181 , 8)),
				 18 => std_logic_vector(to_unsigned( 201 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 553

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 99 , 8)),
				 3 => std_logic_vector(to_unsigned( 183 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 122 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 122 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 120 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 120 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 120 , 8)),
				 17 => std_logic_vector(to_unsigned( 155 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 554

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 173 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 60 , 8)),
				 3 => std_logic_vector(to_unsigned( 71 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 44 , 8)),
				 7 => std_logic_vector(to_unsigned( 197 , 8)),
				 8 => std_logic_vector(to_unsigned( 145 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 127 , 8)),
				 11 => std_logic_vector(to_unsigned( 183 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 129 , 8)),
				 16 => std_logic_vector(to_unsigned( 20 , 8)),
				 17 => std_logic_vector(to_unsigned( 148 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 555

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 123 , 8)),
				 2 => std_logic_vector(to_unsigned( 215 , 8)),
				 3 => std_logic_vector(to_unsigned( 196 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 106 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 91 , 8)),
				 9 => std_logic_vector(to_unsigned( 102 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 29 , 8)),
				 13 => std_logic_vector(to_unsigned( 171 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 18 , 8)),
				 17 => std_logic_vector(to_unsigned( 155 , 8)),
				 18 => std_logic_vector(to_unsigned( 231 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 556

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 157 , 8)),
				 1 => std_logic_vector(to_unsigned( 213 , 8)),
				 2 => std_logic_vector(to_unsigned( 145 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 121 , 8)),
				 5 => std_logic_vector(to_unsigned( 77 , 8)),
				 6 => std_logic_vector(to_unsigned( 97 , 8)),
				 7 => std_logic_vector(to_unsigned( 89 , 8)),
				 8 => std_logic_vector(to_unsigned( 176 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 57 , 8)),
				 11 => std_logic_vector(to_unsigned( 188 , 8)),
				 12 => std_logic_vector(to_unsigned( 180 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 213 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 49 , 8)),
				 17 => std_logic_vector(to_unsigned( 52 , 8)),
				 18 => std_logic_vector(to_unsigned( 241 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 557

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 36 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 252 , 8)),
				 3 => std_logic_vector(to_unsigned( 74 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 235 , 8)),
				 6 => std_logic_vector(to_unsigned( 226 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 225 , 8)),
				 9 => std_logic_vector(to_unsigned( 243 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 35 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 235 , 8)),
				 15 => std_logic_vector(to_unsigned( 48 , 8)),
				 16 => std_logic_vector(to_unsigned( 231 , 8)),
				 17 => std_logic_vector(to_unsigned( 25 , 8)),
				 18 => std_logic_vector(to_unsigned( 40 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 558

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 25 , 8)),
				 2 => std_logic_vector(to_unsigned( 143 , 8)),
				 3 => std_logic_vector(to_unsigned( 164 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 199 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 89 , 8)),
				 11 => std_logic_vector(to_unsigned( 138 , 8)),
				 12 => std_logic_vector(to_unsigned( 94 , 8)),
				 13 => std_logic_vector(to_unsigned( 153 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 178 , 8)),
				 16 => std_logic_vector(to_unsigned( 54 , 8)),
				 17 => std_logic_vector(to_unsigned( 99 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 559

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 208 , 8)),
				 1 => std_logic_vector(to_unsigned( 211 , 8)),
				 2 => std_logic_vector(to_unsigned( 155 , 8)),
				 3 => std_logic_vector(to_unsigned( 158 , 8)),
				 4 => std_logic_vector(to_unsigned( 248 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 26 , 8)),
				 8 => std_logic_vector(to_unsigned( 105 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 121 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 123 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 123 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 115 , 8)),
				 18 => std_logic_vector(to_unsigned( 6 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 560

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 73 , 8)),
				 2 => std_logic_vector(to_unsigned( 186 , 8)),
				 3 => std_logic_vector(to_unsigned( 29 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 48 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 46 , 8)),
				 8 => std_logic_vector(to_unsigned( 237 , 8)),
				 9 => std_logic_vector(to_unsigned( 110 , 8)),
				 10 => std_logic_vector(to_unsigned( 173 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 14 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 28 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 233 , 8)),
				 18 => std_logic_vector(to_unsigned( 228 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 561

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 45 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 46 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 165 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 60 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 46 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 107 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 562

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 68 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 18 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 150 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 185 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 46 , 8)),
				 13 => std_logic_vector(to_unsigned( 119 , 8)),
				 14 => std_logic_vector(to_unsigned( 166 , 8)),
				 15 => std_logic_vector(to_unsigned( 223 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 40 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 563

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 255 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 217 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 217 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 179 , 8)),
				 9 => std_logic_vector(to_unsigned( 223 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 50 , 8)),
				 13 => std_logic_vector(to_unsigned( 40 , 8)),
				 14 => std_logic_vector(to_unsigned( 160 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 28 , 8)),
				 17 => std_logic_vector(to_unsigned( 134 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 564

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 195 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 23 , 8)),
				 4 => std_logic_vector(to_unsigned( 149 , 8)),
				 5 => std_logic_vector(to_unsigned( 149 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 107 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 96 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 107 , 8)),
				 16 => std_logic_vector(to_unsigned( 51 , 8)),
				 17 => std_logic_vector(to_unsigned( 26 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 565

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 152 , 8)),
				 1 => std_logic_vector(to_unsigned( 145 , 8)),
				 2 => std_logic_vector(to_unsigned( 64 , 8)),
				 3 => std_logic_vector(to_unsigned( 187 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 51 , 8)),
				 10 => std_logic_vector(to_unsigned( 50 , 8)),
				 11 => std_logic_vector(to_unsigned( 69 , 8)),
				 12 => std_logic_vector(to_unsigned( 32 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 93 , 8)),
				 16 => std_logic_vector(to_unsigned( 127 , 8)),
				 17 => std_logic_vector(to_unsigned( 27 , 8)),
				 18 => std_logic_vector(to_unsigned( 50 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 566

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 227 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 157 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 193 , 8)),
				 5 => std_logic_vector(to_unsigned( 116 , 8)),
				 6 => std_logic_vector(to_unsigned( 149 , 8)),
				 7 => std_logic_vector(to_unsigned( 8 , 8)),
				 8 => std_logic_vector(to_unsigned( 196 , 8)),
				 9 => std_logic_vector(to_unsigned( 27 , 8)),
				 10 => std_logic_vector(to_unsigned( 177 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 248 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 158 , 8)),
				 15 => std_logic_vector(to_unsigned( 141 , 8)),
				 16 => std_logic_vector(to_unsigned( 107 , 8)),
				 17 => std_logic_vector(to_unsigned( 138 , 8)),
				 18 => std_logic_vector(to_unsigned( 170 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 567

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 26 , 8)),
				 2 => std_logic_vector(to_unsigned( 177 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 169 , 8)),
				 6 => std_logic_vector(to_unsigned( 34 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 60 , 8)),
				 9 => std_logic_vector(to_unsigned( 128 , 8)),
				 10 => std_logic_vector(to_unsigned( 55 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 43 , 8)),
				 13 => std_logic_vector(to_unsigned( 201 , 8)),
				 14 => std_logic_vector(to_unsigned( 139 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 568

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 234 , 8)),
				 1 => std_logic_vector(to_unsigned( 12 , 8)),
				 2 => std_logic_vector(to_unsigned( 180 , 8)),
				 3 => std_logic_vector(to_unsigned( 137 , 8)),
				 4 => std_logic_vector(to_unsigned( 55 , 8)),
				 5 => std_logic_vector(to_unsigned( 153 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 3 , 8)),
				 8 => std_logic_vector(to_unsigned( 119 , 8)),
				 9 => std_logic_vector(to_unsigned( 3 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 138 , 8)),
				 12 => std_logic_vector(to_unsigned( 130 , 8)),
				 13 => std_logic_vector(to_unsigned( 137 , 8)),
				 14 => std_logic_vector(to_unsigned( 182 , 8)),
				 15 => std_logic_vector(to_unsigned( 86 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 43 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 569

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 77 , 8)),
				 1 => std_logic_vector(to_unsigned( 161 , 8)),
				 2 => std_logic_vector(to_unsigned( 222 , 8)),
				 3 => std_logic_vector(to_unsigned( 17 , 8)),
				 4 => std_logic_vector(to_unsigned( 136 , 8)),
				 5 => std_logic_vector(to_unsigned( 178 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 234 , 8)),
				 9 => std_logic_vector(to_unsigned( 67 , 8)),
				 10 => std_logic_vector(to_unsigned( 231 , 8)),
				 11 => std_logic_vector(to_unsigned( 78 , 8)),
				 12 => std_logic_vector(to_unsigned( 176 , 8)),
				 13 => std_logic_vector(to_unsigned( 126 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 82 , 8)),
				 17 => std_logic_vector(to_unsigned( 89 , 8)),
				 18 => std_logic_vector(to_unsigned( 254 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 570

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 150 , 8)),
				 1 => std_logic_vector(to_unsigned( 71 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 193 , 8)),
				 4 => std_logic_vector(to_unsigned( 62 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 224 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 168 , 8)),
				 15 => std_logic_vector(to_unsigned( 188 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 0 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 571

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 248 , 8)),
				 1 => std_logic_vector(to_unsigned( 155 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 69 , 8)),
				 4 => std_logic_vector(to_unsigned( 84 , 8)),
				 5 => std_logic_vector(to_unsigned( 102 , 8)),
				 6 => std_logic_vector(to_unsigned( 180 , 8)),
				 7 => std_logic_vector(to_unsigned( 128 , 8)),
				 8 => std_logic_vector(to_unsigned( 154 , 8)),
				 9 => std_logic_vector(to_unsigned( 186 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 43 , 8)),
				 13 => std_logic_vector(to_unsigned( 90 , 8)),
				 14 => std_logic_vector(to_unsigned( 185 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 59 , 8)),
				 17 => std_logic_vector(to_unsigned( 178 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 572

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 234 , 8)),
				 3 => std_logic_vector(to_unsigned( 84 , 8)),
				 4 => std_logic_vector(to_unsigned( 183 , 8)),
				 5 => std_logic_vector(to_unsigned( 75 , 8)),
				 6 => std_logic_vector(to_unsigned( 173 , 8)),
				 7 => std_logic_vector(to_unsigned( 38 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 139 , 8)),
				 12 => std_logic_vector(to_unsigned( 55 , 8)),
				 13 => std_logic_vector(to_unsigned( 195 , 8)),
				 14 => std_logic_vector(to_unsigned( 126 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 190 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 40 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 573

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 152 , 8)),
				 4 => std_logic_vector(to_unsigned( 144 , 8)),
				 5 => std_logic_vector(to_unsigned( 214 , 8)),
				 6 => std_logic_vector(to_unsigned( 155 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 220 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 223 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 148 , 8)),
				 18 => std_logic_vector(to_unsigned( 97 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 574

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 63 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 70 , 8)),
				 3 => std_logic_vector(to_unsigned( 11 , 8)),
				 4 => std_logic_vector(to_unsigned( 223 , 8)),
				 5 => std_logic_vector(to_unsigned( 72 , 8)),
				 6 => std_logic_vector(to_unsigned( 254 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 168 , 8)),
				 9 => std_logic_vector(to_unsigned( 157 , 8)),
				 10 => std_logic_vector(to_unsigned( 29 , 8)),
				 11 => std_logic_vector(to_unsigned( 182 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 182 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 137 , 8)),
				 16 => std_logic_vector(to_unsigned( 90 , 8)),
				 17 => std_logic_vector(to_unsigned( 128 , 8)),
				 18 => std_logic_vector(to_unsigned( 123 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 575

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 21 , 8)),
				 2 => std_logic_vector(to_unsigned( 90 , 8)),
				 3 => std_logic_vector(to_unsigned( 151 , 8)),
				 4 => std_logic_vector(to_unsigned( 61 , 8)),
				 5 => std_logic_vector(to_unsigned( 133 , 8)),
				 6 => std_logic_vector(to_unsigned( 66 , 8)),
				 7 => std_logic_vector(to_unsigned( 3 , 8)),
				 8 => std_logic_vector(to_unsigned( 97 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 198 , 8)),
				 11 => std_logic_vector(to_unsigned( 148 , 8)),
				 12 => std_logic_vector(to_unsigned( 88 , 8)),
				 13 => std_logic_vector(to_unsigned( 148 , 8)),
				 14 => std_logic_vector(to_unsigned( 88 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 148 , 8)),
				 17 => std_logic_vector(to_unsigned( 192 , 8)),
				 18 => std_logic_vector(to_unsigned( 23 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 576

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 82 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 214 , 8)),
				 3 => std_logic_vector(to_unsigned( 221 , 8)),
				 4 => std_logic_vector(to_unsigned( 155 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 131 , 8)),
				 7 => std_logic_vector(to_unsigned( 103 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 104 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 104 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 213 , 8)),
				 17 => std_logic_vector(to_unsigned( 174 , 8)),
				 18 => std_logic_vector(to_unsigned( 172 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 577

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 15 , 8)),
				 1 => std_logic_vector(to_unsigned( 71 , 8)),
				 2 => std_logic_vector(to_unsigned( 45 , 8)),
				 3 => std_logic_vector(to_unsigned( 109 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 110 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 114 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 125 , 8)),
				 10 => std_logic_vector(to_unsigned( 206 , 8)),
				 11 => std_logic_vector(to_unsigned( 38 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 40 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 17 , 8)),
				 16 => std_logic_vector(to_unsigned( 54 , 8)),
				 17 => std_logic_vector(to_unsigned( 173 , 8)),
				 18 => std_logic_vector(to_unsigned( 46 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 15 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 578

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 102 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 159 , 8)),
				 4 => std_logic_vector(to_unsigned( 204 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 165 , 8)),
				 8 => std_logic_vector(to_unsigned( 162 , 8)),
				 9 => std_logic_vector(to_unsigned( 142 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 216 , 8)),
				 13 => std_logic_vector(to_unsigned( 231 , 8)),
				 14 => std_logic_vector(to_unsigned( 52 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 28 , 8)),
				 17 => std_logic_vector(to_unsigned( 189 , 8)),
				 18 => std_logic_vector(to_unsigned( 108 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 579

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 52 , 8)),
				 4 => std_logic_vector(to_unsigned( 197 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 222 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 138 , 8)),
				 9 => std_logic_vector(to_unsigned( 56 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 62 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 66 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 231 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 580

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 33 , 8)),
				 1 => std_logic_vector(to_unsigned( 73 , 8)),
				 2 => std_logic_vector(to_unsigned( 160 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 89 , 8)),
				 5 => std_logic_vector(to_unsigned( 230 , 8)),
				 6 => std_logic_vector(to_unsigned( 87 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 142 , 8)),
				 12 => std_logic_vector(to_unsigned( 126 , 8)),
				 13 => std_logic_vector(to_unsigned( 48 , 8)),
				 14 => std_logic_vector(to_unsigned( 202 , 8)),
				 15 => std_logic_vector(to_unsigned( 78 , 8)),
				 16 => std_logic_vector(to_unsigned( 172 , 8)),
				 17 => std_logic_vector(to_unsigned( 184 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 581

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 92 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 95 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 95 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 95 , 8)),
				 7 => std_logic_vector(to_unsigned( 95 , 8)),
				 8 => std_logic_vector(to_unsigned( 94 , 8)),
				 9 => std_logic_vector(to_unsigned( 12 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 43 , 8)),
				 12 => std_logic_vector(to_unsigned( 88 , 8)),
				 13 => std_logic_vector(to_unsigned( 10 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 39 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 582

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 124 , 8)),
				 1 => std_logic_vector(to_unsigned( 121 , 8)),
				 2 => std_logic_vector(to_unsigned( 171 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 148 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 88 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 79 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 76 , 8)),
				 13 => std_logic_vector(to_unsigned( 118 , 8)),
				 14 => std_logic_vector(to_unsigned( 98 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 80 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 583

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 140 , 8)),
				 2 => std_logic_vector(to_unsigned( 68 , 8)),
				 3 => std_logic_vector(to_unsigned( 39 , 8)),
				 4 => std_logic_vector(to_unsigned( 191 , 8)),
				 5 => std_logic_vector(to_unsigned( 53 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 229 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 42 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 61 , 8)),
				 12 => std_logic_vector(to_unsigned( 106 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 86 , 8)),
				 15 => std_logic_vector(to_unsigned( 145 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 584

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 112 , 8)),
				 2 => std_logic_vector(to_unsigned( 83 , 8)),
				 3 => std_logic_vector(to_unsigned( 166 , 8)),
				 4 => std_logic_vector(to_unsigned( 29 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 97 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 153 , 8)),
				 10 => std_logic_vector(to_unsigned( 86 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 93 , 8)),
				 13 => std_logic_vector(to_unsigned( 74 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 101 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 188 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 585

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 209 , 8)),
				 2 => std_logic_vector(to_unsigned( 224 , 8)),
				 3 => std_logic_vector(to_unsigned( 0 , 8)),
				 4 => std_logic_vector(to_unsigned( 107 , 8)),
				 5 => std_logic_vector(to_unsigned( 7 , 8)),
				 6 => std_logic_vector(to_unsigned( 248 , 8)),
				 7 => std_logic_vector(to_unsigned( 49 , 8)),
				 8 => std_logic_vector(to_unsigned( 91 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 181 , 8)),
				 12 => std_logic_vector(to_unsigned( 241 , 8)),
				 13 => std_logic_vector(to_unsigned( 207 , 8)),
				 14 => std_logic_vector(to_unsigned( 215 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 215 , 8)),
				 17 => std_logic_vector(to_unsigned( 185 , 8)),
				 18 => std_logic_vector(to_unsigned( 164 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 586

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 7 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 50 , 8)),
				 5 => std_logic_vector(to_unsigned( 169 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 184 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 190 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 103 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 129 , 8)),
				 14 => std_logic_vector(to_unsigned( 240 , 8)),
				 15 => std_logic_vector(to_unsigned( 222 , 8)),
				 16 => std_logic_vector(to_unsigned( 147 , 8)),
				 17 => std_logic_vector(to_unsigned( 153 , 8)),
				 18 => std_logic_vector(to_unsigned( 40 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 587

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 33 , 8)),
				 1 => std_logic_vector(to_unsigned( 122 , 8)),
				 2 => std_logic_vector(to_unsigned( 41 , 8)),
				 3 => std_logic_vector(to_unsigned( 73 , 8)),
				 4 => std_logic_vector(to_unsigned( 110 , 8)),
				 5 => std_logic_vector(to_unsigned( 129 , 8)),
				 6 => std_logic_vector(to_unsigned( 62 , 8)),
				 7 => std_logic_vector(to_unsigned( 148 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 162 , 8)),
				 10 => std_logic_vector(to_unsigned( 29 , 8)),
				 11 => std_logic_vector(to_unsigned( 99 , 8)),
				 12 => std_logic_vector(to_unsigned( 189 , 8)),
				 13 => std_logic_vector(to_unsigned( 81 , 8)),
				 14 => std_logic_vector(to_unsigned( 244 , 8)),
				 15 => std_logic_vector(to_unsigned( 136 , 8)),
				 16 => std_logic_vector(to_unsigned( 189 , 8)),
				 17 => std_logic_vector(to_unsigned( 251 , 8)),
				 18 => std_logic_vector(to_unsigned( 136 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 588

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 49 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 178 , 8)),
				 3 => std_logic_vector(to_unsigned( 181 , 8)),
				 4 => std_logic_vector(to_unsigned( 115 , 8)),
				 5 => std_logic_vector(to_unsigned( 183 , 8)),
				 6 => std_logic_vector(to_unsigned( 113 , 8)),
				 7 => std_logic_vector(to_unsigned( 50 , 8)),
				 8 => std_logic_vector(to_unsigned( 203 , 8)),
				 9 => std_logic_vector(to_unsigned( 132 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 62 , 8)),
				 14 => std_logic_vector(to_unsigned( 212 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 100 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 132 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 589

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 140 , 8)),
				 2 => std_logic_vector(to_unsigned( 235 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 203 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 154 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 124 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 4 , 8)),
				 12 => std_logic_vector(to_unsigned( 124 , 8)),
				 13 => std_logic_vector(to_unsigned( 59 , 8)),
				 14 => std_logic_vector(to_unsigned( 69 , 8)),
				 15 => std_logic_vector(to_unsigned( 123 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 93 , 8)),
				 18 => std_logic_vector(to_unsigned( 135 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 590

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 45 , 8)),
				 2 => std_logic_vector(to_unsigned( 68 , 8)),
				 3 => std_logic_vector(to_unsigned( 108 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 173 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 173 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 180 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 150 , 8)),
				 13 => std_logic_vector(to_unsigned( 217 , 8)),
				 14 => std_logic_vector(to_unsigned( 108 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 210 , 8)),
				 18 => std_logic_vector(to_unsigned( 106 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 591

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 158 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 14 , 8)),
				 4 => std_logic_vector(to_unsigned( 233 , 8)),
				 5 => std_logic_vector(to_unsigned( 102 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 157 , 8)),
				 9 => std_logic_vector(to_unsigned( 67 , 8)),
				 10 => std_logic_vector(to_unsigned( 216 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 102 , 8)),
				 13 => std_logic_vector(to_unsigned( 67 , 8)),
				 14 => std_logic_vector(to_unsigned( 173 , 8)),
				 15 => std_logic_vector(to_unsigned( 161 , 8)),
				 16 => std_logic_vector(to_unsigned( 11 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 245 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 592

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 92 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 15 , 8)),
				 3 => std_logic_vector(to_unsigned( 89 , 8)),
				 4 => std_logic_vector(to_unsigned( 142 , 8)),
				 5 => std_logic_vector(to_unsigned( 218 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 86 , 8)),
				 8 => std_logic_vector(to_unsigned( 132 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 12 , 8)),
				 13 => std_logic_vector(to_unsigned( 212 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 235 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 593

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 114 , 8)),
				 1 => std_logic_vector(to_unsigned( 94 , 8)),
				 2 => std_logic_vector(to_unsigned( 60 , 8)),
				 3 => std_logic_vector(to_unsigned( 119 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 233 , 8)),
				 7 => std_logic_vector(to_unsigned( 214 , 8)),
				 8 => std_logic_vector(to_unsigned( 220 , 8)),
				 9 => std_logic_vector(to_unsigned( 155 , 8)),
				 10 => std_logic_vector(to_unsigned( 34 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 17 , 8)),
				 13 => std_logic_vector(to_unsigned( 178 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 182 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 594

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 191 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 121 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 86 , 8)),
				 5 => std_logic_vector(to_unsigned( 89 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 205 , 8)),
				 9 => std_logic_vector(to_unsigned( 170 , 8)),
				 10 => std_logic_vector(to_unsigned( 159 , 8)),
				 11 => std_logic_vector(to_unsigned( 210 , 8)),
				 12 => std_logic_vector(to_unsigned( 160 , 8)),
				 13 => std_logic_vector(to_unsigned( 233 , 8)),
				 14 => std_logic_vector(to_unsigned( 137 , 8)),
				 15 => std_logic_vector(to_unsigned( 204 , 8)),
				 16 => std_logic_vector(to_unsigned( 184 , 8)),
				 17 => std_logic_vector(to_unsigned( 25 , 8)),
				 18 => std_logic_vector(to_unsigned( 151 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 595

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 0 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 135 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 230 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 239 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 86 , 8)),
				 13 => std_logic_vector(to_unsigned( 65 , 8)),
				 14 => std_logic_vector(to_unsigned( 62 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 30 , 8)),
				 17 => std_logic_vector(to_unsigned( 184 , 8)),
				 18 => std_logic_vector(to_unsigned( 237 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 0 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 596

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 101 , 8)),
				 1 => std_logic_vector(to_unsigned( 245 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 175 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 127 , 8)),
				 7 => std_logic_vector(to_unsigned( 232 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 82 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 81 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 597

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 40 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 133 , 8)),
				 3 => std_logic_vector(to_unsigned( 232 , 8)),
				 4 => std_logic_vector(to_unsigned( 126 , 8)),
				 5 => std_logic_vector(to_unsigned( 116 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 120 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 126 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 128 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 128 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 191 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 40 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 598

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 90 , 8)),
				 2 => std_logic_vector(to_unsigned( 60 , 8)),
				 3 => std_logic_vector(to_unsigned( 61 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 70 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 35 , 8)),
				 10 => std_logic_vector(to_unsigned( 213 , 8)),
				 11 => std_logic_vector(to_unsigned( 149 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 159 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 230 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 599

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 9 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 57 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 33 , 8)),
				 5 => std_logic_vector(to_unsigned( 60 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 67 , 8)),
				 8 => std_logic_vector(to_unsigned( 23 , 8)),
				 9 => std_logic_vector(to_unsigned( 79 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 89 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 89 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 89 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 2 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 600

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 174 , 8)),
				 1 => std_logic_vector(to_unsigned( 203 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 61 , 8)),
				 4 => std_logic_vector(to_unsigned( 204 , 8)),
				 5 => std_logic_vector(to_unsigned( 203 , 8)),
				 6 => std_logic_vector(to_unsigned( 62 , 8)),
				 7 => std_logic_vector(to_unsigned( 170 , 8)),
				 8 => std_logic_vector(to_unsigned( 110 , 8)),
				 9 => std_logic_vector(to_unsigned( 182 , 8)),
				 10 => std_logic_vector(to_unsigned( 98 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 26 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 25 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 25 , 8)),
				 17 => std_logic_vector(to_unsigned( 173 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 601

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 32 , 8)),
				 1 => std_logic_vector(to_unsigned( 113 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 131 , 8)),
				 4 => std_logic_vector(to_unsigned( 148 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 85 , 8)),
				 7 => std_logic_vector(to_unsigned( 135 , 8)),
				 8 => std_logic_vector(to_unsigned( 253 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 190 , 8)),
				 11 => std_logic_vector(to_unsigned( 218 , 8)),
				 12 => std_logic_vector(to_unsigned( 118 , 8)),
				 13 => std_logic_vector(to_unsigned( 235 , 8)),
				 14 => std_logic_vector(to_unsigned( 25 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 20 , 8)),
				 17 => std_logic_vector(to_unsigned( 216 , 8)),
				 18 => std_logic_vector(to_unsigned( 72 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 602

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 182 , 8)),
				 1 => std_logic_vector(to_unsigned( 17 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 59 , 8)),
				 4 => std_logic_vector(to_unsigned( 11 , 8)),
				 5 => std_logic_vector(to_unsigned( 24 , 8)),
				 6 => std_logic_vector(to_unsigned( 179 , 8)),
				 7 => std_logic_vector(to_unsigned( 116 , 8)),
				 8 => std_logic_vector(to_unsigned( 157 , 8)),
				 9 => std_logic_vector(to_unsigned( 128 , 8)),
				 10 => std_logic_vector(to_unsigned( 145 , 8)),
				 11 => std_logic_vector(to_unsigned( 130 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 147 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 250 , 8)),
				 17 => std_logic_vector(to_unsigned( 12 , 8)),
				 18 => std_logic_vector(to_unsigned( 204 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 603

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 82 , 8)),
				 1 => std_logic_vector(to_unsigned( 211 , 8)),
				 2 => std_logic_vector(to_unsigned( 247 , 8)),
				 3 => std_logic_vector(to_unsigned( 227 , 8)),
				 4 => std_logic_vector(to_unsigned( 59 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 40 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 91 , 8)),
				 12 => std_logic_vector(to_unsigned( 243 , 8)),
				 13 => std_logic_vector(to_unsigned( 124 , 8)),
				 14 => std_logic_vector(to_unsigned( 210 , 8)),
				 15 => std_logic_vector(to_unsigned( 127 , 8)),
				 16 => std_logic_vector(to_unsigned( 207 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 180 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 604

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 101 , 8)),
				 3 => std_logic_vector(to_unsigned( 111 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 85 , 8)),
				 6 => std_logic_vector(to_unsigned( 99 , 8)),
				 7 => std_logic_vector(to_unsigned( 122 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 128 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 90 , 8)),
				 17 => std_logic_vector(to_unsigned( 220 , 8)),
				 18 => std_logic_vector(to_unsigned( 42 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 605

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 107 , 8)),
				 3 => std_logic_vector(to_unsigned( 109 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 173 , 8)),
				 8 => std_logic_vector(to_unsigned( 67 , 8)),
				 9 => std_logic_vector(to_unsigned( 222 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 80 , 8)),
				 14 => std_logic_vector(to_unsigned( 67 , 8)),
				 15 => std_logic_vector(to_unsigned( 60 , 8)),
				 16 => std_logic_vector(to_unsigned( 126 , 8)),
				 17 => std_logic_vector(to_unsigned( 150 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 606

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 250 , 8)),
				 3 => std_logic_vector(to_unsigned( 131 , 8)),
				 4 => std_logic_vector(to_unsigned( 237 , 8)),
				 5 => std_logic_vector(to_unsigned( 218 , 8)),
				 6 => std_logic_vector(to_unsigned( 150 , 8)),
				 7 => std_logic_vector(to_unsigned( 232 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 156 , 8)),
				 10 => std_logic_vector(to_unsigned( 233 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 180 , 8)),
				 14 => std_logic_vector(to_unsigned( 92 , 8)),
				 15 => std_logic_vector(to_unsigned( 223 , 8)),
				 16 => std_logic_vector(to_unsigned( 49 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 607

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 4 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 182 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 160 , 8)),
				 6 => std_logic_vector(to_unsigned( 215 , 8)),
				 7 => std_logic_vector(to_unsigned( 108 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 201 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 63 , 8)),
				 12 => std_logic_vector(to_unsigned( 203 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 106 , 8)),
				 15 => std_logic_vector(to_unsigned( 180 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 124 , 8)),
				 18 => std_logic_vector(to_unsigned( 32 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 608

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 205 , 8)),
				 1 => std_logic_vector(to_unsigned( 0 , 8)),
				 2 => std_logic_vector(to_unsigned( 127 , 8)),
				 3 => std_logic_vector(to_unsigned( 8 , 8)),
				 4 => std_logic_vector(to_unsigned( 119 , 8)),
				 5 => std_logic_vector(to_unsigned( 164 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 48 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 137 , 8)),
				 14 => std_logic_vector(to_unsigned( 254 , 8)),
				 15 => std_logic_vector(to_unsigned( 27 , 8)),
				 16 => std_logic_vector(to_unsigned( 198 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 0 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 609

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 134 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 11 , 8)),
				 4 => std_logic_vector(to_unsigned( 241 , 8)),
				 5 => std_logic_vector(to_unsigned( 39 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 41 , 8)),
				 8 => std_logic_vector(to_unsigned( 135 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 181 , 8)),
				 12 => std_logic_vector(to_unsigned( 183 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 123 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 120 , 8)),
				 17 => std_logic_vector(to_unsigned( 246 , 8)),
				 18 => std_logic_vector(to_unsigned( 147 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 610

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 2 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 172 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 197 , 8)),
				 7 => std_logic_vector(to_unsigned( 126 , 8)),
				 8 => std_logic_vector(to_unsigned( 223 , 8)),
				 9 => std_logic_vector(to_unsigned( 53 , 8)),
				 10 => std_logic_vector(to_unsigned( 119 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 97 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 190 , 8)),
				 16 => std_logic_vector(to_unsigned( 103 , 8)),
				 17 => std_logic_vector(to_unsigned( 218 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 611

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 74 , 8)),
				 1 => std_logic_vector(to_unsigned( 75 , 8)),
				 2 => std_logic_vector(to_unsigned( 224 , 8)),
				 3 => std_logic_vector(to_unsigned( 136 , 8)),
				 4 => std_logic_vector(to_unsigned( 185 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 90 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 90 , 8)),
				 9 => std_logic_vector(to_unsigned( 212 , 8)),
				 10 => std_logic_vector(to_unsigned( 115 , 8)),
				 11 => std_logic_vector(to_unsigned( 234 , 8)),
				 12 => std_logic_vector(to_unsigned( 93 , 8)),
				 13 => std_logic_vector(to_unsigned( 77 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 145 , 8)),
				 16 => std_logic_vector(to_unsigned( 84 , 8)),
				 17 => std_logic_vector(to_unsigned( 32 , 8)),
				 18 => std_logic_vector(to_unsigned( 85 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 612

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 160 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 108 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 92 , 8)),
				 5 => std_logic_vector(to_unsigned( 103 , 8)),
				 6 => std_logic_vector(to_unsigned( 110 , 8)),
				 7 => std_logic_vector(to_unsigned( 36 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 41 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 43 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 43 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 44 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 107 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 613

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 26 , 8)),
				 1 => std_logic_vector(to_unsigned( 61 , 8)),
				 2 => std_logic_vector(to_unsigned( 8 , 8)),
				 3 => std_logic_vector(to_unsigned( 103 , 8)),
				 4 => std_logic_vector(to_unsigned( 81 , 8)),
				 5 => std_logic_vector(to_unsigned( 156 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 229 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 66 , 8)),
				 11 => std_logic_vector(to_unsigned( 29 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 60 , 8)),
				 14 => std_logic_vector(to_unsigned( 114 , 8)),
				 15 => std_logic_vector(to_unsigned( 170 , 8)),
				 16 => std_logic_vector(to_unsigned( 195 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 118 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 614

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 158 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 93 , 8)),
				 3 => std_logic_vector(to_unsigned( 211 , 8)),
				 4 => std_logic_vector(to_unsigned( 226 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 194 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 146 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 235 , 8)),
				 12 => std_logic_vector(to_unsigned( 35 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 17 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 159 , 8)),
				 18 => std_logic_vector(to_unsigned( 81 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 615

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 9 , 8)),
				 2 => std_logic_vector(to_unsigned( 12 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 239 , 8)),
				 6 => std_logic_vector(to_unsigned( 112 , 8)),
				 7 => std_logic_vector(to_unsigned( 176 , 8)),
				 8 => std_logic_vector(to_unsigned( 93 , 8)),
				 9 => std_logic_vector(to_unsigned( 130 , 8)),
				 10 => std_logic_vector(to_unsigned( 237 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 54 , 8)),
				 13 => std_logic_vector(to_unsigned( 66 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 2 , 8)),
				 16 => std_logic_vector(to_unsigned( 145 , 8)),
				 17 => std_logic_vector(to_unsigned( 182 , 8)),
				 18 => std_logic_vector(to_unsigned( 152 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 616

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 84 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 211 , 8)),
				 4 => std_logic_vector(to_unsigned( 226 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 135 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 44 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 254 , 8)),
				 13 => std_logic_vector(to_unsigned( 197 , 8)),
				 14 => std_logic_vector(to_unsigned( 244 , 8)),
				 15 => std_logic_vector(to_unsigned( 243 , 8)),
				 16 => std_logic_vector(to_unsigned( 198 , 8)),
				 17 => std_logic_vector(to_unsigned( 121 , 8)),
				 18 => std_logic_vector(to_unsigned( 165 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 617

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 39 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 183 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 102 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 100 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 100 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 117 , 8)),
				 11 => std_logic_vector(to_unsigned( 20 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 191 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 179 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 618

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 12 , 8)),
				 1 => std_logic_vector(to_unsigned( 200 , 8)),
				 2 => std_logic_vector(to_unsigned( 26 , 8)),
				 3 => std_logic_vector(to_unsigned( 217 , 8)),
				 4 => std_logic_vector(to_unsigned( 9 , 8)),
				 5 => std_logic_vector(to_unsigned( 175 , 8)),
				 6 => std_logic_vector(to_unsigned( 69 , 8)),
				 7 => std_logic_vector(to_unsigned( 220 , 8)),
				 8 => std_logic_vector(to_unsigned( 24 , 8)),
				 9 => std_logic_vector(to_unsigned( 158 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 24 , 8)),
				 12 => std_logic_vector(to_unsigned( 219 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 1 , 8)),
				 18 => std_logic_vector(to_unsigned( 101 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 619

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 129 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 164 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 45 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 205 , 8)),
				 10 => std_logic_vector(to_unsigned( 169 , 8)),
				 11 => std_logic_vector(to_unsigned( 128 , 8)),
				 12 => std_logic_vector(to_unsigned( 164 , 8)),
				 13 => std_logic_vector(to_unsigned( 238 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 170 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 620

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 132 , 8)),
				 1 => std_logic_vector(to_unsigned( 48 , 8)),
				 2 => std_logic_vector(to_unsigned( 12 , 8)),
				 3 => std_logic_vector(to_unsigned( 52 , 8)),
				 4 => std_logic_vector(to_unsigned( 8 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 59 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 59 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 59 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 144 , 8)),
				 16 => std_logic_vector(to_unsigned( 134 , 8)),
				 17 => std_logic_vector(to_unsigned( 214 , 8)),
				 18 => std_logic_vector(to_unsigned( 80 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 621

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 27 , 8)),
				 5 => std_logic_vector(to_unsigned( 119 , 8)),
				 6 => std_logic_vector(to_unsigned( 159 , 8)),
				 7 => std_logic_vector(to_unsigned( 192 , 8)),
				 8 => std_logic_vector(to_unsigned( 86 , 8)),
				 9 => std_logic_vector(to_unsigned( 177 , 8)),
				 10 => std_logic_vector(to_unsigned( 209 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 183 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 143 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 134 , 8)),
				 17 => std_logic_vector(to_unsigned( 117 , 8)),
				 18 => std_logic_vector(to_unsigned( 253 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 622

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 163 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 184 , 8)),
				 6 => std_logic_vector(to_unsigned( 81 , 8)),
				 7 => std_logic_vector(to_unsigned( 190 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 27 , 8)),
				 10 => std_logic_vector(to_unsigned( 68 , 8)),
				 11 => std_logic_vector(to_unsigned( 152 , 8)),
				 12 => std_logic_vector(to_unsigned( 203 , 8)),
				 13 => std_logic_vector(to_unsigned( 16 , 8)),
				 14 => std_logic_vector(to_unsigned( 65 , 8)),
				 15 => std_logic_vector(to_unsigned( 216 , 8)),
				 16 => std_logic_vector(to_unsigned( 41 , 8)),
				 17 => std_logic_vector(to_unsigned( 17 , 8)),
				 18 => std_logic_vector(to_unsigned( 215 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 623

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 22 , 8)),
				 1 => std_logic_vector(to_unsigned( 202 , 8)),
				 2 => std_logic_vector(to_unsigned( 222 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 187 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 181 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 175 , 8)),
				 11 => std_logic_vector(to_unsigned( 162 , 8)),
				 12 => std_logic_vector(to_unsigned( 237 , 8)),
				 13 => std_logic_vector(to_unsigned( 199 , 8)),
				 14 => std_logic_vector(to_unsigned( 200 , 8)),
				 15 => std_logic_vector(to_unsigned( 74 , 8)),
				 16 => std_logic_vector(to_unsigned( 222 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 624

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 222 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 141 , 8)),
				 3 => std_logic_vector(to_unsigned( 126 , 8)),
				 4 => std_logic_vector(to_unsigned( 111 , 8)),
				 5 => std_logic_vector(to_unsigned( 54 , 8)),
				 6 => std_logic_vector(to_unsigned( 111 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 107 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 99 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 95 , 8)),
				 15 => std_logic_vector(to_unsigned( 83 , 8)),
				 16 => std_logic_vector(to_unsigned( 163 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 246 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 625

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 190 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 66 , 8)),
				 5 => std_logic_vector(to_unsigned( 161 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 72 , 8)),
				 9 => std_logic_vector(to_unsigned( 41 , 8)),
				 10 => std_logic_vector(to_unsigned( 206 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 239 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 223 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 54 , 8)),
				 17 => std_logic_vector(to_unsigned( 144 , 8)),
				 18 => std_logic_vector(to_unsigned( 123 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 626

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 73 , 8)),
				 1 => std_logic_vector(to_unsigned( 28 , 8)),
				 2 => std_logic_vector(to_unsigned( 42 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 127 , 8)),
				 5 => std_logic_vector(to_unsigned( 93 , 8)),
				 6 => std_logic_vector(to_unsigned( 98 , 8)),
				 7 => std_logic_vector(to_unsigned( 178 , 8)),
				 8 => std_logic_vector(to_unsigned( 176 , 8)),
				 9 => std_logic_vector(to_unsigned( 178 , 8)),
				 10 => std_logic_vector(to_unsigned( 176 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 102 , 8)),
				 13 => std_logic_vector(to_unsigned( 15 , 8)),
				 14 => std_logic_vector(to_unsigned( 196 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 167 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 139 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 627

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 122 , 8)),
				 1 => std_logic_vector(to_unsigned( 59 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 108 , 8)),
				 4 => std_logic_vector(to_unsigned( 67 , 8)),
				 5 => std_logic_vector(to_unsigned( 171 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 52 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 83 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 169 , 8)),
				 12 => std_logic_vector(to_unsigned( 207 , 8)),
				 13 => std_logic_vector(to_unsigned( 170 , 8)),
				 14 => std_logic_vector(to_unsigned( 191 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 112 , 8)),
				 17 => std_logic_vector(to_unsigned( 88 , 8)),
				 18 => std_logic_vector(to_unsigned( 135 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 628

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 123 , 8)),
				 1 => std_logic_vector(to_unsigned( 76 , 8)),
				 2 => std_logic_vector(to_unsigned( 97 , 8)),
				 3 => std_logic_vector(to_unsigned( 187 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 37 , 8)),
				 6 => std_logic_vector(to_unsigned( 176 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 13 , 8)),
				 9 => std_logic_vector(to_unsigned( 19 , 8)),
				 10 => std_logic_vector(to_unsigned( 91 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 27 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 153 , 8)),
				 18 => std_logic_vector(to_unsigned( 124 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 629

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 50 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 152 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 198 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 198 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 149 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 170 , 8)),
				 14 => std_logic_vector(to_unsigned( 84 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 138 , 8)),
				 18 => std_logic_vector(to_unsigned( 5 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 630

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 77 , 8)),
				 2 => std_logic_vector(to_unsigned( 174 , 8)),
				 3 => std_logic_vector(to_unsigned( 90 , 8)),
				 4 => std_logic_vector(to_unsigned( 247 , 8)),
				 5 => std_logic_vector(to_unsigned( 61 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 152 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 48 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 43 , 8)),
				 13 => std_logic_vector(to_unsigned( 135 , 8)),
				 14 => std_logic_vector(to_unsigned( 175 , 8)),
				 15 => std_logic_vector(to_unsigned( 211 , 8)),
				 16 => std_logic_vector(to_unsigned( 99 , 8)),
				 17 => std_logic_vector(to_unsigned( 153 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 631

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 37 , 8)),
				 1 => std_logic_vector(to_unsigned( 192 , 8)),
				 2 => std_logic_vector(to_unsigned( 200 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 153 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 103 , 8)),
				 8 => std_logic_vector(to_unsigned( 91 , 8)),
				 9 => std_logic_vector(to_unsigned( 169 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 179 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 26 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 30 , 8)),
				 16 => std_logic_vector(to_unsigned( 74 , 8)),
				 17 => std_logic_vector(to_unsigned( 120 , 8)),
				 18 => std_logic_vector(to_unsigned( 158 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 632

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 106 , 8)),
				 3 => std_logic_vector(to_unsigned( 127 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 86 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 118 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 39 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 121 , 8)),
				 14 => std_logic_vector(to_unsigned( 32 , 8)),
				 15 => std_logic_vector(to_unsigned( 130 , 8)),
				 16 => std_logic_vector(to_unsigned( 104 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 118 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 633

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 232 , 8)),
				 1 => std_logic_vector(to_unsigned( 56 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 69 , 8)),
				 5 => std_logic_vector(to_unsigned( 103 , 8)),
				 6 => std_logic_vector(to_unsigned( 38 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 197 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 114 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 634

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 88 , 8)),
				 1 => std_logic_vector(to_unsigned( 224 , 8)),
				 2 => std_logic_vector(to_unsigned( 247 , 8)),
				 3 => std_logic_vector(to_unsigned( 126 , 8)),
				 4 => std_logic_vector(to_unsigned( 201 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 221 , 8)),
				 7 => std_logic_vector(to_unsigned( 220 , 8)),
				 8 => std_logic_vector(to_unsigned( 127 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 5 , 8)),
				 16 => std_logic_vector(to_unsigned( 162 , 8)),
				 17 => std_logic_vector(to_unsigned( 71 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 635

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 187 , 8)),
				 2 => std_logic_vector(to_unsigned( 138 , 8)),
				 3 => std_logic_vector(to_unsigned( 243 , 8)),
				 4 => std_logic_vector(to_unsigned( 82 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 73 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 151 , 8)),
				 12 => std_logic_vector(to_unsigned( 225 , 8)),
				 13 => std_logic_vector(to_unsigned( 131 , 8)),
				 14 => std_logic_vector(to_unsigned( 172 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 86 , 8)),
				 17 => std_logic_vector(to_unsigned( 51 , 8)),
				 18 => std_logic_vector(to_unsigned( 20 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 636

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 113 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 171 , 8)),
				 4 => std_logic_vector(to_unsigned( 252 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 178 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 175 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 226 , 8)),
				 11 => std_logic_vector(to_unsigned( 23 , 8)),
				 12 => std_logic_vector(to_unsigned( 110 , 8)),
				 13 => std_logic_vector(to_unsigned( 115 , 8)),
				 14 => std_logic_vector(to_unsigned( 18 , 8)),
				 15 => std_logic_vector(to_unsigned( 121 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 6 , 8)),
				 18 => std_logic_vector(to_unsigned( 83 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 637

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 249 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 120 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 164 , 8)),
				 5 => std_logic_vector(to_unsigned( 73 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 174 , 8)),
				 9 => std_logic_vector(to_unsigned( 135 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 205 , 8)),
				 12 => std_logic_vector(to_unsigned( 76 , 8)),
				 13 => std_logic_vector(to_unsigned( 139 , 8)),
				 14 => std_logic_vector(to_unsigned( 34 , 8)),
				 15 => std_logic_vector(to_unsigned( 113 , 8)),
				 16 => std_logic_vector(to_unsigned( 249 , 8)),
				 17 => std_logic_vector(to_unsigned( 5 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 638

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 124 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 152 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 150 , 8)),
				 9 => std_logic_vector(to_unsigned( 132 , 8)),
				 10 => std_logic_vector(to_unsigned( 196 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 133 , 8)),
				 15 => std_logic_vector(to_unsigned( 109 , 8)),
				 16 => std_logic_vector(to_unsigned( 62 , 8)),
				 17 => std_logic_vector(to_unsigned( 98 , 8)),
				 18 => std_logic_vector(to_unsigned( 72 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 639

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 5 , 8)),
				 1 => std_logic_vector(to_unsigned( 146 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 42 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 131 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 174 , 8)),
				 12 => std_logic_vector(to_unsigned( 42 , 8)),
				 13 => std_logic_vector(to_unsigned( 212 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 213 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 246 , 8)),
				 18 => std_logic_vector(to_unsigned( 107 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 640

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 136 , 8)),
				 2 => std_logic_vector(to_unsigned( 186 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 54 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 128 , 8)),
				 7 => std_logic_vector(to_unsigned( 181 , 8)),
				 8 => std_logic_vector(to_unsigned( 112 , 8)),
				 9 => std_logic_vector(to_unsigned( 13 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 19 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 189 , 8)),
				 14 => std_logic_vector(to_unsigned( 105 , 8)),
				 15 => std_logic_vector(to_unsigned( 85 , 8)),
				 16 => std_logic_vector(to_unsigned( 103 , 8)),
				 17 => std_logic_vector(to_unsigned( 195 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 641

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 104 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 68 , 8)),
				 4 => std_logic_vector(to_unsigned( 174 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 152 , 8)),
				 7 => std_logic_vector(to_unsigned( 151 , 8)),
				 8 => std_logic_vector(to_unsigned( 91 , 8)),
				 9 => std_logic_vector(to_unsigned( 68 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 150 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 228 , 8)),
				 14 => std_logic_vector(to_unsigned( 252 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 243 , 8)),
				 17 => std_logic_vector(to_unsigned( 191 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 642

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 26 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 78 , 8)),
				 7 => std_logic_vector(to_unsigned( 69 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 115 , 8)),
				 13 => std_logic_vector(to_unsigned( 251 , 8)),
				 14 => std_logic_vector(to_unsigned( 115 , 8)),
				 15 => std_logic_vector(to_unsigned( 69 , 8)),
				 16 => std_logic_vector(to_unsigned( 113 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 162 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 112 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 643

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 90 , 8)),
				 4 => std_logic_vector(to_unsigned( 12 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 89 , 8)),
				 8 => std_logic_vector(to_unsigned( 182 , 8)),
				 9 => std_logic_vector(to_unsigned( 47 , 8)),
				 10 => std_logic_vector(to_unsigned( 248 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 112 , 8)),
				 14 => std_logic_vector(to_unsigned( 28 , 8)),
				 15 => std_logic_vector(to_unsigned( 113 , 8)),
				 16 => std_logic_vector(to_unsigned( 27 , 8)),
				 17 => std_logic_vector(to_unsigned( 133 , 8)),
				 18 => std_logic_vector(to_unsigned( 226 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 644

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 164 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 2 , 8)),
				 3 => std_logic_vector(to_unsigned( 130 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 10 , 8)),
				 6 => std_logic_vector(to_unsigned( 44 , 8)),
				 7 => std_logic_vector(to_unsigned( 50 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 16 , 8)),
				 18 => std_logic_vector(to_unsigned( 117 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 645

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 100 , 8)),
				 1 => std_logic_vector(to_unsigned( 5 , 8)),
				 2 => std_logic_vector(to_unsigned( 103 , 8)),
				 3 => std_logic_vector(to_unsigned( 87 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 104 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 106 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 171 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 146 , 8)),
				 16 => std_logic_vector(to_unsigned( 61 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 79 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 646

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 108 , 8)),
				 1 => std_logic_vector(to_unsigned( 109 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 242 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 220 , 8)),
				 7 => std_logic_vector(to_unsigned( 79 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 84 , 8)),
				 10 => std_logic_vector(to_unsigned( 66 , 8)),
				 11 => std_logic_vector(to_unsigned( 207 , 8)),
				 12 => std_logic_vector(to_unsigned( 214 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 184 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 167 , 8)),
				 17 => std_logic_vector(to_unsigned( 36 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 647

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 5 , 8)),
				 1 => std_logic_vector(to_unsigned( 15 , 8)),
				 2 => std_logic_vector(to_unsigned( 104 , 8)),
				 3 => std_logic_vector(to_unsigned( 116 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 206 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 67 , 8)),
				 9 => std_logic_vector(to_unsigned( 60 , 8)),
				 10 => std_logic_vector(to_unsigned( 187 , 8)),
				 11 => std_logic_vector(to_unsigned( 97 , 8)),
				 12 => std_logic_vector(to_unsigned( 150 , 8)),
				 13 => std_logic_vector(to_unsigned( 199 , 8)),
				 14 => std_logic_vector(to_unsigned( 48 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 46 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 133 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 648

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 98 , 8)),
				 3 => std_logic_vector(to_unsigned( 42 , 8)),
				 4 => std_logic_vector(to_unsigned( 169 , 8)),
				 5 => std_logic_vector(to_unsigned( 120 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 143 , 8)),
				 8 => std_logic_vector(to_unsigned( 68 , 8)),
				 9 => std_logic_vector(to_unsigned( 157 , 8)),
				 10 => std_logic_vector(to_unsigned( 54 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 216 , 8)),
				 13 => std_logic_vector(to_unsigned( 68 , 8)),
				 14 => std_logic_vector(to_unsigned( 94 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 15 , 8)),
				 17 => std_logic_vector(to_unsigned( 208 , 8)),
				 18 => std_logic_vector(to_unsigned( 54 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 649

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 62 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 2 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 238 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 238 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 117 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 66 , 8)),
				 15 => std_logic_vector(to_unsigned( 33 , 8)),
				 16 => std_logic_vector(to_unsigned( 193 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 236 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 650

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 250 , 8)),
				 1 => std_logic_vector(to_unsigned( 162 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 58 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 41 , 8)),
				 6 => std_logic_vector(to_unsigned( 203 , 8)),
				 7 => std_logic_vector(to_unsigned( 95 , 8)),
				 8 => std_logic_vector(to_unsigned( 149 , 8)),
				 9 => std_logic_vector(to_unsigned( 182 , 8)),
				 10 => std_logic_vector(to_unsigned( 21 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 93 , 8)),
				 14 => std_logic_vector(to_unsigned( 163 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 194 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 651

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 26 , 8)),
				 1 => std_logic_vector(to_unsigned( 82 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 38 , 8)),
				 5 => std_logic_vector(to_unsigned( 202 , 8)),
				 6 => std_logic_vector(to_unsigned( 173 , 8)),
				 7 => std_logic_vector(to_unsigned( 67 , 8)),
				 8 => std_logic_vector(to_unsigned( 156 , 8)),
				 9 => std_logic_vector(to_unsigned( 177 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 177 , 8)),
				 12 => std_logic_vector(to_unsigned( 130 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 218 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 652

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 102 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 37 , 8)),
				 5 => std_logic_vector(to_unsigned( 249 , 8)),
				 6 => std_logic_vector(to_unsigned( 103 , 8)),
				 7 => std_logic_vector(to_unsigned( 151 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 191 , 8)),
				 10 => std_logic_vector(to_unsigned( 184 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 120 , 8)),
				 13 => std_logic_vector(to_unsigned( 115 , 8)),
				 14 => std_logic_vector(to_unsigned( 54 , 8)),
				 15 => std_logic_vector(to_unsigned( 107 , 8)),
				 16 => std_logic_vector(to_unsigned( 169 , 8)),
				 17 => std_logic_vector(to_unsigned( 21 , 8)),
				 18 => std_logic_vector(to_unsigned( 140 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 653

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 20 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 132 , 8)),
				 3 => std_logic_vector(to_unsigned( 21 , 8)),
				 4 => std_logic_vector(to_unsigned( 127 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 12 , 8)),
				 7 => std_logic_vector(to_unsigned( 145 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 53 , 8)),
				 10 => std_logic_vector(to_unsigned( 112 , 8)),
				 11 => std_logic_vector(to_unsigned( 143 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 45 , 8)),
				 14 => std_logic_vector(to_unsigned( 56 , 8)),
				 15 => std_logic_vector(to_unsigned( 58 , 8)),
				 16 => std_logic_vector(to_unsigned( 43 , 8)),
				 17 => std_logic_vector(to_unsigned( 75 , 8)),
				 18 => std_logic_vector(to_unsigned( 53 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 654

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 74 , 8)),
				 1 => std_logic_vector(to_unsigned( 174 , 8)),
				 2 => std_logic_vector(to_unsigned( 238 , 8)),
				 3 => std_logic_vector(to_unsigned( 127 , 8)),
				 4 => std_logic_vector(to_unsigned( 124 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 72 , 8)),
				 7 => std_logic_vector(to_unsigned( 226 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 68 , 8)),
				 10 => std_logic_vector(to_unsigned( 195 , 8)),
				 11 => std_logic_vector(to_unsigned( 159 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 218 , 8)),
				 14 => std_logic_vector(to_unsigned( 45 , 8)),
				 15 => std_logic_vector(to_unsigned( 193 , 8)),
				 16 => std_logic_vector(to_unsigned( 158 , 8)),
				 17 => std_logic_vector(to_unsigned( 132 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 655

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 157 , 8)),
				 2 => std_logic_vector(to_unsigned( 92 , 8)),
				 3 => std_logic_vector(to_unsigned( 236 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 57 , 8)),
				 7 => std_logic_vector(to_unsigned( 61 , 8)),
				 8 => std_logic_vector(to_unsigned( 104 , 8)),
				 9 => std_logic_vector(to_unsigned( 23 , 8)),
				 10 => std_logic_vector(to_unsigned( 125 , 8)),
				 11 => std_logic_vector(to_unsigned( 101 , 8)),
				 12 => std_logic_vector(to_unsigned( 246 , 8)),
				 13 => std_logic_vector(to_unsigned( 230 , 8)),
				 14 => std_logic_vector(to_unsigned( 117 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 94 , 8)),
				 17 => std_logic_vector(to_unsigned( 225 , 8)),
				 18 => std_logic_vector(to_unsigned( 222 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 656

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 107 , 8)),
				 1 => std_logic_vector(to_unsigned( 190 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 77 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 29 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 251 , 8)),
				 9 => std_logic_vector(to_unsigned( 25 , 8)),
				 10 => std_logic_vector(to_unsigned( 154 , 8)),
				 11 => std_logic_vector(to_unsigned( 167 , 8)),
				 12 => std_logic_vector(to_unsigned( 12 , 8)),
				 13 => std_logic_vector(to_unsigned( 172 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 142 , 8)),
				 16 => std_logic_vector(to_unsigned( 157 , 8)),
				 17 => std_logic_vector(to_unsigned( 142 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 657

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 127 , 8)),
				 2 => std_logic_vector(to_unsigned( 183 , 8)),
				 3 => std_logic_vector(to_unsigned( 38 , 8)),
				 4 => std_logic_vector(to_unsigned( 123 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 222 , 8)),
				 7 => std_logic_vector(to_unsigned( 168 , 8)),
				 8 => std_logic_vector(to_unsigned( 97 , 8)),
				 9 => std_logic_vector(to_unsigned( 234 , 8)),
				 10 => std_logic_vector(to_unsigned( 31 , 8)),
				 11 => std_logic_vector(to_unsigned( 67 , 8)),
				 12 => std_logic_vector(to_unsigned( 119 , 8)),
				 13 => std_logic_vector(to_unsigned( 72 , 8)),
				 14 => std_logic_vector(to_unsigned( 71 , 8)),
				 15 => std_logic_vector(to_unsigned( 124 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 216 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 658

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 5 , 8)),
				 1 => std_logic_vector(to_unsigned( 210 , 8)),
				 2 => std_logic_vector(to_unsigned( 184 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 102 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 220 , 8)),
				 8 => std_logic_vector(to_unsigned( 110 , 8)),
				 9 => std_logic_vector(to_unsigned( 223 , 8)),
				 10 => std_logic_vector(to_unsigned( 107 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 75 , 8)),
				 13 => std_logic_vector(to_unsigned( 23 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 26 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 216 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 659

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 183 , 8)),
				 1 => std_logic_vector(to_unsigned( 180 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 35 , 8)),
				 4 => std_logic_vector(to_unsigned( 209 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 121 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 21 , 8)),
				 16 => std_logic_vector(to_unsigned( 194 , 8)),
				 17 => std_logic_vector(to_unsigned( 28 , 8)),
				 18 => std_logic_vector(to_unsigned( 10 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 660

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 49 , 8)),
				 1 => std_logic_vector(to_unsigned( 220 , 8)),
				 2 => std_logic_vector(to_unsigned( 71 , 8)),
				 3 => std_logic_vector(to_unsigned( 221 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 119 , 8)),
				 10 => std_logic_vector(to_unsigned( 231 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 109 , 8)),
				 13 => std_logic_vector(to_unsigned( 136 , 8)),
				 14 => std_logic_vector(to_unsigned( 170 , 8)),
				 15 => std_logic_vector(to_unsigned( 145 , 8)),
				 16 => std_logic_vector(to_unsigned( 161 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 177 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 661

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 70 , 8)),
				 1 => std_logic_vector(to_unsigned( 190 , 8)),
				 2 => std_logic_vector(to_unsigned( 163 , 8)),
				 3 => std_logic_vector(to_unsigned( 78 , 8)),
				 4 => std_logic_vector(to_unsigned( 71 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 26 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 141 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 217 , 8)),
				 15 => std_logic_vector(to_unsigned( 60 , 8)),
				 16 => std_logic_vector(to_unsigned( 74 , 8)),
				 17 => std_logic_vector(to_unsigned( 143 , 8)),
				 18 => std_logic_vector(to_unsigned( 245 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 662

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 49 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 61 , 8)),
				 3 => std_logic_vector(to_unsigned( 23 , 8)),
				 4 => std_logic_vector(to_unsigned( 207 , 8)),
				 5 => std_logic_vector(to_unsigned( 80 , 8)),
				 6 => std_logic_vector(to_unsigned( 150 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 130 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 31 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 229 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 12 , 8)),
				 16 => std_logic_vector(to_unsigned( 34 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 663

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 68 , 8)),
				 1 => std_logic_vector(to_unsigned( 141 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 34 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 189 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 190 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 63 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 226 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 68 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 664

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 84 , 8)),
				 2 => std_logic_vector(to_unsigned( 171 , 8)),
				 3 => std_logic_vector(to_unsigned( 193 , 8)),
				 4 => std_logic_vector(to_unsigned( 62 , 8)),
				 5 => std_logic_vector(to_unsigned( 152 , 8)),
				 6 => std_logic_vector(to_unsigned( 217 , 8)),
				 7 => std_logic_vector(to_unsigned( 159 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 136 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 126 , 8)),
				 13 => std_logic_vector(to_unsigned( 67 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 134 , 8)),
				 16 => std_logic_vector(to_unsigned( 113 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 665

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 7 , 8)),
				 1 => std_logic_vector(to_unsigned( 85 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 139 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 74 , 8)),
				 13 => std_logic_vector(to_unsigned( 102 , 8)),
				 14 => std_logic_vector(to_unsigned( 29 , 8)),
				 15 => std_logic_vector(to_unsigned( 17 , 8)),
				 16 => std_logic_vector(to_unsigned( 124 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 123 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 666

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 60 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 218 , 8)),
				 3 => std_logic_vector(to_unsigned( 74 , 8)),
				 4 => std_logic_vector(to_unsigned( 206 , 8)),
				 5 => std_logic_vector(to_unsigned( 169 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 44 , 8)),
				 8 => std_logic_vector(to_unsigned( 205 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 84 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 241 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 667

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 89 , 8)),
				 3 => std_logic_vector(to_unsigned( 147 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 78 , 8)),
				 6 => std_logic_vector(to_unsigned( 131 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 82 , 8)),
				 9 => std_logic_vector(to_unsigned( 58 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 109 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 131 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 215 , 8)),
				 18 => std_logic_vector(to_unsigned( 183 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 668

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 13 , 8)),
				 1 => std_logic_vector(to_unsigned( 195 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 82 , 8)),
				 4 => std_logic_vector(to_unsigned( 117 , 8)),
				 5 => std_logic_vector(to_unsigned( 147 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 166 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 70 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 30 , 8)),
				 12 => std_logic_vector(to_unsigned( 188 , 8)),
				 13 => std_logic_vector(to_unsigned( 231 , 8)),
				 14 => std_logic_vector(to_unsigned( 165 , 8)),
				 15 => std_logic_vector(to_unsigned( 138 , 8)),
				 16 => std_logic_vector(to_unsigned( 97 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 238 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 669

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 38 , 8)),
				 1 => std_logic_vector(to_unsigned( 92 , 8)),
				 2 => std_logic_vector(to_unsigned( 45 , 8)),
				 3 => std_logic_vector(to_unsigned( 243 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 244 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 210 , 8)),
				 10 => std_logic_vector(to_unsigned( 40 , 8)),
				 11 => std_logic_vector(to_unsigned( 218 , 8)),
				 12 => std_logic_vector(to_unsigned( 32 , 8)),
				 13 => std_logic_vector(to_unsigned( 50 , 8)),
				 14 => std_logic_vector(to_unsigned( 169 , 8)),
				 15 => std_logic_vector(to_unsigned( 120 , 8)),
				 16 => std_logic_vector(to_unsigned( 99 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 670

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 47 , 8)),
				 1 => std_logic_vector(to_unsigned( 158 , 8)),
				 2 => std_logic_vector(to_unsigned( 182 , 8)),
				 3 => std_logic_vector(to_unsigned( 41 , 8)),
				 4 => std_logic_vector(to_unsigned( 136 , 8)),
				 5 => std_logic_vector(to_unsigned( 129 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 138 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 137 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 136 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 211 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 111 , 8)),
				 18 => std_logic_vector(to_unsigned( 137 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 671

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 233 , 8)),
				 2 => std_logic_vector(to_unsigned( 43 , 8)),
				 3 => std_logic_vector(to_unsigned( 6 , 8)),
				 4 => std_logic_vector(to_unsigned( 189 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 252 , 8)),
				 7 => std_logic_vector(to_unsigned( 224 , 8)),
				 8 => std_logic_vector(to_unsigned( 219 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 212 , 8)),
				 11 => std_logic_vector(to_unsigned( 40 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 44 , 8)),
				 14 => std_logic_vector(to_unsigned( 103 , 8)),
				 15 => std_logic_vector(to_unsigned( 138 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 245 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 672

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 160 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 76 , 8)),
				 3 => std_logic_vector(to_unsigned( 204 , 8)),
				 4 => std_logic_vector(to_unsigned( 24 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 76 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 174 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 29 , 8)),
				 13 => std_logic_vector(to_unsigned( 99 , 8)),
				 14 => std_logic_vector(to_unsigned( 98 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 176 , 8)),
				 17 => std_logic_vector(to_unsigned( 33 , 8)),
				 18 => std_logic_vector(to_unsigned( 111 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 673

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 56 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 6 , 8)),
				 3 => std_logic_vector(to_unsigned( 200 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 31 , 8)),
				 6 => std_logic_vector(to_unsigned( 20 , 8)),
				 7 => std_logic_vector(to_unsigned( 43 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 11 , 8)),
				 10 => std_logic_vector(to_unsigned( 214 , 8)),
				 11 => std_logic_vector(to_unsigned( 0 , 8)),
				 12 => std_logic_vector(to_unsigned( 44 , 8)),
				 13 => std_logic_vector(to_unsigned( 3 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 13 , 8)),
				 16 => std_logic_vector(to_unsigned( 31 , 8)),
				 17 => std_logic_vector(to_unsigned( 4 , 8)),
				 18 => std_logic_vector(to_unsigned( 10 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 674

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 178 , 8)),
				 2 => std_logic_vector(to_unsigned( 63 , 8)),
				 3 => std_logic_vector(to_unsigned( 184 , 8)),
				 4 => std_logic_vector(to_unsigned( 57 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 94 , 8)),
				 7 => std_logic_vector(to_unsigned( 66 , 8)),
				 8 => std_logic_vector(to_unsigned( 34 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 198 , 8)),
				 11 => std_logic_vector(to_unsigned( 80 , 8)),
				 12 => std_logic_vector(to_unsigned( 159 , 8)),
				 13 => std_logic_vector(to_unsigned( 178 , 8)),
				 14 => std_logic_vector(to_unsigned( 61 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 675

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 249 , 8)),
				 1 => std_logic_vector(to_unsigned( 66 , 8)),
				 2 => std_logic_vector(to_unsigned( 160 , 8)),
				 3 => std_logic_vector(to_unsigned( 219 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 7 , 8)),
				 7 => std_logic_vector(to_unsigned( 224 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 225 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 225 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 676

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 75 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 142 , 8)),
				 4 => std_logic_vector(to_unsigned( 136 , 8)),
				 5 => std_logic_vector(to_unsigned( 189 , 8)),
				 6 => std_logic_vector(to_unsigned( 89 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 91 , 8)),
				 11 => std_logic_vector(to_unsigned( 237 , 8)),
				 12 => std_logic_vector(to_unsigned( 58 , 8)),
				 13 => std_logic_vector(to_unsigned( 26 , 8)),
				 14 => std_logic_vector(to_unsigned( 76 , 8)),
				 15 => std_logic_vector(to_unsigned( 85 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 158 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 677

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 13 , 8)),
				 2 => std_logic_vector(to_unsigned( 79 , 8)),
				 3 => std_logic_vector(to_unsigned( 45 , 8)),
				 4 => std_logic_vector(to_unsigned( 47 , 8)),
				 5 => std_logic_vector(to_unsigned( 79 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 87 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 174 , 8)),
				 10 => std_logic_vector(to_unsigned( 250 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 172 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 172 , 8)),
				 15 => std_logic_vector(to_unsigned( 126 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 21 , 8)),
				 18 => std_logic_vector(to_unsigned( 238 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 678

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 22 , 8)),
				 2 => std_logic_vector(to_unsigned( 126 , 8)),
				 3 => std_logic_vector(to_unsigned( 33 , 8)),
				 4 => std_logic_vector(to_unsigned( 115 , 8)),
				 5 => std_logic_vector(to_unsigned( 98 , 8)),
				 6 => std_logic_vector(to_unsigned( 50 , 8)),
				 7 => std_logic_vector(to_unsigned( 107 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 99 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 243 , 8)),
				 13 => std_logic_vector(to_unsigned( 124 , 8)),
				 14 => std_logic_vector(to_unsigned( 186 , 8)),
				 15 => std_logic_vector(to_unsigned( 163 , 8)),
				 16 => std_logic_vector(to_unsigned( 147 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 679

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 58 , 8)),
				 1 => std_logic_vector(to_unsigned( 44 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 43 , 8)),
				 5 => std_logic_vector(to_unsigned( 59 , 8)),
				 6 => std_logic_vector(to_unsigned( 38 , 8)),
				 7 => std_logic_vector(to_unsigned( 135 , 8)),
				 8 => std_logic_vector(to_unsigned( 141 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 84 , 8)),
				 11 => std_logic_vector(to_unsigned( 219 , 8)),
				 12 => std_logic_vector(to_unsigned( 57 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 242 , 8)),
				 15 => std_logic_vector(to_unsigned( 226 , 8)),
				 16 => std_logic_vector(to_unsigned( 107 , 8)),
				 17 => std_logic_vector(to_unsigned( 60 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 680

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 70 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 115 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 41 , 8)),
				 8 => std_logic_vector(to_unsigned( 69 , 8)),
				 9 => std_logic_vector(to_unsigned( 158 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 66 , 8)),
				 12 => std_logic_vector(to_unsigned( 139 , 8)),
				 13 => std_logic_vector(to_unsigned( 213 , 8)),
				 14 => std_logic_vector(to_unsigned( 120 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 79 , 8)),
				 17 => std_logic_vector(to_unsigned( 77 , 8)),
				 18 => std_logic_vector(to_unsigned( 240 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 681

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 105 , 8)),
				 1 => std_logic_vector(to_unsigned( 28 , 8)),
				 2 => std_logic_vector(to_unsigned( 180 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 178 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 118 , 8)),
				 9 => std_logic_vector(to_unsigned( 215 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 92 , 8)),
				 13 => std_logic_vector(to_unsigned( 43 , 8)),
				 14 => std_logic_vector(to_unsigned( 221 , 8)),
				 15 => std_logic_vector(to_unsigned( 117 , 8)),
				 16 => std_logic_vector(to_unsigned( 142 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 235 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 682

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 108 , 8)),
				 3 => std_logic_vector(to_unsigned( 53 , 8)),
				 4 => std_logic_vector(to_unsigned( 69 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 234 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 73 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 71 , 8)),
				 13 => std_logic_vector(to_unsigned( 129 , 8)),
				 14 => std_logic_vector(to_unsigned( 177 , 8)),
				 15 => std_logic_vector(to_unsigned( 162 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 138 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 683

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 200 , 8)),
				 1 => std_logic_vector(to_unsigned( 173 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 93 , 8)),
				 4 => std_logic_vector(to_unsigned( 193 , 8)),
				 5 => std_logic_vector(to_unsigned( 130 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 0 , 8)),
				 9 => std_logic_vector(to_unsigned( 85 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 198 , 8)),
				 12 => std_logic_vector(to_unsigned( 59 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 73 , 8)),
				 16 => std_logic_vector(to_unsigned( 249 , 8)),
				 17 => std_logic_vector(to_unsigned( 204 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 684

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 43 , 8)),
				 1 => std_logic_vector(to_unsigned( 73 , 8)),
				 2 => std_logic_vector(to_unsigned( 238 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 78 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 70 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 186 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 215 , 8)),
				 13 => std_logic_vector(to_unsigned( 144 , 8)),
				 14 => std_logic_vector(to_unsigned( 208 , 8)),
				 15 => std_logic_vector(to_unsigned( 165 , 8)),
				 16 => std_logic_vector(to_unsigned( 187 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 190 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 685

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 143 , 8)),
				 1 => std_logic_vector(to_unsigned( 138 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 62 , 8)),
				 6 => std_logic_vector(to_unsigned( 219 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 250 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 95 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 95 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 189 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 99 , 8)),
				 17 => std_logic_vector(to_unsigned( 186 , 8)),
				 18 => std_logic_vector(to_unsigned( 112 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 686

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 44 , 8)),
				 7 => std_logic_vector(to_unsigned( 215 , 8)),
				 8 => std_logic_vector(to_unsigned( 182 , 8)),
				 9 => std_logic_vector(to_unsigned( 137 , 8)),
				 10 => std_logic_vector(to_unsigned( 126 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 63 , 8)),
				 15 => std_logic_vector(to_unsigned( 200 , 8)),
				 16 => std_logic_vector(to_unsigned( 63 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 687

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 144 , 8)),
				 1 => std_logic_vector(to_unsigned( 229 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 1 , 8)),
				 5 => std_logic_vector(to_unsigned( 213 , 8)),
				 6 => std_logic_vector(to_unsigned( 78 , 8)),
				 7 => std_logic_vector(to_unsigned( 217 , 8)),
				 8 => std_logic_vector(to_unsigned( 74 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 45 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 143 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 222 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 688

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 219 , 8)),
				 1 => std_logic_vector(to_unsigned( 118 , 8)),
				 2 => std_logic_vector(to_unsigned( 71 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 57 , 8)),
				 5 => std_logic_vector(to_unsigned( 174 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 149 , 8)),
				 8 => std_logic_vector(to_unsigned( 240 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 151 , 8)),
				 11 => std_logic_vector(to_unsigned( 166 , 8)),
				 12 => std_logic_vector(to_unsigned( 146 , 8)),
				 13 => std_logic_vector(to_unsigned( 190 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 39 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 242 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 689

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 197 , 8)),
				 1 => std_logic_vector(to_unsigned( 22 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 38 , 8)),
				 4 => std_logic_vector(to_unsigned( 153 , 8)),
				 5 => std_logic_vector(to_unsigned( 65 , 8)),
				 6 => std_logic_vector(to_unsigned( 126 , 8)),
				 7 => std_logic_vector(to_unsigned( 126 , 8)),
				 8 => std_logic_vector(to_unsigned( 65 , 8)),
				 9 => std_logic_vector(to_unsigned( 161 , 8)),
				 10 => std_logic_vector(to_unsigned( 181 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 146 , 8)),
				 14 => std_logic_vector(to_unsigned( 104 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 74 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 182 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 690

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 89 , 8)),
				 1 => std_logic_vector(to_unsigned( 161 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 77 , 8)),
				 6 => std_logic_vector(to_unsigned( 50 , 8)),
				 7 => std_logic_vector(to_unsigned( 139 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 154 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 185 , 8)),
				 12 => std_logic_vector(to_unsigned( 20 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 204 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 109 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 691

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 219 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 34 , 8)),
				 5 => std_logic_vector(to_unsigned( 216 , 8)),
				 6 => std_logic_vector(to_unsigned( 32 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 22 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 21 , 8)),
				 14 => std_logic_vector(to_unsigned( 236 , 8)),
				 15 => std_logic_vector(to_unsigned( 50 , 8)),
				 16 => std_logic_vector(to_unsigned( 231 , 8)),
				 17 => std_logic_vector(to_unsigned( 0 , 8)),
				 18 => std_logic_vector(to_unsigned( 69 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 692

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 20 , 8)),
				 2 => std_logic_vector(to_unsigned( 48 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 100 , 8)),
				 7 => std_logic_vector(to_unsigned( 196 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 109 , 8)),
				 10 => std_logic_vector(to_unsigned( 131 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 20 , 8)),
				 13 => std_logic_vector(to_unsigned( 38 , 8)),
				 14 => std_logic_vector(to_unsigned( 251 , 8)),
				 15 => std_logic_vector(to_unsigned( 201 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 70 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 693

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 157 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 213 , 8)),
				 3 => std_logic_vector(to_unsigned( 207 , 8)),
				 4 => std_logic_vector(to_unsigned( 212 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 188 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 169 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 115 , 8)),
				 11 => std_logic_vector(to_unsigned( 44 , 8)),
				 12 => std_logic_vector(to_unsigned( 81 , 8)),
				 13 => std_logic_vector(to_unsigned( 155 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 80 , 8)),
				 17 => std_logic_vector(to_unsigned( 54 , 8)),
				 18 => std_logic_vector(to_unsigned( 247 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 694

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 114 , 8)),
				 1 => std_logic_vector(to_unsigned( 180 , 8)),
				 2 => std_logic_vector(to_unsigned( 86 , 8)),
				 3 => std_logic_vector(to_unsigned( 24 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 198 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 56 , 8)),
				 10 => std_logic_vector(to_unsigned( 94 , 8)),
				 11 => std_logic_vector(to_unsigned( 80 , 8)),
				 12 => std_logic_vector(to_unsigned( 70 , 8)),
				 13 => std_logic_vector(to_unsigned( 128 , 8)),
				 14 => std_logic_vector(to_unsigned( 22 , 8)),
				 15 => std_logic_vector(to_unsigned( 134 , 8)),
				 16 => std_logic_vector(to_unsigned( 16 , 8)),
				 17 => std_logic_vector(to_unsigned( 214 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 112 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 695

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 164 , 8)),
				 3 => std_logic_vector(to_unsigned( 196 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 149 , 8)),
				 8 => std_logic_vector(to_unsigned( 159 , 8)),
				 9 => std_logic_vector(to_unsigned( 197 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 178 , 8)),
				 13 => std_logic_vector(to_unsigned( 135 , 8)),
				 14 => std_logic_vector(to_unsigned( 76 , 8)),
				 15 => std_logic_vector(to_unsigned( 156 , 8)),
				 16 => std_logic_vector(to_unsigned( 55 , 8)),
				 17 => std_logic_vector(to_unsigned( 84 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 696

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 143 , 8)),
				 1 => std_logic_vector(to_unsigned( 234 , 8)),
				 2 => std_logic_vector(to_unsigned( 160 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 159 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 154 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 150 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 149 , 8)),
				 11 => std_logic_vector(to_unsigned( 250 , 8)),
				 12 => std_logic_vector(to_unsigned( 144 , 8)),
				 13 => std_logic_vector(to_unsigned( 181 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 245 , 8)),
				 17 => std_logic_vector(to_unsigned( 129 , 8)),
				 18 => std_logic_vector(to_unsigned( 24 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 15 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 697

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 185 , 8)),
				 2 => std_logic_vector(to_unsigned( 224 , 8)),
				 3 => std_logic_vector(to_unsigned( 194 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 80 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 210 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 1 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 153 , 8)),
				 12 => std_logic_vector(to_unsigned( 201 , 8)),
				 13 => std_logic_vector(to_unsigned( 71 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 69 , 8)),
				 16 => std_logic_vector(to_unsigned( 64 , 8)),
				 17 => std_logic_vector(to_unsigned( 131 , 8)),
				 18 => std_logic_vector(to_unsigned( 112 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 698

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 144 , 8)),
				 2 => std_logic_vector(to_unsigned( 34 , 8)),
				 3 => std_logic_vector(to_unsigned( 133 , 8)),
				 4 => std_logic_vector(to_unsigned( 196 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 120 , 8)),
				 7 => std_logic_vector(to_unsigned( 18 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 122 , 8)),
				 10 => std_logic_vector(to_unsigned( 72 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 137 , 8)),
				 14 => std_logic_vector(to_unsigned( 230 , 8)),
				 15 => std_logic_vector(to_unsigned( 138 , 8)),
				 16 => std_logic_vector(to_unsigned( 229 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 3 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 699

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 55 , 8)),
				 1 => std_logic_vector(to_unsigned( 202 , 8)),
				 2 => std_logic_vector(to_unsigned( 225 , 8)),
				 3 => std_logic_vector(to_unsigned( 63 , 8)),
				 4 => std_logic_vector(to_unsigned( 167 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 80 , 8)),
				 7 => std_logic_vector(to_unsigned( 220 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 21 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 61 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 95 , 8)),
				 14 => std_logic_vector(to_unsigned( 135 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 194 , 8)),
				 17 => std_logic_vector(to_unsigned( 188 , 8)),
				 18 => std_logic_vector(to_unsigned( 110 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 700

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 111 , 8)),
				 2 => std_logic_vector(to_unsigned( 78 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 160 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 158 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 140 , 8)),
				 9 => std_logic_vector(to_unsigned( 1 , 8)),
				 10 => std_logic_vector(to_unsigned( 240 , 8)),
				 11 => std_logic_vector(to_unsigned( 36 , 8)),
				 12 => std_logic_vector(to_unsigned( 228 , 8)),
				 13 => std_logic_vector(to_unsigned( 147 , 8)),
				 14 => std_logic_vector(to_unsigned( 117 , 8)),
				 15 => std_logic_vector(to_unsigned( 83 , 8)),
				 16 => std_logic_vector(to_unsigned( 106 , 8)),
				 17 => std_logic_vector(to_unsigned( 215 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 701

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 34 , 8)),
				 1 => std_logic_vector(to_unsigned( 222 , 8)),
				 2 => std_logic_vector(to_unsigned( 205 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 175 , 8)),
				 5 => std_logic_vector(to_unsigned( 160 , 8)),
				 6 => std_logic_vector(to_unsigned( 217 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 172 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 76 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 23 , 8)),
				 15 => std_logic_vector(to_unsigned( 104 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 97 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 702

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 96 , 8)),
				 1 => std_logic_vector(to_unsigned( 15 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 82 , 8)),
				 4 => std_logic_vector(to_unsigned( 131 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 90 , 8)),
				 7 => std_logic_vector(to_unsigned( 208 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 136 , 8)),
				 10 => std_logic_vector(to_unsigned( 90 , 8)),
				 11 => std_logic_vector(to_unsigned( 171 , 8)),
				 12 => std_logic_vector(to_unsigned( 55 , 8)),
				 13 => std_logic_vector(to_unsigned( 218 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 222 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 19 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 703

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 183 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 217 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 157 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 65 , 8)),
				 11 => std_logic_vector(to_unsigned( 4 , 8)),
				 12 => std_logic_vector(to_unsigned( 255 , 8)),
				 13 => std_logic_vector(to_unsigned( 49 , 8)),
				 14 => std_logic_vector(to_unsigned( 210 , 8)),
				 15 => std_logic_vector(to_unsigned( 109 , 8)),
				 16 => std_logic_vector(to_unsigned( 189 , 8)),
				 17 => std_logic_vector(to_unsigned( 129 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 704

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 236 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 100 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 160 , 8)),
				 11 => std_logic_vector(to_unsigned( 68 , 8)),
				 12 => std_logic_vector(to_unsigned( 17 , 8)),
				 13 => std_logic_vector(to_unsigned( 53 , 8)),
				 14 => std_logic_vector(to_unsigned( 130 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 235 , 8)),
				 18 => std_logic_vector(to_unsigned( 32 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 705

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 205 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 73 , 8)),
				 4 => std_logic_vector(to_unsigned( 97 , 8)),
				 5 => std_logic_vector(to_unsigned( 157 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 197 , 8)),
				 9 => std_logic_vector(to_unsigned( 184 , 8)),
				 10 => std_logic_vector(to_unsigned( 77 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 25 , 8)),
				 14 => std_logic_vector(to_unsigned( 65 , 8)),
				 15 => std_logic_vector(to_unsigned( 88 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 192 , 8)),
				 18 => std_logic_vector(to_unsigned( 99 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 706

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 138 , 8)),
				 1 => std_logic_vector(to_unsigned( 234 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 16 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 47 , 8)),
				 6 => std_logic_vector(to_unsigned( 184 , 8)),
				 7 => std_logic_vector(to_unsigned( 214 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 232 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 123 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 105 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 104 , 8)),
				 17 => std_logic_vector(to_unsigned( 76 , 8)),
				 18 => std_logic_vector(to_unsigned( 45 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 707

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 51 , 8)),
				 1 => std_logic_vector(to_unsigned( 48 , 8)),
				 2 => std_logic_vector(to_unsigned( 52 , 8)),
				 3 => std_logic_vector(to_unsigned( 51 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 92 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 171 , 8)),
				 10 => std_logic_vector(to_unsigned( 216 , 8)),
				 11 => std_logic_vector(to_unsigned( 92 , 8)),
				 12 => std_logic_vector(to_unsigned( 221 , 8)),
				 13 => std_logic_vector(to_unsigned( 19 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 87 , 8)),
				 16 => std_logic_vector(to_unsigned( 135 , 8)),
				 17 => std_logic_vector(to_unsigned( 20 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 708

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 193 , 8)),
				 2 => std_logic_vector(to_unsigned( 218 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 182 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 169 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 165 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 154 , 8)),
				 12 => std_logic_vector(to_unsigned( 166 , 8)),
				 13 => std_logic_vector(to_unsigned( 43 , 8)),
				 14 => std_logic_vector(to_unsigned( 219 , 8)),
				 15 => std_logic_vector(to_unsigned( 93 , 8)),
				 16 => std_logic_vector(to_unsigned( 127 , 8)),
				 17 => std_logic_vector(to_unsigned( 154 , 8)),
				 18 => std_logic_vector(to_unsigned( 85 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 709

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 248 , 8)),
				 1 => std_logic_vector(to_unsigned( 234 , 8)),
				 2 => std_logic_vector(to_unsigned( 90 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 80 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 15 , 8)),
				 7 => std_logic_vector(to_unsigned( 147 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 149 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 149 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 150 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 118 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 710

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 1 , 8)),
				 1 => std_logic_vector(to_unsigned( 17 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 25 , 8)),
				 4 => std_logic_vector(to_unsigned( 207 , 8)),
				 5 => std_logic_vector(to_unsigned( 170 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 178 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 74 , 8)),
				 10 => std_logic_vector(to_unsigned( 163 , 8)),
				 11 => std_logic_vector(to_unsigned( 116 , 8)),
				 12 => std_logic_vector(to_unsigned( 121 , 8)),
				 13 => std_logic_vector(to_unsigned( 120 , 8)),
				 14 => std_logic_vector(to_unsigned( 106 , 8)),
				 15 => std_logic_vector(to_unsigned( 162 , 8)),
				 16 => std_logic_vector(to_unsigned( 64 , 8)),
				 17 => std_logic_vector(to_unsigned( 115 , 8)),
				 18 => std_logic_vector(to_unsigned( 100 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 711

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 145 , 8)),
				 6 => std_logic_vector(to_unsigned( 150 , 8)),
				 7 => std_logic_vector(to_unsigned( 121 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 121 , 8)),
				 10 => std_logic_vector(to_unsigned( 17 , 8)),
				 11 => std_logic_vector(to_unsigned( 122 , 8)),
				 12 => std_logic_vector(to_unsigned( 16 , 8)),
				 13 => std_logic_vector(to_unsigned( 83 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 223 , 8)),
				 16 => std_logic_vector(to_unsigned( 93 , 8)),
				 17 => std_logic_vector(to_unsigned( 16 , 8)),
				 18 => std_logic_vector(to_unsigned( 222 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 712

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 67 , 8)),
				 3 => std_logic_vector(to_unsigned( 46 , 8)),
				 4 => std_logic_vector(to_unsigned( 48 , 8)),
				 5 => std_logic_vector(to_unsigned( 175 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 6 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 52 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 175 , 8)),
				 12 => std_logic_vector(to_unsigned( 223 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 247 , 8)),
				 15 => std_logic_vector(to_unsigned( 171 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 242 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 713

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 2 , 8)),
				 2 => std_logic_vector(to_unsigned( 3 , 8)),
				 3 => std_logic_vector(to_unsigned( 210 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 169 , 8)),
				 7 => std_logic_vector(to_unsigned( 116 , 8)),
				 8 => std_logic_vector(to_unsigned( 206 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 60 , 8)),
				 12 => std_logic_vector(to_unsigned( 21 , 8)),
				 13 => std_logic_vector(to_unsigned( 70 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 146 , 8)),
				 16 => std_logic_vector(to_unsigned( 93 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 714

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 89 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 44 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 7 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 138 , 8)),
				 10 => std_logic_vector(to_unsigned( 58 , 8)),
				 11 => std_logic_vector(to_unsigned( 144 , 8)),
				 12 => std_logic_vector(to_unsigned( 52 , 8)),
				 13 => std_logic_vector(to_unsigned( 191 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 221 , 8)),
				 18 => std_logic_vector(to_unsigned( 18 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 715

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 145 , 8)),
				 2 => std_logic_vector(to_unsigned( 202 , 8)),
				 3 => std_logic_vector(to_unsigned( 185 , 8)),
				 4 => std_logic_vector(to_unsigned( 18 , 8)),
				 5 => std_logic_vector(to_unsigned( 193 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 8 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 43 , 8)),
				 14 => std_logic_vector(to_unsigned( 246 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 131 , 8)),
				 17 => std_logic_vector(to_unsigned( 125 , 8)),
				 18 => std_logic_vector(to_unsigned( 210 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 716

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 139 , 8)),
				 2 => std_logic_vector(to_unsigned( 36 , 8)),
				 3 => std_logic_vector(to_unsigned( 171 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 132 , 8)),
				 6 => std_logic_vector(to_unsigned( 89 , 8)),
				 7 => std_logic_vector(to_unsigned( 215 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 219 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 15 , 8)),
				 16 => std_logic_vector(to_unsigned( 240 , 8)),
				 17 => std_logic_vector(to_unsigned( 196 , 8)),
				 18 => std_logic_vector(to_unsigned( 252 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 717

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 244 , 8)),
				 1 => std_logic_vector(to_unsigned( 150 , 8)),
				 2 => std_logic_vector(to_unsigned( 248 , 8)),
				 3 => std_logic_vector(to_unsigned( 81 , 8)),
				 4 => std_logic_vector(to_unsigned( 134 , 8)),
				 5 => std_logic_vector(to_unsigned( 60 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 91 , 8)),
				 8 => std_logic_vector(to_unsigned( 29 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 200 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 43 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 137 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 718

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 87 , 8)),
				 1 => std_logic_vector(to_unsigned( 142 , 8)),
				 2 => std_logic_vector(to_unsigned( 43 , 8)),
				 3 => std_logic_vector(to_unsigned( 112 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 9 , 8)),
				 6 => std_logic_vector(to_unsigned( 63 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 221 , 8)),
				 9 => std_logic_vector(to_unsigned( 150 , 8)),
				 10 => std_logic_vector(to_unsigned( 198 , 8)),
				 11 => std_logic_vector(to_unsigned( 177 , 8)),
				 12 => std_logic_vector(to_unsigned( 93 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 56 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 20 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 206 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 719

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 141 , 8)),
				 6 => std_logic_vector(to_unsigned( 247 , 8)),
				 7 => std_logic_vector(to_unsigned( 158 , 8)),
				 8 => std_logic_vector(to_unsigned( 230 , 8)),
				 9 => std_logic_vector(to_unsigned( 162 , 8)),
				 10 => std_logic_vector(to_unsigned( 226 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 117 , 8)),
				 15 => std_logic_vector(to_unsigned( 136 , 8)),
				 16 => std_logic_vector(to_unsigned( 38 , 8)),
				 17 => std_logic_vector(to_unsigned( 6 , 8)),
				 18 => std_logic_vector(to_unsigned( 173 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 720

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 97 , 8)),
				 2 => std_logic_vector(to_unsigned( 7 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 106 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 236 , 8)),
				 7 => std_logic_vector(to_unsigned( 125 , 8)),
				 8 => std_logic_vector(to_unsigned( 208 , 8)),
				 9 => std_logic_vector(to_unsigned( 203 , 8)),
				 10 => std_logic_vector(to_unsigned( 202 , 8)),
				 11 => std_logic_vector(to_unsigned( 202 , 8)),
				 12 => std_logic_vector(to_unsigned( 82 , 8)),
				 13 => std_logic_vector(to_unsigned( 39 , 8)),
				 14 => std_logic_vector(to_unsigned( 85 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 53 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 101 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 721

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 123 , 8)),
				 1 => std_logic_vector(to_unsigned( 116 , 8)),
				 2 => std_logic_vector(to_unsigned( 86 , 8)),
				 3 => std_logic_vector(to_unsigned( 156 , 8)),
				 4 => std_logic_vector(to_unsigned( 46 , 8)),
				 5 => std_logic_vector(to_unsigned( 199 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 199 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 19 , 8)),
				 10 => std_logic_vector(to_unsigned( 187 , 8)),
				 11 => std_logic_vector(to_unsigned( 146 , 8)),
				 12 => std_logic_vector(to_unsigned( 73 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 244 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 235 , 8)),
				 17 => std_logic_vector(to_unsigned( 19 , 8)),
				 18 => std_logic_vector(to_unsigned( 124 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 722

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 168 , 8)),
				 2 => std_logic_vector(to_unsigned( 89 , 8)),
				 3 => std_logic_vector(to_unsigned( 8 , 8)),
				 4 => std_logic_vector(to_unsigned( 206 , 8)),
				 5 => std_logic_vector(to_unsigned( 121 , 8)),
				 6 => std_logic_vector(to_unsigned( 173 , 8)),
				 7 => std_logic_vector(to_unsigned( 160 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 134 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 93 , 8)),
				 13 => std_logic_vector(to_unsigned( 133 , 8)),
				 14 => std_logic_vector(to_unsigned( 213 , 8)),
				 15 => std_logic_vector(to_unsigned( 89 , 8)),
				 16 => std_logic_vector(to_unsigned( 129 , 8)),
				 17 => std_logic_vector(to_unsigned( 233 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 723

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 113 , 8)),
				 1 => std_logic_vector(to_unsigned( 65 , 8)),
				 2 => std_logic_vector(to_unsigned( 192 , 8)),
				 3 => std_logic_vector(to_unsigned( 19 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 37 , 8)),
				 6 => std_logic_vector(to_unsigned( 74 , 8)),
				 7 => std_logic_vector(to_unsigned( 78 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 90 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 75 , 8)),
				 13 => std_logic_vector(to_unsigned( 130 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 139 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 2 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 724

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 13 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 206 , 8)),
				 3 => std_logic_vector(to_unsigned( 174 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 181 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 73 , 8)),
				 8 => std_logic_vector(to_unsigned( 63 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 36 , 8)),
				 14 => std_logic_vector(to_unsigned( 42 , 8)),
				 15 => std_logic_vector(to_unsigned( 48 , 8)),
				 16 => std_logic_vector(to_unsigned( 30 , 8)),
				 17 => std_logic_vector(to_unsigned( 74 , 8)),
				 18 => std_logic_vector(to_unsigned( 50 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 725

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 90 , 8)),
				 1 => std_logic_vector(to_unsigned( 203 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 135 , 8)),
				 4 => std_logic_vector(to_unsigned( 44 , 8)),
				 5 => std_logic_vector(to_unsigned( 144 , 8)),
				 6 => std_logic_vector(to_unsigned( 107 , 8)),
				 7 => std_logic_vector(to_unsigned( 131 , 8)),
				 8 => std_logic_vector(to_unsigned( 104 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 183 , 8)),
				 11 => std_logic_vector(to_unsigned( 196 , 8)),
				 12 => std_logic_vector(to_unsigned( 155 , 8)),
				 13 => std_logic_vector(to_unsigned( 83 , 8)),
				 14 => std_logic_vector(to_unsigned( 41 , 8)),
				 15 => std_logic_vector(to_unsigned( 164 , 8)),
				 16 => std_logic_vector(to_unsigned( 116 , 8)),
				 17 => std_logic_vector(to_unsigned( 144 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 726

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 36 , 8)),
				 2 => std_logic_vector(to_unsigned( 214 , 8)),
				 3 => std_logic_vector(to_unsigned( 21 , 8)),
				 4 => std_logic_vector(to_unsigned( 158 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 9 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 111 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 184 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 148 , 8)),
				 15 => std_logic_vector(to_unsigned( 209 , 8)),
				 16 => std_logic_vector(to_unsigned( 115 , 8)),
				 17 => std_logic_vector(to_unsigned( 99 , 8)),
				 18 => std_logic_vector(to_unsigned( 152 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 727

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 139 , 8)),
				 1 => std_logic_vector(to_unsigned( 32 , 8)),
				 2 => std_logic_vector(to_unsigned( 13 , 8)),
				 3 => std_logic_vector(to_unsigned( 210 , 8)),
				 4 => std_logic_vector(to_unsigned( 186 , 8)),
				 5 => std_logic_vector(to_unsigned( 173 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 247 , 8)),
				 9 => std_logic_vector(to_unsigned( 17 , 8)),
				 10 => std_logic_vector(to_unsigned( 120 , 8)),
				 11 => std_logic_vector(to_unsigned( 99 , 8)),
				 12 => std_logic_vector(to_unsigned( 38 , 8)),
				 13 => std_logic_vector(to_unsigned( 121 , 8)),
				 14 => std_logic_vector(to_unsigned( 16 , 8)),
				 15 => std_logic_vector(to_unsigned( 148 , 8)),
				 16 => std_logic_vector(to_unsigned( 163 , 8)),
				 17 => std_logic_vector(to_unsigned( 155 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 728

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 76 , 8)),
				 1 => std_logic_vector(to_unsigned( 114 , 8)),
				 2 => std_logic_vector(to_unsigned( 244 , 8)),
				 3 => std_logic_vector(to_unsigned( 227 , 8)),
				 4 => std_logic_vector(to_unsigned( 131 , 8)),
				 5 => std_logic_vector(to_unsigned( 160 , 8)),
				 6 => std_logic_vector(to_unsigned( 203 , 8)),
				 7 => std_logic_vector(to_unsigned( 226 , 8)),
				 8 => std_logic_vector(to_unsigned( 137 , 8)),
				 9 => std_logic_vector(to_unsigned( 242 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 246 , 8)),
				 12 => std_logic_vector(to_unsigned( 117 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 109 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 107 , 8)),
				 18 => std_logic_vector(to_unsigned( 165 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 729

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 64 , 8)),
				 2 => std_logic_vector(to_unsigned( 70 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 200 , 8)),
				 7 => std_logic_vector(to_unsigned( 238 , 8)),
				 8 => std_logic_vector(to_unsigned( 181 , 8)),
				 9 => std_logic_vector(to_unsigned( 40 , 8)),
				 10 => std_logic_vector(to_unsigned( 86 , 8)),
				 11 => std_logic_vector(to_unsigned( 82 , 8)),
				 12 => std_logic_vector(to_unsigned( 44 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 42 , 8)),
				 15 => std_logic_vector(to_unsigned( 26 , 8)),
				 16 => std_logic_vector(to_unsigned( 184 , 8)),
				 17 => std_logic_vector(to_unsigned( 147 , 8)),
				 18 => std_logic_vector(to_unsigned( 86 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 730

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 224 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 121 , 8)),
				 3 => std_logic_vector(to_unsigned( 189 , 8)),
				 4 => std_logic_vector(to_unsigned( 201 , 8)),
				 5 => std_logic_vector(to_unsigned( 120 , 8)),
				 6 => std_logic_vector(to_unsigned( 182 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 90 , 8)),
				 9 => std_logic_vector(to_unsigned( 188 , 8)),
				 10 => std_logic_vector(to_unsigned( 73 , 8)),
				 11 => std_logic_vector(to_unsigned( 155 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 127 , 8)),
				 14 => std_logic_vector(to_unsigned( 188 , 8)),
				 15 => std_logic_vector(to_unsigned( 91 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 223 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 731

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 234 , 8)),
				 2 => std_logic_vector(to_unsigned( 226 , 8)),
				 3 => std_logic_vector(to_unsigned( 112 , 8)),
				 4 => std_logic_vector(to_unsigned( 45 , 8)),
				 5 => std_logic_vector(to_unsigned( 40 , 8)),
				 6 => std_logic_vector(to_unsigned( 54 , 8)),
				 7 => std_logic_vector(to_unsigned( 46 , 8)),
				 8 => std_logic_vector(to_unsigned( 48 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 62 , 8)),
				 11 => std_logic_vector(to_unsigned( 101 , 8)),
				 12 => std_logic_vector(to_unsigned( 111 , 8)),
				 13 => std_logic_vector(to_unsigned( 182 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 186 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 57 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 732

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 214 , 8)),
				 2 => std_logic_vector(to_unsigned( 4 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 114 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 13 , 8)),
				 8 => std_logic_vector(to_unsigned( 245 , 8)),
				 9 => std_logic_vector(to_unsigned( 242 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 241 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 229 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 210 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 103 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 733

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 0 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 87 , 8)),
				 3 => std_logic_vector(to_unsigned( 229 , 8)),
				 4 => std_logic_vector(to_unsigned( 139 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 115 , 8)),
				 9 => std_logic_vector(to_unsigned( 84 , 8)),
				 10 => std_logic_vector(to_unsigned( 245 , 8)),
				 11 => std_logic_vector(to_unsigned( 81 , 8)),
				 12 => std_logic_vector(to_unsigned( 249 , 8)),
				 13 => std_logic_vector(to_unsigned( 247 , 8)),
				 14 => std_logic_vector(to_unsigned( 83 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 75 , 8)),
				 17 => std_logic_vector(to_unsigned( 2 , 8)),
				 18 => std_logic_vector(to_unsigned( 209 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 0 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 734

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 146 , 8)),
				 2 => std_logic_vector(to_unsigned( 171 , 8)),
				 3 => std_logic_vector(to_unsigned( 233 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 152 , 8)),
				 6 => std_logic_vector(to_unsigned( 111 , 8)),
				 7 => std_logic_vector(to_unsigned( 186 , 8)),
				 8 => std_logic_vector(to_unsigned( 211 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 153 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 145 , 8)),
				 15 => std_logic_vector(to_unsigned( 215 , 8)),
				 16 => std_logic_vector(to_unsigned( 205 , 8)),
				 17 => std_logic_vector(to_unsigned( 102 , 8)),
				 18 => std_logic_vector(to_unsigned( 250 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 9 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 735

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 163 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 151 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 41 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 35 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 23 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 45 , 8)),
				 12 => std_logic_vector(to_unsigned( 71 , 8)),
				 13 => std_logic_vector(to_unsigned( 72 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 84 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 87 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 160 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 736

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 44 , 8)),
				 1 => std_logic_vector(to_unsigned( 116 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 181 , 8)),
				 4 => std_logic_vector(to_unsigned( 132 , 8)),
				 5 => std_logic_vector(to_unsigned( 227 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 229 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 212 , 8)),
				 10 => std_logic_vector(to_unsigned( 145 , 8)),
				 11 => std_logic_vector(to_unsigned( 140 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 64 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 193 , 8)),
				 16 => std_logic_vector(to_unsigned( 246 , 8)),
				 17 => std_logic_vector(to_unsigned( 56 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 737

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 76 , 8)),
				 1 => std_logic_vector(to_unsigned( 107 , 8)),
				 2 => std_logic_vector(to_unsigned( 216 , 8)),
				 3 => std_logic_vector(to_unsigned( 109 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 109 , 8)),
				 6 => std_logic_vector(to_unsigned( 17 , 8)),
				 7 => std_logic_vector(to_unsigned( 20 , 8)),
				 8 => std_logic_vector(to_unsigned( 218 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 8 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 85 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 81 , 8)),
				 15 => std_logic_vector(to_unsigned( 42 , 8)),
				 16 => std_logic_vector(to_unsigned( 159 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 133 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 738

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 184 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 44 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 76 , 8)),
				 8 => std_logic_vector(to_unsigned( 151 , 8)),
				 9 => std_logic_vector(to_unsigned( 140 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 26 , 8)),
				 13 => std_logic_vector(to_unsigned( 215 , 8)),
				 14 => std_logic_vector(to_unsigned( 12 , 8)),
				 15 => std_logic_vector(to_unsigned( 218 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 250 , 8)),
				 18 => std_logic_vector(to_unsigned( 124 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 176 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 739

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 182 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 155 , 8)),
				 4 => std_logic_vector(to_unsigned( 198 , 8)),
				 5 => std_logic_vector(to_unsigned( 158 , 8)),
				 6 => std_logic_vector(to_unsigned( 195 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 76 , 8)),
				 9 => std_logic_vector(to_unsigned( 210 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 211 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 88 , 8)),
				 16 => std_logic_vector(to_unsigned( 144 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 70 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 740

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 53 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 181 , 8)),
				 4 => std_logic_vector(to_unsigned( 203 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 132 , 8)),
				 7 => std_logic_vector(to_unsigned( 152 , 8)),
				 8 => std_logic_vector(to_unsigned( 190 , 8)),
				 9 => std_logic_vector(to_unsigned( 61 , 8)),
				 10 => std_logic_vector(to_unsigned( 161 , 8)),
				 11 => std_logic_vector(to_unsigned( 69 , 8)),
				 12 => std_logic_vector(to_unsigned( 234 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 146 , 8)),
				 15 => std_logic_vector(to_unsigned( 199 , 8)),
				 16 => std_logic_vector(to_unsigned( 140 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 741

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 68 , 8)),
				 2 => std_logic_vector(to_unsigned( 159 , 8)),
				 3 => std_logic_vector(to_unsigned( 216 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 230 , 8)),
				 6 => std_logic_vector(to_unsigned( 241 , 8)),
				 7 => std_logic_vector(to_unsigned( 63 , 8)),
				 8 => std_logic_vector(to_unsigned( 126 , 8)),
				 9 => std_logic_vector(to_unsigned( 161 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 181 , 8)),
				 12 => std_logic_vector(to_unsigned( 219 , 8)),
				 13 => std_logic_vector(to_unsigned( 35 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 147 , 8)),
				 16 => std_logic_vector(to_unsigned( 222 , 8)),
				 17 => std_logic_vector(to_unsigned( 55 , 8)),
				 18 => std_logic_vector(to_unsigned( 63 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 742

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 147 , 8)),
				 1 => std_logic_vector(to_unsigned( 226 , 8)),
				 2 => std_logic_vector(to_unsigned( 227 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 209 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 198 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 198 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 198 , 8)),
				 11 => std_logic_vector(to_unsigned( 225 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 229 , 8)),
				 14 => std_logic_vector(to_unsigned( 103 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 94 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 89 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 743

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 10 , 8)),
				 1 => std_logic_vector(to_unsigned( 159 , 8)),
				 2 => std_logic_vector(to_unsigned( 102 , 8)),
				 3 => std_logic_vector(to_unsigned( 161 , 8)),
				 4 => std_logic_vector(to_unsigned( 100 , 8)),
				 5 => std_logic_vector(to_unsigned( 215 , 8)),
				 6 => std_logic_vector(to_unsigned( 152 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 161 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 13 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 118 , 8)),
				 13 => std_logic_vector(to_unsigned( 246 , 8)),
				 14 => std_logic_vector(to_unsigned( 186 , 8)),
				 15 => std_logic_vector(to_unsigned( 140 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 70 , 8)),
				 18 => std_logic_vector(to_unsigned( 209 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 744

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 98 , 8)),
				 1 => std_logic_vector(to_unsigned( 34 , 8)),
				 2 => std_logic_vector(to_unsigned( 27 , 8)),
				 3 => std_logic_vector(to_unsigned( 35 , 8)),
				 4 => std_logic_vector(to_unsigned( 26 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 57 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 137 , 8)),
				 10 => std_logic_vector(to_unsigned( 242 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 0 , 8)),
				 13 => std_logic_vector(to_unsigned( 207 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 230 , 8)),
				 16 => std_logic_vector(to_unsigned( 113 , 8)),
				 17 => std_logic_vector(to_unsigned( 88 , 8)),
				 18 => std_logic_vector(to_unsigned( 152 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 745

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 122 , 8)),
				 1 => std_logic_vector(to_unsigned( 151 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 150 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 190 , 8)),
				 6 => std_logic_vector(to_unsigned( 162 , 8)),
				 7 => std_logic_vector(to_unsigned( 145 , 8)),
				 8 => std_logic_vector(to_unsigned( 14 , 8)),
				 9 => std_logic_vector(to_unsigned( 146 , 8)),
				 10 => std_logic_vector(to_unsigned( 13 , 8)),
				 11 => std_logic_vector(to_unsigned( 108 , 8)),
				 12 => std_logic_vector(to_unsigned( 109 , 8)),
				 13 => std_logic_vector(to_unsigned( 202 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 211 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 143 , 8)),
				 18 => std_logic_vector(to_unsigned( 129 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 746

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 1 , 8)),
				 3 => std_logic_vector(to_unsigned( 242 , 8)),
				 4 => std_logic_vector(to_unsigned( 228 , 8)),
				 5 => std_logic_vector(to_unsigned( 233 , 8)),
				 6 => std_logic_vector(to_unsigned( 101 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 39 , 8)),
				 13 => std_logic_vector(to_unsigned( 125 , 8)),
				 14 => std_logic_vector(to_unsigned( 20 , 8)),
				 15 => std_logic_vector(to_unsigned( 126 , 8)),
				 16 => std_logic_vector(to_unsigned( 19 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 211 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 747

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 126 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 59 , 8)),
				 3 => std_logic_vector(to_unsigned( 217 , 8)),
				 4 => std_logic_vector(to_unsigned( 150 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 117 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 117 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 112 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 112 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 112 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 112 , 8)),
				 17 => std_logic_vector(to_unsigned( 232 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 748

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 55 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 176 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 166 , 8)),
				 5 => std_logic_vector(to_unsigned( 246 , 8)),
				 6 => std_logic_vector(to_unsigned( 166 , 8)),
				 7 => std_logic_vector(to_unsigned( 52 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 77 , 8)),
				 10 => std_logic_vector(to_unsigned( 137 , 8)),
				 11 => std_logic_vector(to_unsigned( 31 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 36 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 125 , 8)),
				 16 => std_logic_vector(to_unsigned( 23 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 192 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 749

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 178 , 8)),
				 1 => std_logic_vector(to_unsigned( 48 , 8)),
				 2 => std_logic_vector(to_unsigned( 67 , 8)),
				 3 => std_logic_vector(to_unsigned( 93 , 8)),
				 4 => std_logic_vector(to_unsigned( 22 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 20 , 8)),
				 7 => std_logic_vector(to_unsigned( 100 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 222 , 8)),
				 16 => std_logic_vector(to_unsigned( 220 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 225 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 750

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 78 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 32 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 207 , 8)),
				 5 => std_logic_vector(to_unsigned( 118 , 8)),
				 6 => std_logic_vector(to_unsigned( 184 , 8)),
				 7 => std_logic_vector(to_unsigned( 144 , 8)),
				 8 => std_logic_vector(to_unsigned( 158 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 191 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 187 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 187 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 47 , 8)),
				 17 => std_logic_vector(to_unsigned( 208 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 751

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 18 , 8)),
				 1 => std_logic_vector(to_unsigned( 115 , 8)),
				 2 => std_logic_vector(to_unsigned( 121 , 8)),
				 3 => std_logic_vector(to_unsigned( 1 , 8)),
				 4 => std_logic_vector(to_unsigned( 74 , 8)),
				 5 => std_logic_vector(to_unsigned( 22 , 8)),
				 6 => std_logic_vector(to_unsigned( 53 , 8)),
				 7 => std_logic_vector(to_unsigned( 36 , 8)),
				 8 => std_logic_vector(to_unsigned( 120 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 90 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 50 , 8)),
				 13 => std_logic_vector(to_unsigned( 146 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 176 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 752

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 79 , 8)),
				 1 => std_logic_vector(to_unsigned( 184 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 199 , 8)),
				 4 => std_logic_vector(to_unsigned( 48 , 8)),
				 5 => std_logic_vector(to_unsigned( 65 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 68 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 161 , 8)),
				 11 => std_logic_vector(to_unsigned( 250 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 51 , 8)),
				 14 => std_logic_vector(to_unsigned( 168 , 8)),
				 15 => std_logic_vector(to_unsigned( 169 , 8)),
				 16 => std_logic_vector(to_unsigned( 50 , 8)),
				 17 => std_logic_vector(to_unsigned( 112 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 753

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 169 , 8)),
				 2 => std_logic_vector(to_unsigned( 46 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 146 , 8)),
				 5 => std_logic_vector(to_unsigned( 217 , 8)),
				 6 => std_logic_vector(to_unsigned( 50 , 8)),
				 7 => std_logic_vector(to_unsigned( 209 , 8)),
				 8 => std_logic_vector(to_unsigned( 209 , 8)),
				 9 => std_logic_vector(to_unsigned( 12 , 8)),
				 10 => std_logic_vector(to_unsigned( 63 , 8)),
				 11 => std_logic_vector(to_unsigned( 30 , 8)),
				 12 => std_logic_vector(to_unsigned( 45 , 8)),
				 13 => std_logic_vector(to_unsigned( 75 , 8)),
				 14 => std_logic_vector(to_unsigned( 216 , 8)),
				 15 => std_logic_vector(to_unsigned( 82 , 8)),
				 16 => std_logic_vector(to_unsigned( 209 , 8)),
				 17 => std_logic_vector(to_unsigned( 223 , 8)),
				 18 => std_logic_vector(to_unsigned( 155 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 754

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 246 , 8)),
				 1 => std_logic_vector(to_unsigned( 167 , 8)),
				 2 => std_logic_vector(to_unsigned( 211 , 8)),
				 3 => std_logic_vector(to_unsigned( 241 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 46 , 8)),
				 6 => std_logic_vector(to_unsigned( 162 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 128 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 180 , 8)),
				 14 => std_logic_vector(to_unsigned( 148 , 8)),
				 15 => std_logic_vector(to_unsigned( 207 , 8)),
				 16 => std_logic_vector(to_unsigned( 121 , 8)),
				 17 => std_logic_vector(to_unsigned( 16 , 8)),
				 18 => std_logic_vector(to_unsigned( 201 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 755

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 48 , 8)),
				 1 => std_logic_vector(to_unsigned( 15 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 182 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 168 , 8)),
				 6 => std_logic_vector(to_unsigned( 190 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 123 , 8)),
				 9 => std_logic_vector(to_unsigned( 100 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 100 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 100 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 16 , 8)),
				 16 => std_logic_vector(to_unsigned( 18 , 8)),
				 17 => std_logic_vector(to_unsigned( 255 , 8)),
				 18 => std_logic_vector(to_unsigned( 153 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 756

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 130 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 140 , 8)),
				 5 => std_logic_vector(to_unsigned( 198 , 8)),
				 6 => std_logic_vector(to_unsigned( 63 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 183 , 8)),
				 10 => std_logic_vector(to_unsigned( 62 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 44 , 8)),
				 14 => std_logic_vector(to_unsigned( 199 , 8)),
				 15 => std_logic_vector(to_unsigned( 220 , 8)),
				 16 => std_logic_vector(to_unsigned( 23 , 8)),
				 17 => std_logic_vector(to_unsigned( 10 , 8)),
				 18 => std_logic_vector(to_unsigned( 123 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 757

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 96 , 8)),
				 1 => std_logic_vector(to_unsigned( 119 , 8)),
				 2 => std_logic_vector(to_unsigned( 169 , 8)),
				 3 => std_logic_vector(to_unsigned( 164 , 8)),
				 4 => std_logic_vector(to_unsigned( 124 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 33 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 187 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 172 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 172 , 8)),
				 15 => std_logic_vector(to_unsigned( 206 , 8)),
				 16 => std_logic_vector(to_unsigned( 60 , 8)),
				 17 => std_logic_vector(to_unsigned( 143 , 8)),
				 18 => std_logic_vector(to_unsigned( 222 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 758

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 71 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 31 , 8)),
				 7 => std_logic_vector(to_unsigned( 56 , 8)),
				 8 => std_logic_vector(to_unsigned( 108 , 8)),
				 9 => std_logic_vector(to_unsigned( 140 , 8)),
				 10 => std_logic_vector(to_unsigned( 24 , 8)),
				 11 => std_logic_vector(to_unsigned( 161 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 1 , 8)),
				 14 => std_logic_vector(to_unsigned( 81 , 8)),
				 15 => std_logic_vector(to_unsigned( 15 , 8)),
				 16 => std_logic_vector(to_unsigned( 166 , 8)),
				 17 => std_logic_vector(to_unsigned( 225 , 8)),
				 18 => std_logic_vector(to_unsigned( 204 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 759

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 221 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 191 , 8)),
				 3 => std_logic_vector(to_unsigned( 163 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 68 , 8)),
				 7 => std_logic_vector(to_unsigned( 44 , 8)),
				 8 => std_logic_vector(to_unsigned( 68 , 8)),
				 9 => std_logic_vector(to_unsigned( 55 , 8)),
				 10 => std_logic_vector(to_unsigned( 57 , 8)),
				 11 => std_logic_vector(to_unsigned( 210 , 8)),
				 12 => std_logic_vector(to_unsigned( 44 , 8)),
				 13 => std_logic_vector(to_unsigned( 32 , 8)),
				 14 => std_logic_vector(to_unsigned( 139 , 8)),
				 15 => std_logic_vector(to_unsigned( 54 , 8)),
				 16 => std_logic_vector(to_unsigned( 166 , 8)),
				 17 => std_logic_vector(to_unsigned( 231 , 8)),
				 18 => std_logic_vector(to_unsigned( 71 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 760

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 167 , 8)),
				 1 => std_logic_vector(to_unsigned( 126 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 224 , 8)),
				 4 => std_logic_vector(to_unsigned( 135 , 8)),
				 5 => std_logic_vector(to_unsigned( 1 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 140 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 221 , 8)),
				 10 => std_logic_vector(to_unsigned( 189 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 174 , 8)),
				 13 => std_logic_vector(to_unsigned( 156 , 8)),
				 14 => std_logic_vector(to_unsigned( 191 , 8)),
				 15 => std_logic_vector(to_unsigned( 182 , 8)),
				 16 => std_logic_vector(to_unsigned( 147 , 8)),
				 17 => std_logic_vector(to_unsigned( 213 , 8)),
				 18 => std_logic_vector(to_unsigned( 178 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 761

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 116 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 223 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 8 , 8)),
				 5 => std_logic_vector(to_unsigned( 202 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 194 , 8)),
				 8 => std_logic_vector(to_unsigned( 220 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 195 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 55 , 8)),
				 16 => std_logic_vector(to_unsigned( 255 , 8)),
				 17 => std_logic_vector(to_unsigned( 54 , 8)),
				 18 => std_logic_vector(to_unsigned( 143 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 762

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 45 , 8)),
				 1 => std_logic_vector(to_unsigned( 197 , 8)),
				 2 => std_logic_vector(to_unsigned( 68 , 8)),
				 3 => std_logic_vector(to_unsigned( 216 , 8)),
				 4 => std_logic_vector(to_unsigned( 52 , 8)),
				 5 => std_logic_vector(to_unsigned( 123 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 182 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 108 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 26 , 8)),
				 14 => std_logic_vector(to_unsigned( 36 , 8)),
				 15 => std_logic_vector(to_unsigned( 45 , 8)),
				 16 => std_logic_vector(to_unsigned( 17 , 8)),
				 17 => std_logic_vector(to_unsigned( 112 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 763

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 101 , 8)),
				 1 => std_logic_vector(to_unsigned( 220 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 98 , 8)),
				 6 => std_logic_vector(to_unsigned( 151 , 8)),
				 7 => std_logic_vector(to_unsigned( 170 , 8)),
				 8 => std_logic_vector(to_unsigned( 249 , 8)),
				 9 => std_logic_vector(to_unsigned( 44 , 8)),
				 10 => std_logic_vector(to_unsigned( 131 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 49 , 8)),
				 14 => std_logic_vector(to_unsigned( 230 , 8)),
				 15 => std_logic_vector(to_unsigned( 146 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 83 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 764

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 49 , 8)),
				 1 => std_logic_vector(to_unsigned( 227 , 8)),
				 2 => std_logic_vector(to_unsigned( 239 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 213 , 8)),
				 9 => std_logic_vector(to_unsigned( 2 , 8)),
				 10 => std_logic_vector(to_unsigned( 130 , 8)),
				 11 => std_logic_vector(to_unsigned( 117 , 8)),
				 12 => std_logic_vector(to_unsigned( 86 , 8)),
				 13 => std_logic_vector(to_unsigned( 114 , 8)),
				 14 => std_logic_vector(to_unsigned( 138 , 8)),
				 15 => std_logic_vector(to_unsigned( 219 , 8)),
				 16 => std_logic_vector(to_unsigned( 33 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 4 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 765

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 42 , 8)),
				 2 => std_logic_vector(to_unsigned( 221 , 8)),
				 3 => std_logic_vector(to_unsigned( 227 , 8)),
				 4 => std_logic_vector(to_unsigned( 36 , 8)),
				 5 => std_logic_vector(to_unsigned( 69 , 8)),
				 6 => std_logic_vector(to_unsigned( 224 , 8)),
				 7 => std_logic_vector(to_unsigned( 42 , 8)),
				 8 => std_logic_vector(to_unsigned( 227 , 8)),
				 9 => std_logic_vector(to_unsigned( 174 , 8)),
				 10 => std_logic_vector(to_unsigned( 246 , 8)),
				 11 => std_logic_vector(to_unsigned( 182 , 8)),
				 12 => std_logic_vector(to_unsigned( 238 , 8)),
				 13 => std_logic_vector(to_unsigned( 35 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 160 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 47 , 8)),
				 18 => std_logic_vector(to_unsigned( 201 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 766

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 186 , 8)),
				 3 => std_logic_vector(to_unsigned( 168 , 8)),
				 4 => std_logic_vector(to_unsigned( 170 , 8)),
				 5 => std_logic_vector(to_unsigned( 209 , 8)),
				 6 => std_logic_vector(to_unsigned( 129 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 48 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 46 , 8)),
				 11 => std_logic_vector(to_unsigned( 9 , 8)),
				 12 => std_logic_vector(to_unsigned( 27 , 8)),
				 13 => std_logic_vector(to_unsigned( 13 , 8)),
				 14 => std_logic_vector(to_unsigned( 23 , 8)),
				 15 => std_logic_vector(to_unsigned( 66 , 8)),
				 16 => std_logic_vector(to_unsigned( 83 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 173 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 767

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 103 , 8)),
				 2 => std_logic_vector(to_unsigned( 130 , 8)),
				 3 => std_logic_vector(to_unsigned( 160 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 89 , 8)),
				 6 => std_logic_vector(to_unsigned( 135 , 8)),
				 7 => std_logic_vector(to_unsigned( 124 , 8)),
				 8 => std_logic_vector(to_unsigned( 217 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 101 , 8)),
				 11 => std_logic_vector(to_unsigned( 253 , 8)),
				 12 => std_logic_vector(to_unsigned( 236 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 235 , 8)),
				 15 => std_logic_vector(to_unsigned( 149 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 168 , 8)),
				 18 => std_logic_vector(to_unsigned( 55 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 768

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 94 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 87 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 134 , 8)),
				 5 => std_logic_vector(to_unsigned( 190 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 197 , 8)),
				 8 => std_logic_vector(to_unsigned( 7 , 8)),
				 9 => std_logic_vector(to_unsigned( 203 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 104 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 769

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 41 , 8)),
				 1 => std_logic_vector(to_unsigned( 251 , 8)),
				 2 => std_logic_vector(to_unsigned( 67 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 63 , 8)),
				 5 => std_logic_vector(to_unsigned( 62 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 10 , 8)),
				 8 => std_logic_vector(to_unsigned( 179 , 8)),
				 9 => std_logic_vector(to_unsigned( 17 , 8)),
				 10 => std_logic_vector(to_unsigned( 172 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 113 , 8)),
				 13 => std_logic_vector(to_unsigned( 94 , 8)),
				 14 => std_logic_vector(to_unsigned( 95 , 8)),
				 15 => std_logic_vector(to_unsigned( 179 , 8)),
				 16 => std_logic_vector(to_unsigned( 49 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 56 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 770

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 83 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 168 , 8)),
				 4 => std_logic_vector(to_unsigned( 11 , 8)),
				 5 => std_logic_vector(to_unsigned( 208 , 8)),
				 6 => std_logic_vector(to_unsigned( 174 , 8)),
				 7 => std_logic_vector(to_unsigned( 221 , 8)),
				 8 => std_logic_vector(to_unsigned( 161 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 214 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 198 , 8)),
				 15 => std_logic_vector(to_unsigned( 200 , 8)),
				 16 => std_logic_vector(to_unsigned( 219 , 8)),
				 17 => std_logic_vector(to_unsigned( 213 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 771

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 37 , 8)),
				 1 => std_logic_vector(to_unsigned( 70 , 8)),
				 2 => std_logic_vector(to_unsigned( 82 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 69 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 120 , 8)),
				 9 => std_logic_vector(to_unsigned( 220 , 8)),
				 10 => std_logic_vector(to_unsigned( 141 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 86 , 8)),
				 14 => std_logic_vector(to_unsigned( 194 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 77 , 8)),
				 17 => std_logic_vector(to_unsigned( 62 , 8)),
				 18 => std_logic_vector(to_unsigned( 70 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 772

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 211 , 8)),
				 1 => std_logic_vector(to_unsigned( 55 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 113 , 8)),
				 4 => std_logic_vector(to_unsigned( 154 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 141 , 8)),
				 7 => std_logic_vector(to_unsigned( 108 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 45 , 8)),
				 11 => std_logic_vector(to_unsigned( 11 , 8)),
				 12 => std_logic_vector(to_unsigned( 253 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 137 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 136 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 254 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 773

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 11 , 8)),
				 1 => std_logic_vector(to_unsigned( 220 , 8)),
				 2 => std_logic_vector(to_unsigned( 67 , 8)),
				 3 => std_logic_vector(to_unsigned( 242 , 8)),
				 4 => std_logic_vector(to_unsigned( 183 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 168 , 8)),
				 8 => std_logic_vector(to_unsigned( 102 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 77 , 8)),
				 11 => std_logic_vector(to_unsigned( 64 , 8)),
				 12 => std_logic_vector(to_unsigned( 242 , 8)),
				 13 => std_logic_vector(to_unsigned( 221 , 8)),
				 14 => std_logic_vector(to_unsigned( 241 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 224 , 8)),
				 17 => std_logic_vector(to_unsigned( 177 , 8)),
				 18 => std_logic_vector(to_unsigned( 83 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 774

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 95 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 235 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 246 , 8)),
				 6 => std_logic_vector(to_unsigned( 145 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 145 , 8)),
				 9 => std_logic_vector(to_unsigned( 208 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 45 , 8)),
				 12 => std_logic_vector(to_unsigned( 41 , 8)),
				 13 => std_logic_vector(to_unsigned( 107 , 8)),
				 14 => std_logic_vector(to_unsigned( 147 , 8)),
				 15 => std_logic_vector(to_unsigned( 196 , 8)),
				 16 => std_logic_vector(to_unsigned( 58 , 8)),
				 17 => std_logic_vector(to_unsigned( 22 , 8)),
				 18 => std_logic_vector(to_unsigned( 59 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 775

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 233 , 8)),
				 1 => std_logic_vector(to_unsigned( 11 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 17 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 19 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 60 , 8)),
				 8 => std_logic_vector(to_unsigned( 145 , 8)),
				 9 => std_logic_vector(to_unsigned( 202 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 198 , 8)),
				 12 => std_logic_vector(to_unsigned( 233 , 8)),
				 13 => std_logic_vector(to_unsigned( 109 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 135 , 8)),
				 16 => std_logic_vector(to_unsigned( 74 , 8)),
				 17 => std_logic_vector(to_unsigned( 144 , 8)),
				 18 => std_logic_vector(to_unsigned( 116 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 192 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 776

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 171 , 8)),
				 1 => std_logic_vector(to_unsigned( 141 , 8)),
				 2 => std_logic_vector(to_unsigned( 190 , 8)),
				 3 => std_logic_vector(to_unsigned( 155 , 8)),
				 4 => std_logic_vector(to_unsigned( 73 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 211 , 8)),
				 7 => std_logic_vector(to_unsigned( 196 , 8)),
				 8 => std_logic_vector(to_unsigned( 194 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 191 , 8)),
				 11 => std_logic_vector(to_unsigned( 6 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 6 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 6 , 8)),
				 17 => std_logic_vector(to_unsigned( 192 , 8)),
				 18 => std_logic_vector(to_unsigned( 141 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 777

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 55 , 8)),
				 1 => std_logic_vector(to_unsigned( 202 , 8)),
				 2 => std_logic_vector(to_unsigned( 153 , 8)),
				 3 => std_logic_vector(to_unsigned( 125 , 8)),
				 4 => std_logic_vector(to_unsigned( 241 , 8)),
				 5 => std_logic_vector(to_unsigned( 234 , 8)),
				 6 => std_logic_vector(to_unsigned( 132 , 8)),
				 7 => std_logic_vector(to_unsigned( 129 , 8)),
				 8 => std_logic_vector(to_unsigned( 231 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 125 , 8)),
				 12 => std_logic_vector(to_unsigned( 173 , 8)),
				 13 => std_logic_vector(to_unsigned( 148 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 241 , 8)),
				 16 => std_logic_vector(to_unsigned( 207 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 160 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 778

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 135 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 238 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 228 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 199 , 8)),
				 7 => std_logic_vector(to_unsigned( 8 , 8)),
				 8 => std_logic_vector(to_unsigned( 199 , 8)),
				 9 => std_logic_vector(to_unsigned( 129 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 242 , 8)),
				 13 => std_logic_vector(to_unsigned( 86 , 8)),
				 14 => std_logic_vector(to_unsigned( 241 , 8)),
				 15 => std_logic_vector(to_unsigned( 98 , 8)),
				 16 => std_logic_vector(to_unsigned( 229 , 8)),
				 17 => std_logic_vector(to_unsigned( 71 , 8)),
				 18 => std_logic_vector(to_unsigned( 4 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 779

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 209 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 93 , 8)),
				 3 => std_logic_vector(to_unsigned( 82 , 8)),
				 4 => std_logic_vector(to_unsigned( 191 , 8)),
				 5 => std_logic_vector(to_unsigned( 118 , 8)),
				 6 => std_logic_vector(to_unsigned( 155 , 8)),
				 7 => std_logic_vector(to_unsigned( 63 , 8)),
				 8 => std_logic_vector(to_unsigned( 127 , 8)),
				 9 => std_logic_vector(to_unsigned( 237 , 8)),
				 10 => std_logic_vector(to_unsigned( 120 , 8)),
				 11 => std_logic_vector(to_unsigned( 68 , 8)),
				 12 => std_logic_vector(to_unsigned( 38 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 80 , 8)),
				 15 => std_logic_vector(to_unsigned( 208 , 8)),
				 16 => std_logic_vector(to_unsigned( 164 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 100 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 780

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 247 , 8)),
				 1 => std_logic_vector(to_unsigned( 128 , 8)),
				 2 => std_logic_vector(to_unsigned( 121 , 8)),
				 3 => std_logic_vector(to_unsigned( 207 , 8)),
				 4 => std_logic_vector(to_unsigned( 42 , 8)),
				 5 => std_logic_vector(to_unsigned( 223 , 8)),
				 6 => std_logic_vector(to_unsigned( 26 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 225 , 8)),
				 9 => std_logic_vector(to_unsigned( 72 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 125 , 8)),
				 12 => std_logic_vector(to_unsigned( 121 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 115 , 8)),
				 15 => std_logic_vector(to_unsigned( 118 , 8)),
				 16 => std_logic_vector(to_unsigned( 139 , 8)),
				 17 => std_logic_vector(to_unsigned( 168 , 8)),
				 18 => std_logic_vector(to_unsigned( 195 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 781

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 205 , 8)),
				 1 => std_logic_vector(to_unsigned( 79 , 8)),
				 2 => std_logic_vector(to_unsigned( 203 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 120 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 177 , 8)),
				 8 => std_logic_vector(to_unsigned( 26 , 8)),
				 9 => std_logic_vector(to_unsigned( 108 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 172 , 8)),
				 12 => std_logic_vector(to_unsigned( 38 , 8)),
				 13 => std_logic_vector(to_unsigned( 34 , 8)),
				 14 => std_logic_vector(to_unsigned( 107 , 8)),
				 15 => std_logic_vector(to_unsigned( 29 , 8)),
				 16 => std_logic_vector(to_unsigned( 137 , 8)),
				 17 => std_logic_vector(to_unsigned( 29 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 782

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 221 , 8)),
				 2 => std_logic_vector(to_unsigned( 147 , 8)),
				 3 => std_logic_vector(to_unsigned( 8 , 8)),
				 4 => std_logic_vector(to_unsigned( 133 , 8)),
				 5 => std_logic_vector(to_unsigned( 30 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 148 , 8)),
				 8 => std_logic_vector(to_unsigned( 228 , 8)),
				 9 => std_logic_vector(to_unsigned( 177 , 8)),
				 10 => std_logic_vector(to_unsigned( 199 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 175 , 8)),
				 13 => std_logic_vector(to_unsigned( 247 , 8)),
				 14 => std_logic_vector(to_unsigned( 129 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 123 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 16 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 783

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 15 , 8)),
				 1 => std_logic_vector(to_unsigned( 233 , 8)),
				 2 => std_logic_vector(to_unsigned( 170 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 159 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 148 , 8)),
				 7 => std_logic_vector(to_unsigned( 39 , 8)),
				 8 => std_logic_vector(to_unsigned( 188 , 8)),
				 9 => std_logic_vector(to_unsigned( 178 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 42 , 8)),
				 14 => std_logic_vector(to_unsigned( 62 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 784

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 197 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 147 , 8)),
				 3 => std_logic_vector(to_unsigned( 152 , 8)),
				 4 => std_logic_vector(to_unsigned( 46 , 8)),
				 5 => std_logic_vector(to_unsigned( 180 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 186 , 8)),
				 8 => std_logic_vector(to_unsigned( 12 , 8)),
				 9 => std_logic_vector(to_unsigned( 189 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 194 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 163 , 8)),
				 15 => std_logic_vector(to_unsigned( 197 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 136 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 785

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 127 , 8)),
				 1 => std_logic_vector(to_unsigned( 19 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 33 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 36 , 8)),
				 6 => std_logic_vector(to_unsigned( 180 , 8)),
				 7 => std_logic_vector(to_unsigned( 208 , 8)),
				 8 => std_logic_vector(to_unsigned( 194 , 8)),
				 9 => std_logic_vector(to_unsigned( 234 , 8)),
				 10 => std_logic_vector(to_unsigned( 168 , 8)),
				 11 => std_logic_vector(to_unsigned( 72 , 8)),
				 12 => std_logic_vector(to_unsigned( 212 , 8)),
				 13 => std_logic_vector(to_unsigned( 244 , 8)),
				 14 => std_logic_vector(to_unsigned( 40 , 8)),
				 15 => std_logic_vector(to_unsigned( 248 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 180 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 786

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 239 , 8)),
				 1 => std_logic_vector(to_unsigned( 7 , 8)),
				 2 => std_logic_vector(to_unsigned( 179 , 8)),
				 3 => std_logic_vector(to_unsigned( 107 , 8)),
				 4 => std_logic_vector(to_unsigned( 79 , 8)),
				 5 => std_logic_vector(to_unsigned( 34 , 8)),
				 6 => std_logic_vector(to_unsigned( 150 , 8)),
				 7 => std_logic_vector(to_unsigned( 117 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 181 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 35 , 8)),
				 14 => std_logic_vector(to_unsigned( 239 , 8)),
				 15 => std_logic_vector(to_unsigned( 238 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 209 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 787

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 190 , 8)),
				 2 => std_logic_vector(to_unsigned( 42 , 8)),
				 3 => std_logic_vector(to_unsigned( 190 , 8)),
				 4 => std_logic_vector(to_unsigned( 160 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 148 , 8)),
				 10 => std_logic_vector(to_unsigned( 186 , 8)),
				 11 => std_logic_vector(to_unsigned( 163 , 8)),
				 12 => std_logic_vector(to_unsigned( 171 , 8)),
				 13 => std_logic_vector(to_unsigned( 64 , 8)),
				 14 => std_logic_vector(to_unsigned( 63 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 27 , 8)),
				 17 => std_logic_vector(to_unsigned( 36 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 788

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 176 , 8)),
				 1 => std_logic_vector(to_unsigned( 41 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 56 , 8)),
				 4 => std_logic_vector(to_unsigned( 54 , 8)),
				 5 => std_logic_vector(to_unsigned( 97 , 8)),
				 6 => std_logic_vector(to_unsigned( 65 , 8)),
				 7 => std_logic_vector(to_unsigned( 172 , 8)),
				 8 => std_logic_vector(to_unsigned( 198 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 125 , 8)),
				 11 => std_logic_vector(to_unsigned( 235 , 8)),
				 12 => std_logic_vector(to_unsigned( 229 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 209 , 8)),
				 15 => std_logic_vector(to_unsigned( 169 , 8)),
				 16 => std_logic_vector(to_unsigned( 41 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 15 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 789

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 253 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 255 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 6 , 8)),
				 6 => std_logic_vector(to_unsigned( 161 , 8)),
				 7 => std_logic_vector(to_unsigned( 157 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 164 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 165 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 156 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 157 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 40 , 8)),
				 18 => std_logic_vector(to_unsigned( 38 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 790

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 31 , 8)),
				 1 => std_logic_vector(to_unsigned( 87 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 125 , 8)),
				 5 => std_logic_vector(to_unsigned( 146 , 8)),
				 6 => std_logic_vector(to_unsigned( 54 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 143 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 107 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 106 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 106 , 8)),
				 17 => std_logic_vector(to_unsigned( 183 , 8)),
				 18 => std_logic_vector(to_unsigned( 132 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 791

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 122 , 8)),
				 1 => std_logic_vector(to_unsigned( 19 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 90 , 8)),
				 4 => std_logic_vector(to_unsigned( 183 , 8)),
				 5 => std_logic_vector(to_unsigned( 21 , 8)),
				 6 => std_logic_vector(to_unsigned( 44 , 8)),
				 7 => std_logic_vector(to_unsigned( 38 , 8)),
				 8 => std_logic_vector(to_unsigned( 27 , 8)),
				 9 => std_logic_vector(to_unsigned( 64 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 205 , 8)),
				 14 => std_logic_vector(to_unsigned( 32 , 8)),
				 15 => std_logic_vector(to_unsigned( 21 , 8)),
				 16 => std_logic_vector(to_unsigned( 97 , 8)),
				 17 => std_logic_vector(to_unsigned( 47 , 8)),
				 18 => std_logic_vector(to_unsigned( 44 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 792

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 109 , 8)),
				 1 => std_logic_vector(to_unsigned( 107 , 8)),
				 2 => std_logic_vector(to_unsigned( 141 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 24 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 235 , 8)),
				 10 => std_logic_vector(to_unsigned( 28 , 8)),
				 11 => std_logic_vector(to_unsigned( 98 , 8)),
				 12 => std_logic_vector(to_unsigned( 138 , 8)),
				 13 => std_logic_vector(to_unsigned( 102 , 8)),
				 14 => std_logic_vector(to_unsigned( 134 , 8)),
				 15 => std_logic_vector(to_unsigned( 117 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 184 , 8)),
				 18 => std_logic_vector(to_unsigned( 83 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 793

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 25 , 8)),
				 1 => std_logic_vector(to_unsigned( 67 , 8)),
				 2 => std_logic_vector(to_unsigned( 71 , 8)),
				 3 => std_logic_vector(to_unsigned( 56 , 8)),
				 4 => std_logic_vector(to_unsigned( 94 , 8)),
				 5 => std_logic_vector(to_unsigned( 172 , 8)),
				 6 => std_logic_vector(to_unsigned( 48 , 8)),
				 7 => std_logic_vector(to_unsigned( 11 , 8)),
				 8 => std_logic_vector(to_unsigned( 190 , 8)),
				 9 => std_logic_vector(to_unsigned( 51 , 8)),
				 10 => std_logic_vector(to_unsigned( 150 , 8)),
				 11 => std_logic_vector(to_unsigned( 109 , 8)),
				 12 => std_logic_vector(to_unsigned( 92 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 13 , 8)),
				 15 => std_logic_vector(to_unsigned( 60 , 8)),
				 16 => std_logic_vector(to_unsigned( 130 , 8)),
				 17 => std_logic_vector(to_unsigned( 73 , 8)),
				 18 => std_logic_vector(to_unsigned( 117 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 794

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 13 , 8)),
				 1 => std_logic_vector(to_unsigned( 106 , 8)),
				 2 => std_logic_vector(to_unsigned( 148 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 245 , 8)),
				 5 => std_logic_vector(to_unsigned( 58 , 8)),
				 6 => std_logic_vector(to_unsigned( 83 , 8)),
				 7 => std_logic_vector(to_unsigned( 19 , 8)),
				 8 => std_logic_vector(to_unsigned( 29 , 8)),
				 9 => std_logic_vector(to_unsigned( 47 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 47 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 152 , 8)),
				 14 => std_logic_vector(to_unsigned( 134 , 8)),
				 15 => std_logic_vector(to_unsigned( 168 , 8)),
				 16 => std_logic_vector(to_unsigned( 141 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 84 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 795

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 234 , 8)),
				 1 => std_logic_vector(to_unsigned( 3 , 8)),
				 2 => std_logic_vector(to_unsigned( 179 , 8)),
				 3 => std_logic_vector(to_unsigned( 29 , 8)),
				 4 => std_logic_vector(to_unsigned( 153 , 8)),
				 5 => std_logic_vector(to_unsigned( 48 , 8)),
				 6 => std_logic_vector(to_unsigned( 34 , 8)),
				 7 => std_logic_vector(to_unsigned( 246 , 8)),
				 8 => std_logic_vector(to_unsigned( 28 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 56 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 196 , 8)),
				 16 => std_logic_vector(to_unsigned( 28 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 31 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 796

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 41 , 8)),
				 1 => std_logic_vector(to_unsigned( 43 , 8)),
				 2 => std_logic_vector(to_unsigned( 197 , 8)),
				 3 => std_logic_vector(to_unsigned( 75 , 8)),
				 4 => std_logic_vector(to_unsigned( 63 , 8)),
				 5 => std_logic_vector(to_unsigned( 130 , 8)),
				 6 => std_logic_vector(to_unsigned( 8 , 8)),
				 7 => std_logic_vector(to_unsigned( 133 , 8)),
				 8 => std_logic_vector(to_unsigned( 5 , 8)),
				 9 => std_logic_vector(to_unsigned( 25 , 8)),
				 10 => std_logic_vector(to_unsigned( 232 , 8)),
				 11 => std_logic_vector(to_unsigned( 215 , 8)),
				 12 => std_logic_vector(to_unsigned( 31 , 8)),
				 13 => std_logic_vector(to_unsigned( 93 , 8)),
				 14 => std_logic_vector(to_unsigned( 84 , 8)),
				 15 => std_logic_vector(to_unsigned( 154 , 8)),
				 16 => std_logic_vector(to_unsigned( 32 , 8)),
				 17 => std_logic_vector(to_unsigned( 0 , 8)),
				 18 => std_logic_vector(to_unsigned( 42 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 797

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 2 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 86 , 8)),
				 3 => std_logic_vector(to_unsigned( 186 , 8)),
				 4 => std_logic_vector(to_unsigned( 58 , 8)),
				 5 => std_logic_vector(to_unsigned( 191 , 8)),
				 6 => std_logic_vector(to_unsigned( 53 , 8)),
				 7 => std_logic_vector(to_unsigned( 74 , 8)),
				 8 => std_logic_vector(to_unsigned( 174 , 8)),
				 9 => std_logic_vector(to_unsigned( 144 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 200 , 8)),
				 12 => std_logic_vector(to_unsigned( 188 , 8)),
				 13 => std_logic_vector(to_unsigned( 221 , 8)),
				 14 => std_logic_vector(to_unsigned( 167 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 161 , 8)),
				 17 => std_logic_vector(to_unsigned( 157 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 798

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 27 , 8)),
				 2 => std_logic_vector(to_unsigned( 161 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 124 , 8)),
				 5 => std_logic_vector(to_unsigned( 218 , 8)),
				 6 => std_logic_vector(to_unsigned( 35 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 251 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 32 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 24 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 23 , 8)),
				 18 => std_logic_vector(to_unsigned( 81 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 799

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 122 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 113 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 93 , 8)),
				 7 => std_logic_vector(to_unsigned( 170 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 111 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 223 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 111 , 8)),
				 18 => std_logic_vector(to_unsigned( 73 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 800

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 249 , 8)),
				 2 => std_logic_vector(to_unsigned( 216 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 211 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 210 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 82 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 186 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 180 , 8)),
				 15 => std_logic_vector(to_unsigned( 166 , 8)),
				 16 => std_logic_vector(to_unsigned( 92 , 8)),
				 17 => std_logic_vector(to_unsigned( 170 , 8)),
				 18 => std_logic_vector(to_unsigned( 225 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 801

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 64 , 8)),
				 1 => std_logic_vector(to_unsigned( 38 , 8)),
				 2 => std_logic_vector(to_unsigned( 189 , 8)),
				 3 => std_logic_vector(to_unsigned( 150 , 8)),
				 4 => std_logic_vector(to_unsigned( 77 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 207 , 8)),
				 8 => std_logic_vector(to_unsigned( 20 , 8)),
				 9 => std_logic_vector(to_unsigned( 18 , 8)),
				 10 => std_logic_vector(to_unsigned( 243 , 8)),
				 11 => std_logic_vector(to_unsigned( 57 , 8)),
				 12 => std_logic_vector(to_unsigned( 204 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 196 , 8)),
				 18 => std_logic_vector(to_unsigned( 39 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 802

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 0 , 8)),
				 1 => std_logic_vector(to_unsigned( 89 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 141 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 238 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 197 , 8)),
				 9 => std_logic_vector(to_unsigned( 90 , 8)),
				 10 => std_logic_vector(to_unsigned( 108 , 8)),
				 11 => std_logic_vector(to_unsigned( 96 , 8)),
				 12 => std_logic_vector(to_unsigned( 102 , 8)),
				 13 => std_logic_vector(to_unsigned( 188 , 8)),
				 14 => std_logic_vector(to_unsigned( 24 , 8)),
				 15 => std_logic_vector(to_unsigned( 204 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 213 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 0 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 803

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 72 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 48 , 8)),
				 4 => std_logic_vector(to_unsigned( 131 , 8)),
				 5 => std_logic_vector(to_unsigned( 139 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 178 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 62 , 8)),
				 11 => std_logic_vector(to_unsigned( 214 , 8)),
				 12 => std_logic_vector(to_unsigned( 29 , 8)),
				 13 => std_logic_vector(to_unsigned( 214 , 8)),
				 14 => std_logic_vector(to_unsigned( 29 , 8)),
				 15 => std_logic_vector(to_unsigned( 234 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 87 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 804

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 244 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 35 , 8)),
				 3 => std_logic_vector(to_unsigned( 41 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 58 , 8)),
				 6 => std_logic_vector(to_unsigned( 246 , 8)),
				 7 => std_logic_vector(to_unsigned( 163 , 8)),
				 8 => std_logic_vector(to_unsigned( 141 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 178 , 8)),
				 11 => std_logic_vector(to_unsigned( 8 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 35 , 8)),
				 14 => std_logic_vector(to_unsigned( 251 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 35 , 8)),
				 17 => std_logic_vector(to_unsigned( 27 , 8)),
				 18 => std_logic_vector(to_unsigned( 88 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 805

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 186 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 131 , 8)),
				 5 => std_logic_vector(to_unsigned( 219 , 8)),
				 6 => std_logic_vector(to_unsigned( 180 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 150 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 145 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 144 , 8)),
				 13 => std_logic_vector(to_unsigned( 39 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 87 , 8)),
				 16 => std_logic_vector(to_unsigned( 34 , 8)),
				 17 => std_logic_vector(to_unsigned( 191 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 806

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 199 , 8)),
				 2 => std_logic_vector(to_unsigned( 154 , 8)),
				 3 => std_logic_vector(to_unsigned( 130 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 185 , 8)),
				 7 => std_logic_vector(to_unsigned( 151 , 8)),
				 8 => std_logic_vector(to_unsigned( 156 , 8)),
				 9 => std_logic_vector(to_unsigned( 204 , 8)),
				 10 => std_logic_vector(to_unsigned( 92 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 43 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 43 , 8)),
				 17 => std_logic_vector(to_unsigned( 15 , 8)),
				 18 => std_logic_vector(to_unsigned( 120 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 807

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 67 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 2 , 8)),
				 8 => std_logic_vector(to_unsigned( 51 , 8)),
				 9 => std_logic_vector(to_unsigned( 34 , 8)),
				 10 => std_logic_vector(to_unsigned( 19 , 8)),
				 11 => std_logic_vector(to_unsigned( 36 , 8)),
				 12 => std_logic_vector(to_unsigned( 17 , 8)),
				 13 => std_logic_vector(to_unsigned( 41 , 8)),
				 14 => std_logic_vector(to_unsigned( 12 , 8)),
				 15 => std_logic_vector(to_unsigned( 29 , 8)),
				 16 => std_logic_vector(to_unsigned( 238 , 8)),
				 17 => std_logic_vector(to_unsigned( 242 , 8)),
				 18 => std_logic_vector(to_unsigned( 136 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 808

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 162 , 8)),
				 1 => std_logic_vector(to_unsigned( 13 , 8)),
				 2 => std_logic_vector(to_unsigned( 218 , 8)),
				 3 => std_logic_vector(to_unsigned( 171 , 8)),
				 4 => std_logic_vector(to_unsigned( 162 , 8)),
				 5 => std_logic_vector(to_unsigned( 192 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 147 , 8)),
				 8 => std_logic_vector(to_unsigned( 187 , 8)),
				 9 => std_logic_vector(to_unsigned( 236 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 145 , 8)),
				 12 => std_logic_vector(to_unsigned( 184 , 8)),
				 13 => std_logic_vector(to_unsigned( 75 , 8)),
				 14 => std_logic_vector(to_unsigned( 75 , 8)),
				 15 => std_logic_vector(to_unsigned( 98 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 106 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 809

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 23 , 8)),
				 2 => std_logic_vector(to_unsigned( 125 , 8)),
				 3 => std_logic_vector(to_unsigned( 43 , 8)),
				 4 => std_logic_vector(to_unsigned( 105 , 8)),
				 5 => std_logic_vector(to_unsigned( 121 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 131 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 142 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 206 , 8)),
				 12 => std_logic_vector(to_unsigned( 78 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 29 , 8)),
				 15 => std_logic_vector(to_unsigned( 114 , 8)),
				 16 => std_logic_vector(to_unsigned( 209 , 8)),
				 17 => std_logic_vector(to_unsigned( 108 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 810

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 252 , 8)),
				 1 => std_logic_vector(to_unsigned( 126 , 8)),
				 2 => std_logic_vector(to_unsigned( 195 , 8)),
				 3 => std_logic_vector(to_unsigned( 199 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 73 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 73 , 8)),
				 9 => std_logic_vector(to_unsigned( 168 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 58 , 8)),
				 13 => std_logic_vector(to_unsigned( 74 , 8)),
				 14 => std_logic_vector(to_unsigned( 228 , 8)),
				 15 => std_logic_vector(to_unsigned( 100 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 178 , 8)),
				 18 => std_logic_vector(to_unsigned( 41 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 811

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 212 , 8)),
				 2 => std_logic_vector(to_unsigned( 252 , 8)),
				 3 => std_logic_vector(to_unsigned( 237 , 8)),
				 4 => std_logic_vector(to_unsigned( 118 , 8)),
				 5 => std_logic_vector(to_unsigned( 227 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 111 , 8)),
				 8 => std_logic_vector(to_unsigned( 168 , 8)),
				 9 => std_logic_vector(to_unsigned( 24 , 8)),
				 10 => std_logic_vector(to_unsigned( 102 , 8)),
				 11 => std_logic_vector(to_unsigned( 100 , 8)),
				 12 => std_logic_vector(to_unsigned( 26 , 8)),
				 13 => std_logic_vector(to_unsigned( 159 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 68 , 8)),
				 16 => std_logic_vector(to_unsigned( 81 , 8)),
				 17 => std_logic_vector(to_unsigned( 54 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 812

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 13 , 8)),
				 1 => std_logic_vector(to_unsigned( 16 , 8)),
				 2 => std_logic_vector(to_unsigned( 195 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 164 , 8)),
				 6 => std_logic_vector(to_unsigned( 47 , 8)),
				 7 => std_logic_vector(to_unsigned( 123 , 8)),
				 8 => std_logic_vector(to_unsigned( 254 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 184 , 8)),
				 11 => std_logic_vector(to_unsigned( 227 , 8)),
				 12 => std_logic_vector(to_unsigned( 143 , 8)),
				 13 => std_logic_vector(to_unsigned( 183 , 8)),
				 14 => std_logic_vector(to_unsigned( 82 , 8)),
				 15 => std_logic_vector(to_unsigned( 232 , 8)),
				 16 => std_logic_vector(to_unsigned( 33 , 8)),
				 17 => std_logic_vector(to_unsigned( 231 , 8)),
				 18 => std_logic_vector(to_unsigned( 126 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 813

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 12 , 8)),
				 3 => std_logic_vector(to_unsigned( 212 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 159 , 8)),
				 7 => std_logic_vector(to_unsigned( 179 , 8)),
				 8 => std_logic_vector(to_unsigned( 249 , 8)),
				 9 => std_logic_vector(to_unsigned( 11 , 8)),
				 10 => std_logic_vector(to_unsigned( 247 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 168 , 8)),
				 16 => std_logic_vector(to_unsigned( 197 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 130 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 814

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 206 , 8)),
				 1 => std_logic_vector(to_unsigned( 163 , 8)),
				 2 => std_logic_vector(to_unsigned( 13 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 6 , 8)),
				 5 => std_logic_vector(to_unsigned( 173 , 8)),
				 6 => std_logic_vector(to_unsigned( 141 , 8)),
				 7 => std_logic_vector(to_unsigned( 200 , 8)),
				 8 => std_logic_vector(to_unsigned( 114 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 77 , 8)),
				 11 => std_logic_vector(to_unsigned( 41 , 8)),
				 12 => std_logic_vector(to_unsigned( 203 , 8)),
				 13 => std_logic_vector(to_unsigned( 96 , 8)),
				 14 => std_logic_vector(to_unsigned( 148 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 153 , 8)),
				 17 => std_logic_vector(to_unsigned( 112 , 8)),
				 18 => std_logic_vector(to_unsigned( 197 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 815

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 192 , 8)),
				 1 => std_logic_vector(to_unsigned( 45 , 8)),
				 2 => std_logic_vector(to_unsigned( 77 , 8)),
				 3 => std_logic_vector(to_unsigned( 219 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 238 , 8)),
				 6 => std_logic_vector(to_unsigned( 85 , 8)),
				 7 => std_logic_vector(to_unsigned( 249 , 8)),
				 8 => std_logic_vector(to_unsigned( 74 , 8)),
				 9 => std_logic_vector(to_unsigned( 223 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 232 , 8)),
				 13 => std_logic_vector(to_unsigned( 254 , 8)),
				 14 => std_logic_vector(to_unsigned( 182 , 8)),
				 15 => std_logic_vector(to_unsigned( 112 , 8)),
				 16 => std_logic_vector(to_unsigned( 18 , 8)),
				 17 => std_logic_vector(to_unsigned( 49 , 8)),
				 18 => std_logic_vector(to_unsigned( 140 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 816

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 26 , 8)),
				 2 => std_logic_vector(to_unsigned( 91 , 8)),
				 3 => std_logic_vector(to_unsigned( 85 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 2 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 19 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 118 , 8)),
				 10 => std_logic_vector(to_unsigned( 105 , 8)),
				 11 => std_logic_vector(to_unsigned( 122 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 212 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 73 , 8)),
				 17 => std_logic_vector(to_unsigned( 149 , 8)),
				 18 => std_logic_vector(to_unsigned( 14 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 817

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 175 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 185 , 8)),
				 6 => std_logic_vector(to_unsigned( 106 , 8)),
				 7 => std_logic_vector(to_unsigned( 236 , 8)),
				 8 => std_logic_vector(to_unsigned( 55 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 104 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 59 , 8)),
				 13 => std_logic_vector(to_unsigned( 166 , 8)),
				 14 => std_logic_vector(to_unsigned( 30 , 8)),
				 15 => std_logic_vector(to_unsigned( 188 , 8)),
				 16 => std_logic_vector(to_unsigned( 8 , 8)),
				 17 => std_logic_vector(to_unsigned( 252 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 9 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 818

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 114 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 213 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 210 , 8)),
				 5 => std_logic_vector(to_unsigned( 62 , 8)),
				 6 => std_logic_vector(to_unsigned( 105 , 8)),
				 7 => std_logic_vector(to_unsigned( 130 , 8)),
				 8 => std_logic_vector(to_unsigned( 174 , 8)),
				 9 => std_logic_vector(to_unsigned( 234 , 8)),
				 10 => std_logic_vector(to_unsigned( 70 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 55 , 8)),
				 13 => std_logic_vector(to_unsigned( 102 , 8)),
				 14 => std_logic_vector(to_unsigned( 70 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 41 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 13 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 819

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 194 , 8)),
				 1 => std_logic_vector(to_unsigned( 12 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 252 , 8)),
				 5 => std_logic_vector(to_unsigned( 236 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 250 , 8)),
				 8 => std_logic_vector(to_unsigned( 23 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 183 , 8)),
				 11 => std_logic_vector(to_unsigned( 238 , 8)),
				 12 => std_logic_vector(to_unsigned( 177 , 8)),
				 13 => std_logic_vector(to_unsigned( 239 , 8)),
				 14 => std_logic_vector(to_unsigned( 176 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 153 , 8)),
				 17 => std_logic_vector(to_unsigned( 241 , 8)),
				 18 => std_logic_vector(to_unsigned( 221 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 820

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 109 , 8)),
				 1 => std_logic_vector(to_unsigned( 210 , 8)),
				 2 => std_logic_vector(to_unsigned( 130 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 90 , 8)),
				 6 => std_logic_vector(to_unsigned( 170 , 8)),
				 7 => std_logic_vector(to_unsigned( 224 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 20 , 8)),
				 11 => std_logic_vector(to_unsigned( 31 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 46 , 8)),
				 14 => std_logic_vector(to_unsigned( 185 , 8)),
				 15 => std_logic_vector(to_unsigned( 31 , 8)),
				 16 => std_logic_vector(to_unsigned( 145 , 8)),
				 17 => std_logic_vector(to_unsigned( 189 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 821

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 44 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 65 , 8)),
				 3 => std_logic_vector(to_unsigned( 77 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 227 , 8)),
				 6 => std_logic_vector(to_unsigned( 108 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 92 , 8)),
				 9 => std_logic_vector(to_unsigned( 133 , 8)),
				 10 => std_logic_vector(to_unsigned( 146 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 106 , 8)),
				 13 => std_logic_vector(to_unsigned( 216 , 8)),
				 14 => std_logic_vector(to_unsigned( 63 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 16 , 8)),
				 18 => std_logic_vector(to_unsigned( 75 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 822

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 31 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 166 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 14 , 8)),
				 7 => std_logic_vector(to_unsigned( 114 , 8)),
				 8 => std_logic_vector(to_unsigned( 177 , 8)),
				 9 => std_logic_vector(to_unsigned( 135 , 8)),
				 10 => std_logic_vector(to_unsigned( 156 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 53 , 8)),
				 13 => std_logic_vector(to_unsigned( 209 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 39 , 8)),
				 17 => std_logic_vector(to_unsigned( 55 , 8)),
				 18 => std_logic_vector(to_unsigned( 48 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 823

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 179 , 8)),
				 2 => std_logic_vector(to_unsigned( 42 , 8)),
				 3 => std_logic_vector(to_unsigned( 189 , 8)),
				 4 => std_logic_vector(to_unsigned( 32 , 8)),
				 5 => std_logic_vector(to_unsigned( 189 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 138 , 8)),
				 8 => std_logic_vector(to_unsigned( 96 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 219 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 200 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 824

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 209 , 8)),
				 1 => std_logic_vector(to_unsigned( 76 , 8)),
				 2 => std_logic_vector(to_unsigned( 128 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 201 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 201 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 203 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 203 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 199 , 8)),
				 18 => std_logic_vector(to_unsigned( 46 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 825

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 95 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 100 , 8)),
				 4 => std_logic_vector(to_unsigned( 249 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 118 , 8)),
				 7 => std_logic_vector(to_unsigned( 231 , 8)),
				 8 => std_logic_vector(to_unsigned( 118 , 8)),
				 9 => std_logic_vector(to_unsigned( 164 , 8)),
				 10 => std_logic_vector(to_unsigned( 245 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 164 , 8)),
				 13 => std_logic_vector(to_unsigned( 155 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 217 , 8)),
				 18 => std_logic_vector(to_unsigned( 112 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 826

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 212 , 8)),
				 2 => std_logic_vector(to_unsigned( 83 , 8)),
				 3 => std_logic_vector(to_unsigned( 65 , 8)),
				 4 => std_logic_vector(to_unsigned( 61 , 8)),
				 5 => std_logic_vector(to_unsigned( 97 , 8)),
				 6 => std_logic_vector(to_unsigned( 70 , 8)),
				 7 => std_logic_vector(to_unsigned( 135 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 162 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 144 , 8)),
				 15 => std_logic_vector(to_unsigned( 194 , 8)),
				 16 => std_logic_vector(to_unsigned( 125 , 8)),
				 17 => std_logic_vector(to_unsigned( 236 , 8)),
				 18 => std_logic_vector(to_unsigned( 89 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 827

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 190 , 8)),
				 1 => std_logic_vector(to_unsigned( 150 , 8)),
				 2 => std_logic_vector(to_unsigned( 199 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 103 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 101 , 8)),
				 7 => std_logic_vector(to_unsigned( 190 , 8)),
				 8 => std_logic_vector(to_unsigned( 39 , 8)),
				 9 => std_logic_vector(to_unsigned( 205 , 8)),
				 10 => std_logic_vector(to_unsigned( 24 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 226 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 47 , 8)),
				 16 => std_logic_vector(to_unsigned( 190 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 828

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 134 , 8)),
				 1 => std_logic_vector(to_unsigned( 117 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 248 , 8)),
				 4 => std_logic_vector(to_unsigned( 217 , 8)),
				 5 => std_logic_vector(to_unsigned( 143 , 8)),
				 6 => std_logic_vector(to_unsigned( 254 , 8)),
				 7 => std_logic_vector(to_unsigned( 193 , 8)),
				 8 => std_logic_vector(to_unsigned( 204 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 211 , 8)),
				 11 => std_logic_vector(to_unsigned( 118 , 8)),
				 12 => std_logic_vector(to_unsigned( 244 , 8)),
				 13 => std_logic_vector(to_unsigned( 141 , 8)),
				 14 => std_logic_vector(to_unsigned( 221 , 8)),
				 15 => std_logic_vector(to_unsigned( 156 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 829

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 183 , 8)),
				 2 => std_logic_vector(to_unsigned( 161 , 8)),
				 3 => std_logic_vector(to_unsigned( 167 , 8)),
				 4 => std_logic_vector(to_unsigned( 52 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 32 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 14 , 8)),
				 9 => std_logic_vector(to_unsigned( 71 , 8)),
				 10 => std_logic_vector(to_unsigned( 233 , 8)),
				 11 => std_logic_vector(to_unsigned( 169 , 8)),
				 12 => std_logic_vector(to_unsigned( 135 , 8)),
				 13 => std_logic_vector(to_unsigned( 75 , 8)),
				 14 => std_logic_vector(to_unsigned( 52 , 8)),
				 15 => std_logic_vector(to_unsigned( 122 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 34 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 830

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 101 , 8)),
				 1 => std_logic_vector(to_unsigned( 176 , 8)),
				 2 => std_logic_vector(to_unsigned( 124 , 8)),
				 3 => std_logic_vector(to_unsigned( 17 , 8)),
				 4 => std_logic_vector(to_unsigned( 245 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 143 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 243 , 8)),
				 10 => std_logic_vector(to_unsigned( 141 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 139 , 8)),
				 13 => std_logic_vector(to_unsigned( 248 , 8)),
				 14 => std_logic_vector(to_unsigned( 136 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 32 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 831

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 141 , 8)),
				 1 => std_logic_vector(to_unsigned( 38 , 8)),
				 2 => std_logic_vector(to_unsigned( 160 , 8)),
				 3 => std_logic_vector(to_unsigned( 231 , 8)),
				 4 => std_logic_vector(to_unsigned( 226 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 209 , 8)),
				 7 => std_logic_vector(to_unsigned( 85 , 8)),
				 8 => std_logic_vector(to_unsigned( 152 , 8)),
				 9 => std_logic_vector(to_unsigned( 226 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 77 , 8)),
				 15 => std_logic_vector(to_unsigned( 194 , 8)),
				 16 => std_logic_vector(to_unsigned( 192 , 8)),
				 17 => std_logic_vector(to_unsigned( 9 , 8)),
				 18 => std_logic_vector(to_unsigned( 121 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 832

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 11 , 8)),
				 3 => std_logic_vector(to_unsigned( 29 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 154 , 8)),
				 8 => std_logic_vector(to_unsigned( 9 , 8)),
				 9 => std_logic_vector(to_unsigned( 158 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 3 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 161 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 50 , 8)),
				 18 => std_logic_vector(to_unsigned( 97 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 833

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 241 , 8)),
				 1 => std_logic_vector(to_unsigned( 194 , 8)),
				 2 => std_logic_vector(to_unsigned( 134 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 110 , 8)),
				 5 => std_logic_vector(to_unsigned( 136 , 8)),
				 6 => std_logic_vector(to_unsigned( 140 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 64 , 8)),
				 9 => std_logic_vector(to_unsigned( 229 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 247 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 20 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 115 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 834

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 81 , 8)),
				 1 => std_logic_vector(to_unsigned( 244 , 8)),
				 2 => std_logic_vector(to_unsigned( 233 , 8)),
				 3 => std_logic_vector(to_unsigned( 178 , 8)),
				 4 => std_logic_vector(to_unsigned( 155 , 8)),
				 5 => std_logic_vector(to_unsigned( 119 , 8)),
				 6 => std_logic_vector(to_unsigned( 37 , 8)),
				 7 => std_logic_vector(to_unsigned( 79 , 8)),
				 8 => std_logic_vector(to_unsigned( 161 , 8)),
				 9 => std_logic_vector(to_unsigned( 147 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 29 , 8)),
				 12 => std_logic_vector(to_unsigned( 213 , 8)),
				 13 => std_logic_vector(to_unsigned( 4 , 8)),
				 14 => std_logic_vector(to_unsigned( 214 , 8)),
				 15 => std_logic_vector(to_unsigned( 174 , 8)),
				 16 => std_logic_vector(to_unsigned( 160 , 8)),
				 17 => std_logic_vector(to_unsigned( 54 , 8)),
				 18 => std_logic_vector(to_unsigned( 11 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 835

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 169 , 8)),
				 1 => std_logic_vector(to_unsigned( 36 , 8)),
				 2 => std_logic_vector(to_unsigned( 171 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 93 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 92 , 8)),
				 13 => std_logic_vector(to_unsigned( 101 , 8)),
				 14 => std_logic_vector(to_unsigned( 60 , 8)),
				 15 => std_logic_vector(to_unsigned( 109 , 8)),
				 16 => std_logic_vector(to_unsigned( 52 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 836

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 179 , 8)),
				 1 => std_logic_vector(to_unsigned( 152 , 8)),
				 2 => std_logic_vector(to_unsigned( 184 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 86 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 85 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 84 , 8)),
				 9 => std_logic_vector(to_unsigned( 81 , 8)),
				 10 => std_logic_vector(to_unsigned( 243 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 131 , 8)),
				 13 => std_logic_vector(to_unsigned( 247 , 8)),
				 14 => std_logic_vector(to_unsigned( 77 , 8)),
				 15 => std_logic_vector(to_unsigned( 219 , 8)),
				 16 => std_logic_vector(to_unsigned( 194 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 66 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 837

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 26 , 8)),
				 1 => std_logic_vector(to_unsigned( 137 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 35 , 8)),
				 4 => std_logic_vector(to_unsigned( 130 , 8)),
				 5 => std_logic_vector(to_unsigned( 62 , 8)),
				 6 => std_logic_vector(to_unsigned( 103 , 8)),
				 7 => std_logic_vector(to_unsigned( 36 , 8)),
				 8 => std_logic_vector(to_unsigned( 186 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 95 , 8)),
				 11 => std_logic_vector(to_unsigned( 168 , 8)),
				 12 => std_logic_vector(to_unsigned( 54 , 8)),
				 13 => std_logic_vector(to_unsigned( 172 , 8)),
				 14 => std_logic_vector(to_unsigned( 50 , 8)),
				 15 => std_logic_vector(to_unsigned( 193 , 8)),
				 16 => std_logic_vector(to_unsigned( 208 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 838

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 129 , 8)),
				 1 => std_logic_vector(to_unsigned( 223 , 8)),
				 2 => std_logic_vector(to_unsigned( 68 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 45 , 8)),
				 5 => std_logic_vector(to_unsigned( 30 , 8)),
				 6 => std_logic_vector(to_unsigned( 170 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 101 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 101 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 101 , 8)),
				 13 => std_logic_vector(to_unsigned( 81 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 197 , 8)),
				 16 => std_logic_vector(to_unsigned( 76 , 8)),
				 17 => std_logic_vector(to_unsigned( 120 , 8)),
				 18 => std_logic_vector(to_unsigned( 170 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 839

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 31 , 8)),
				 1 => std_logic_vector(to_unsigned( 53 , 8)),
				 2 => std_logic_vector(to_unsigned( 4 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 110 , 8)),
				 6 => std_logic_vector(to_unsigned( 51 , 8)),
				 7 => std_logic_vector(to_unsigned( 145 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 151 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 82 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 43 , 8)),
				 16 => std_logic_vector(to_unsigned( 89 , 8)),
				 17 => std_logic_vector(to_unsigned( 180 , 8)),
				 18 => std_logic_vector(to_unsigned( 33 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 840

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 157 , 8)),
				 1 => std_logic_vector(to_unsigned( 171 , 8)),
				 2 => std_logic_vector(to_unsigned( 88 , 8)),
				 3 => std_logic_vector(to_unsigned( 179 , 8)),
				 4 => std_logic_vector(to_unsigned( 80 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 5 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 11 , 8)),
				 14 => std_logic_vector(to_unsigned( 87 , 8)),
				 15 => std_logic_vector(to_unsigned( 34 , 8)),
				 16 => std_logic_vector(to_unsigned( 64 , 8)),
				 17 => std_logic_vector(to_unsigned( 245 , 8)),
				 18 => std_logic_vector(to_unsigned( 176 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 841

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 167 , 8)),
				 2 => std_logic_vector(to_unsigned( 238 , 8)),
				 3 => std_logic_vector(to_unsigned( 198 , 8)),
				 4 => std_logic_vector(to_unsigned( 119 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 110 , 8)),
				 7 => std_logic_vector(to_unsigned( 229 , 8)),
				 8 => std_logic_vector(to_unsigned( 88 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 65 , 8)),
				 13 => std_logic_vector(to_unsigned( 253 , 8)),
				 14 => std_logic_vector(to_unsigned( 64 , 8)),
				 15 => std_logic_vector(to_unsigned( 254 , 8)),
				 16 => std_logic_vector(to_unsigned( 63 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 842

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 183 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 168 , 8)),
				 3 => std_logic_vector(to_unsigned( 128 , 8)),
				 4 => std_logic_vector(to_unsigned( 9 , 8)),
				 5 => std_logic_vector(to_unsigned( 135 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 94 , 8)),
				 11 => std_logic_vector(to_unsigned( 213 , 8)),
				 12 => std_logic_vector(to_unsigned( 56 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 49 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 42 , 8)),
				 17 => std_logic_vector(to_unsigned( 194 , 8)),
				 18 => std_logic_vector(to_unsigned( 20 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 160 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 843

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 141 , 8)),
				 1 => std_logic_vector(to_unsigned( 36 , 8)),
				 2 => std_logic_vector(to_unsigned( 41 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 66 , 8)),
				 6 => std_logic_vector(to_unsigned( 11 , 8)),
				 7 => std_logic_vector(to_unsigned( 12 , 8)),
				 8 => std_logic_vector(to_unsigned( 115 , 8)),
				 9 => std_logic_vector(to_unsigned( 118 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 118 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 126 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 126 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 26 , 8)),
				 18 => std_logic_vector(to_unsigned( 55 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 844

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 231 , 8)),
				 2 => std_logic_vector(to_unsigned( 134 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 14 , 8)),
				 5 => std_logic_vector(to_unsigned( 58 , 8)),
				 6 => std_logic_vector(to_unsigned( 10 , 8)),
				 7 => std_logic_vector(to_unsigned( 203 , 8)),
				 8 => std_logic_vector(to_unsigned( 230 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 207 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 206 , 8)),
				 13 => std_logic_vector(to_unsigned( 175 , 8)),
				 14 => std_logic_vector(to_unsigned( 251 , 8)),
				 15 => std_logic_vector(to_unsigned( 183 , 8)),
				 16 => std_logic_vector(to_unsigned( 243 , 8)),
				 17 => std_logic_vector(to_unsigned( 228 , 8)),
				 18 => std_logic_vector(to_unsigned( 171 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 845

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 72 , 8)),
				 1 => std_logic_vector(to_unsigned( 32 , 8)),
				 2 => std_logic_vector(to_unsigned( 108 , 8)),
				 3 => std_logic_vector(to_unsigned( 23 , 8)),
				 4 => std_logic_vector(to_unsigned( 150 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 153 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 45 , 8)),
				 9 => std_logic_vector(to_unsigned( 164 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 99 , 8)),
				 12 => std_logic_vector(to_unsigned( 223 , 8)),
				 13 => std_logic_vector(to_unsigned( 190 , 8)),
				 14 => std_logic_vector(to_unsigned( 215 , 8)),
				 15 => std_logic_vector(to_unsigned( 191 , 8)),
				 16 => std_logic_vector(to_unsigned( 214 , 8)),
				 17 => std_logic_vector(to_unsigned( 140 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 846

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 29 , 8)),
				 1 => std_logic_vector(to_unsigned( 119 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 33 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 111 , 8)),
				 6 => std_logic_vector(to_unsigned( 36 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 34 , 8)),
				 9 => std_logic_vector(to_unsigned( 133 , 8)),
				 10 => std_logic_vector(to_unsigned( 14 , 8)),
				 11 => std_logic_vector(to_unsigned( 91 , 8)),
				 12 => std_logic_vector(to_unsigned( 251 , 8)),
				 13 => std_logic_vector(to_unsigned( 29 , 8)),
				 14 => std_logic_vector(to_unsigned( 141 , 8)),
				 15 => std_logic_vector(to_unsigned( 70 , 8)),
				 16 => std_logic_vector(to_unsigned( 126 , 8)),
				 17 => std_logic_vector(to_unsigned( 147 , 8)),
				 18 => std_logic_vector(to_unsigned( 68 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 847

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 25 , 8)),
				 1 => std_logic_vector(to_unsigned( 121 , 8)),
				 2 => std_logic_vector(to_unsigned( 13 , 8)),
				 3 => std_logic_vector(to_unsigned( 15 , 8)),
				 4 => std_logic_vector(to_unsigned( 113 , 8)),
				 5 => std_logic_vector(to_unsigned( 61 , 8)),
				 6 => std_logic_vector(to_unsigned( 67 , 8)),
				 7 => std_logic_vector(to_unsigned( 70 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 90 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 103 , 8)),
				 12 => std_logic_vector(to_unsigned( 25 , 8)),
				 13 => std_logic_vector(to_unsigned( 10 , 8)),
				 14 => std_logic_vector(to_unsigned( 179 , 8)),
				 15 => std_logic_vector(to_unsigned( 141 , 8)),
				 16 => std_logic_vector(to_unsigned( 48 , 8)),
				 17 => std_logic_vector(to_unsigned( 91 , 8)),
				 18 => std_logic_vector(to_unsigned( 95 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 848

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 149 , 8)),
				 2 => std_logic_vector(to_unsigned( 98 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 7 , 8)),
				 5 => std_logic_vector(to_unsigned( 238 , 8)),
				 6 => std_logic_vector(to_unsigned( 207 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 193 , 8)),
				 9 => std_logic_vector(to_unsigned( 159 , 8)),
				 10 => std_logic_vector(to_unsigned( 58 , 8)),
				 11 => std_logic_vector(to_unsigned( 217 , 8)),
				 12 => std_logic_vector(to_unsigned( 203 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 175 , 8)),
				 15 => std_logic_vector(to_unsigned( 210 , 8)),
				 16 => std_logic_vector(to_unsigned( 165 , 8)),
				 17 => std_logic_vector(to_unsigned( 100 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 849

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 116 , 8)),
				 1 => std_logic_vector(to_unsigned( 244 , 8)),
				 2 => std_logic_vector(to_unsigned( 119 , 8)),
				 3 => std_logic_vector(to_unsigned( 251 , 8)),
				 4 => std_logic_vector(to_unsigned( 112 , 8)),
				 5 => std_logic_vector(to_unsigned( 69 , 8)),
				 6 => std_logic_vector(to_unsigned( 158 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 196 , 8)),
				 10 => std_logic_vector(to_unsigned( 237 , 8)),
				 11 => std_logic_vector(to_unsigned( 228 , 8)),
				 12 => std_logic_vector(to_unsigned( 220 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 216 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 204 , 8)),
				 17 => std_logic_vector(to_unsigned( 59 , 8)),
				 18 => std_logic_vector(to_unsigned( 218 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 850

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 83 , 8)),
				 1 => std_logic_vector(to_unsigned( 130 , 8)),
				 2 => std_logic_vector(to_unsigned( 116 , 8)),
				 3 => std_logic_vector(to_unsigned( 151 , 8)),
				 4 => std_logic_vector(to_unsigned( 95 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 32 , 8)),
				 7 => std_logic_vector(to_unsigned( 150 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 157 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 160 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 62 , 8)),
				 14 => std_logic_vector(to_unsigned( 229 , 8)),
				 15 => std_logic_vector(to_unsigned( 163 , 8)),
				 16 => std_logic_vector(to_unsigned( 28 , 8)),
				 17 => std_logic_vector(to_unsigned( 228 , 8)),
				 18 => std_logic_vector(to_unsigned( 151 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 851

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 203 , 8)),
				 1 => std_logic_vector(to_unsigned( 230 , 8)),
				 2 => std_logic_vector(to_unsigned( 185 , 8)),
				 3 => std_logic_vector(to_unsigned( 234 , 8)),
				 4 => std_logic_vector(to_unsigned( 181 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 168 , 8)),
				 7 => std_logic_vector(to_unsigned( 234 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 238 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 242 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 243 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 243 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 230 , 8)),
				 18 => std_logic_vector(to_unsigned( 63 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 852

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 9 , 8)),
				 1 => std_logic_vector(to_unsigned( 145 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 84 , 8)),
				 4 => std_logic_vector(to_unsigned( 117 , 8)),
				 5 => std_logic_vector(to_unsigned( 158 , 8)),
				 6 => std_logic_vector(to_unsigned( 42 , 8)),
				 7 => std_logic_vector(to_unsigned( 183 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 191 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 199 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 51 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 853

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 108 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 128 , 8)),
				 3 => std_logic_vector(to_unsigned( 146 , 8)),
				 4 => std_logic_vector(to_unsigned( 212 , 8)),
				 5 => std_logic_vector(to_unsigned( 99 , 8)),
				 6 => std_logic_vector(to_unsigned( 230 , 8)),
				 7 => std_logic_vector(to_unsigned( 132 , 8)),
				 8 => std_logic_vector(to_unsigned( 43 , 8)),
				 9 => std_logic_vector(to_unsigned( 135 , 8)),
				 10 => std_logic_vector(to_unsigned( 40 , 8)),
				 11 => std_logic_vector(to_unsigned( 116 , 8)),
				 12 => std_logic_vector(to_unsigned( 10 , 8)),
				 13 => std_logic_vector(to_unsigned( 123 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 151 , 8)),
				 16 => std_logic_vector(to_unsigned( 92 , 8)),
				 17 => std_logic_vector(to_unsigned( 22 , 8)),
				 18 => std_logic_vector(to_unsigned( 35 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 854

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 136 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 112 , 8)),
				 4 => std_logic_vector(to_unsigned( 251 , 8)),
				 5 => std_logic_vector(to_unsigned( 157 , 8)),
				 6 => std_logic_vector(to_unsigned( 17 , 8)),
				 7 => std_logic_vector(to_unsigned( 101 , 8)),
				 8 => std_logic_vector(to_unsigned( 116 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 142 , 8)),
				 11 => std_logic_vector(to_unsigned( 78 , 8)),
				 12 => std_logic_vector(to_unsigned( 249 , 8)),
				 13 => std_logic_vector(to_unsigned( 79 , 8)),
				 14 => std_logic_vector(to_unsigned( 248 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 133 , 8)),
				 18 => std_logic_vector(to_unsigned( 226 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 855

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 251 , 8)),
				 1 => std_logic_vector(to_unsigned( 11 , 8)),
				 2 => std_logic_vector(to_unsigned( 61 , 8)),
				 3 => std_logic_vector(to_unsigned( 39 , 8)),
				 4 => std_logic_vector(to_unsigned( 33 , 8)),
				 5 => std_logic_vector(to_unsigned( 67 , 8)),
				 6 => std_logic_vector(to_unsigned( 72 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 22 , 8)),
				 9 => std_logic_vector(to_unsigned( 98 , 8)),
				 10 => std_logic_vector(to_unsigned( 121 , 8)),
				 11 => std_logic_vector(to_unsigned( 182 , 8)),
				 12 => std_logic_vector(to_unsigned( 37 , 8)),
				 13 => std_logic_vector(to_unsigned( 184 , 8)),
				 14 => std_logic_vector(to_unsigned( 35 , 8)),
				 15 => std_logic_vector(to_unsigned( 214 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 217 , 8)),
				 18 => std_logic_vector(to_unsigned( 249 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 240 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 856

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 246 , 8)),
				 1 => std_logic_vector(to_unsigned( 103 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 250 , 8)),
				 4 => std_logic_vector(to_unsigned( 25 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 196 , 8)),
				 7 => std_logic_vector(to_unsigned( 86 , 8)),
				 8 => std_logic_vector(to_unsigned( 153 , 8)),
				 9 => std_logic_vector(to_unsigned( 187 , 8)),
				 10 => std_logic_vector(to_unsigned( 96 , 8)),
				 11 => std_logic_vector(to_unsigned( 214 , 8)),
				 12 => std_logic_vector(to_unsigned( 69 , 8)),
				 13 => std_logic_vector(to_unsigned( 245 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 38 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 143 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 857

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 243 , 8)),
				 2 => std_logic_vector(to_unsigned( 230 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 227 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 200 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 198 , 8)),
				 9 => std_logic_vector(to_unsigned( 247 , 8)),
				 10 => std_logic_vector(to_unsigned( 195 , 8)),
				 11 => std_logic_vector(to_unsigned( 248 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 197 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 196 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 161 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 858

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 74 , 8)),
				 2 => std_logic_vector(to_unsigned( 139 , 8)),
				 3 => std_logic_vector(to_unsigned( 37 , 8)),
				 4 => std_logic_vector(to_unsigned( 236 , 8)),
				 5 => std_logic_vector(to_unsigned( 37 , 8)),
				 6 => std_logic_vector(to_unsigned( 244 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 165 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 162 , 8)),
				 11 => std_logic_vector(to_unsigned( 80 , 8)),
				 12 => std_logic_vector(to_unsigned( 110 , 8)),
				 13 => std_logic_vector(to_unsigned( 143 , 8)),
				 14 => std_logic_vector(to_unsigned( 47 , 8)),
				 15 => std_logic_vector(to_unsigned( 152 , 8)),
				 16 => std_logic_vector(to_unsigned( 163 , 8)),
				 17 => std_logic_vector(to_unsigned( 73 , 8)),
				 18 => std_logic_vector(to_unsigned( 126 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 859

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 140 , 8)),
				 1 => std_logic_vector(to_unsigned( 255 , 8)),
				 2 => std_logic_vector(to_unsigned( 207 , 8)),
				 3 => std_logic_vector(to_unsigned( 197 , 8)),
				 4 => std_logic_vector(to_unsigned( 233 , 8)),
				 5 => std_logic_vector(to_unsigned( 240 , 8)),
				 6 => std_logic_vector(to_unsigned( 190 , 8)),
				 7 => std_logic_vector(to_unsigned( 16 , 8)),
				 8 => std_logic_vector(to_unsigned( 75 , 8)),
				 9 => std_logic_vector(to_unsigned( 180 , 8)),
				 10 => std_logic_vector(to_unsigned( 127 , 8)),
				 11 => std_logic_vector(to_unsigned( 203 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 60 , 8)),
				 14 => std_logic_vector(to_unsigned( 241 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 210 , 8)),
				 17 => std_logic_vector(to_unsigned( 13 , 8)),
				 18 => std_logic_vector(to_unsigned( 168 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 860

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 162 , 8)),
				 1 => std_logic_vector(to_unsigned( 181 , 8)),
				 2 => std_logic_vector(to_unsigned( 248 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 151 , 8)),
				 5 => std_logic_vector(to_unsigned( 18 , 8)),
				 6 => std_logic_vector(to_unsigned( 112 , 8)),
				 7 => std_logic_vector(to_unsigned( 122 , 8)),
				 8 => std_logic_vector(to_unsigned( 115 , 8)),
				 9 => std_logic_vector(to_unsigned( 216 , 8)),
				 10 => std_logic_vector(to_unsigned( 186 , 8)),
				 11 => std_logic_vector(to_unsigned( 230 , 8)),
				 12 => std_logic_vector(to_unsigned( 172 , 8)),
				 13 => std_logic_vector(to_unsigned( 166 , 8)),
				 14 => std_logic_vector(to_unsigned( 216 , 8)),
				 15 => std_logic_vector(to_unsigned( 234 , 8)),
				 16 => std_logic_vector(to_unsigned( 148 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 179 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 861

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 97 , 8)),
				 1 => std_logic_vector(to_unsigned( 102 , 8)),
				 2 => std_logic_vector(to_unsigned( 120 , 8)),
				 3 => std_logic_vector(to_unsigned( 101 , 8)),
				 4 => std_logic_vector(to_unsigned( 105 , 8)),
				 5 => std_logic_vector(to_unsigned( 150 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 156 , 8)),
				 8 => std_logic_vector(to_unsigned( 50 , 8)),
				 9 => std_logic_vector(to_unsigned( 195 , 8)),
				 10 => std_logic_vector(to_unsigned( 11 , 8)),
				 11 => std_logic_vector(to_unsigned( 195 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 59 , 8)),
				 16 => std_logic_vector(to_unsigned( 175 , 8)),
				 17 => std_logic_vector(to_unsigned( 232 , 8)),
				 18 => std_logic_vector(to_unsigned( 14 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 862

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 99 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 212 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 20 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 191 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 149 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 146 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 863

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 140 , 8)),
				 1 => std_logic_vector(to_unsigned( 5 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 16 , 8)),
				 4 => std_logic_vector(to_unsigned( 249 , 8)),
				 5 => std_logic_vector(to_unsigned( 23 , 8)),
				 6 => std_logic_vector(to_unsigned( 197 , 8)),
				 7 => std_logic_vector(to_unsigned( 209 , 8)),
				 8 => std_logic_vector(to_unsigned( 93 , 8)),
				 9 => std_logic_vector(to_unsigned( 7 , 8)),
				 10 => std_logic_vector(to_unsigned( 53 , 8)),
				 11 => std_logic_vector(to_unsigned( 53 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 57 , 8)),
				 14 => std_logic_vector(to_unsigned( 3 , 8)),
				 15 => std_logic_vector(to_unsigned( 58 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 38 , 8)),
				 18 => std_logic_vector(to_unsigned( 222 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 864

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 37 , 8)),
				 1 => std_logic_vector(to_unsigned( 160 , 8)),
				 2 => std_logic_vector(to_unsigned( 33 , 8)),
				 3 => std_logic_vector(to_unsigned( 83 , 8)),
				 4 => std_logic_vector(to_unsigned( 186 , 8)),
				 5 => std_logic_vector(to_unsigned( 161 , 8)),
				 6 => std_logic_vector(to_unsigned( 188 , 8)),
				 7 => std_logic_vector(to_unsigned( 144 , 8)),
				 8 => std_logic_vector(to_unsigned( 64 , 8)),
				 9 => std_logic_vector(to_unsigned( 192 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 15 , 8)),
				 13 => std_logic_vector(to_unsigned( 194 , 8)),
				 14 => std_logic_vector(to_unsigned( 14 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 165 , 8)),
				 18 => std_logic_vector(to_unsigned( 99 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 865

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 78 , 8)),
				 1 => std_logic_vector(to_unsigned( 9 , 8)),
				 2 => std_logic_vector(to_unsigned( 252 , 8)),
				 3 => std_logic_vector(to_unsigned( 221 , 8)),
				 4 => std_logic_vector(to_unsigned( 211 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 181 , 8)),
				 7 => std_logic_vector(to_unsigned( 230 , 8)),
				 8 => std_logic_vector(to_unsigned( 157 , 8)),
				 9 => std_logic_vector(to_unsigned( 29 , 8)),
				 10 => std_logic_vector(to_unsigned( 85 , 8)),
				 11 => std_logic_vector(to_unsigned( 81 , 8)),
				 12 => std_logic_vector(to_unsigned( 7 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 79 , 8)),
				 15 => std_logic_vector(to_unsigned( 205 , 8)),
				 16 => std_logic_vector(to_unsigned( 34 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 249 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 866

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 134 , 8)),
				 2 => std_logic_vector(to_unsigned( 44 , 8)),
				 3 => std_logic_vector(to_unsigned( 148 , 8)),
				 4 => std_logic_vector(to_unsigned( 30 , 8)),
				 5 => std_logic_vector(to_unsigned( 70 , 8)),
				 6 => std_logic_vector(to_unsigned( 156 , 8)),
				 7 => std_logic_vector(to_unsigned( 73 , 8)),
				 8 => std_logic_vector(to_unsigned( 57 , 8)),
				 9 => std_logic_vector(to_unsigned( 103 , 8)),
				 10 => std_logic_vector(to_unsigned( 147 , 8)),
				 11 => std_logic_vector(to_unsigned( 159 , 8)),
				 12 => std_logic_vector(to_unsigned( 169 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 146 , 8)),
				 15 => std_logic_vector(to_unsigned( 222 , 8)),
				 16 => std_logic_vector(to_unsigned( 245 , 8)),
				 17 => std_logic_vector(to_unsigned( 213 , 8)),
				 18 => std_logic_vector(to_unsigned( 101 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 867

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 165 , 8)),
				 1 => std_logic_vector(to_unsigned( 228 , 8)),
				 2 => std_logic_vector(to_unsigned( 203 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 185 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 177 , 8)),
				 7 => std_logic_vector(to_unsigned( 136 , 8)),
				 8 => std_logic_vector(to_unsigned( 235 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 196 , 8)),
				 11 => std_logic_vector(to_unsigned( 213 , 8)),
				 12 => std_logic_vector(to_unsigned( 158 , 8)),
				 13 => std_logic_vector(to_unsigned( 148 , 8)),
				 14 => std_logic_vector(to_unsigned( 254 , 8)),
				 15 => std_logic_vector(to_unsigned( 196 , 8)),
				 16 => std_logic_vector(to_unsigned( 206 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 212 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 868

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 154 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 222 , 8)),
				 3 => std_logic_vector(to_unsigned( 100 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 117 , 8)),
				 8 => std_logic_vector(to_unsigned( 6 , 8)),
				 9 => std_logic_vector(to_unsigned( 116 , 8)),
				 10 => std_logic_vector(to_unsigned( 249 , 8)),
				 11 => std_logic_vector(to_unsigned( 228 , 8)),
				 12 => std_logic_vector(to_unsigned( 181 , 8)),
				 13 => std_logic_vector(to_unsigned( 237 , 8)),
				 14 => std_logic_vector(to_unsigned( 21 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 226 , 8)),
				 18 => std_logic_vector(to_unsigned( 196 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 869

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 2 , 8)),
				 2 => std_logic_vector(to_unsigned( 225 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 103 , 8)),
				 5 => std_logic_vector(to_unsigned( 133 , 8)),
				 6 => std_logic_vector(to_unsigned( 82 , 8)),
				 7 => std_logic_vector(to_unsigned( 162 , 8)),
				 8 => std_logic_vector(to_unsigned( 53 , 8)),
				 9 => std_logic_vector(to_unsigned( 175 , 8)),
				 10 => std_logic_vector(to_unsigned( 232 , 8)),
				 11 => std_logic_vector(to_unsigned( 18 , 8)),
				 12 => std_logic_vector(to_unsigned( 61 , 8)),
				 13 => std_logic_vector(to_unsigned( 71 , 8)),
				 14 => std_logic_vector(to_unsigned( 8 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 225 , 8)),
				 18 => std_logic_vector(to_unsigned( 175 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 870

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 116 , 8)),
				 1 => std_logic_vector(to_unsigned( 209 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 92 , 8)),
				 4 => std_logic_vector(to_unsigned( 116 , 8)),
				 5 => std_logic_vector(to_unsigned( 183 , 8)),
				 6 => std_logic_vector(to_unsigned( 56 , 8)),
				 7 => std_logic_vector(to_unsigned( 169 , 8)),
				 8 => std_logic_vector(to_unsigned( 138 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 237 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 237 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 237 , 8)),
				 17 => std_logic_vector(to_unsigned( 67 , 8)),
				 18 => std_logic_vector(to_unsigned( 86 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 871

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 16 , 8)),
				 1 => std_logic_vector(to_unsigned( 39 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 46 , 8)),
				 4 => std_logic_vector(to_unsigned( 149 , 8)),
				 5 => std_logic_vector(to_unsigned( 152 , 8)),
				 6 => std_logic_vector(to_unsigned( 43 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 102 , 8)),
				 10 => std_logic_vector(to_unsigned( 3 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 6 , 8)),
				 14 => std_logic_vector(to_unsigned( 239 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 160 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 872

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 195 , 8)),
				 1 => std_logic_vector(to_unsigned( 21 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 53 , 8)),
				 4 => std_logic_vector(to_unsigned( 64 , 8)),
				 5 => std_logic_vector(to_unsigned( 213 , 8)),
				 6 => std_logic_vector(to_unsigned( 178 , 8)),
				 7 => std_logic_vector(to_unsigned( 25 , 8)),
				 8 => std_logic_vector(to_unsigned( 255 , 8)),
				 9 => std_logic_vector(to_unsigned( 219 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 49 , 8)),
				 13 => std_logic_vector(to_unsigned( 236 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 41 , 8)),
				 17 => std_logic_vector(to_unsigned( 81 , 8)),
				 18 => std_logic_vector(to_unsigned( 132 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 3 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 873

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 108 , 8)),
				 1 => std_logic_vector(to_unsigned( 188 , 8)),
				 2 => std_logic_vector(to_unsigned( 38 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 229 , 8)),
				 5 => std_logic_vector(to_unsigned( 179 , 8)),
				 6 => std_logic_vector(to_unsigned( 86 , 8)),
				 7 => std_logic_vector(to_unsigned( 71 , 8)),
				 8 => std_logic_vector(to_unsigned( 58 , 8)),
				 9 => std_logic_vector(to_unsigned( 194 , 8)),
				 10 => std_logic_vector(to_unsigned( 0 , 8)),
				 11 => std_logic_vector(to_unsigned( 52 , 8)),
				 12 => std_logic_vector(to_unsigned( 141 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 108 , 8)),
				 15 => std_logic_vector(to_unsigned( 230 , 8)),
				 16 => std_logic_vector(to_unsigned( 71 , 8)),
				 17 => std_logic_vector(to_unsigned( 221 , 8)),
				 18 => std_logic_vector(to_unsigned( 246 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 874

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 198 , 8)),
				 1 => std_logic_vector(to_unsigned( 6 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 74 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 132 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 162 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 135 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 104 , 8)),
				 14 => std_logic_vector(to_unsigned( 165 , 8)),
				 15 => std_logic_vector(to_unsigned( 22 , 8)),
				 16 => std_logic_vector(to_unsigned( 46 , 8)),
				 17 => std_logic_vector(to_unsigned( 172 , 8)),
				 18 => std_logic_vector(to_unsigned( 167 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 875

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 85 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 66 , 8)),
				 3 => std_logic_vector(to_unsigned( 36 , 8)),
				 4 => std_logic_vector(to_unsigned( 160 , 8)),
				 5 => std_logic_vector(to_unsigned( 251 , 8)),
				 6 => std_logic_vector(to_unsigned( 208 , 8)),
				 7 => std_logic_vector(to_unsigned( 54 , 8)),
				 8 => std_logic_vector(to_unsigned( 109 , 8)),
				 9 => std_logic_vector(to_unsigned( 72 , 8)),
				 10 => std_logic_vector(to_unsigned( 6 , 8)),
				 11 => std_logic_vector(to_unsigned( 73 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 73 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 19 , 8)),
				 16 => std_logic_vector(to_unsigned( 230 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 203 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 876

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 251 , 8)),
				 1 => std_logic_vector(to_unsigned( 74 , 8)),
				 2 => std_logic_vector(to_unsigned( 236 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 108 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 65 , 8)),
				 7 => std_logic_vector(to_unsigned( 42 , 8)),
				 8 => std_logic_vector(to_unsigned( 231 , 8)),
				 9 => std_logic_vector(to_unsigned( 164 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 61 , 8)),
				 12 => std_logic_vector(to_unsigned( 124 , 8)),
				 13 => std_logic_vector(to_unsigned( 23 , 8)),
				 14 => std_logic_vector(to_unsigned( 223 , 8)),
				 15 => std_logic_vector(to_unsigned( 136 , 8)),
				 16 => std_logic_vector(to_unsigned( 110 , 8)),
				 17 => std_logic_vector(to_unsigned( 30 , 8)),
				 18 => std_logic_vector(to_unsigned( 110 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 877

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 35 , 8)),
				 1 => std_logic_vector(to_unsigned( 125 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 132 , 8)),
				 4 => std_logic_vector(to_unsigned( 222 , 8)),
				 5 => std_logic_vector(to_unsigned( 204 , 8)),
				 6 => std_logic_vector(to_unsigned( 150 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 142 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 110 , 8)),
				 11 => std_logic_vector(to_unsigned( 75 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 239 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 119 , 8)),
				 16 => std_logic_vector(to_unsigned( 35 , 8)),
				 17 => std_logic_vector(to_unsigned( 71 , 8)),
				 18 => std_logic_vector(to_unsigned( 122 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 878

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 106 , 8)),
				 1 => std_logic_vector(to_unsigned( 249 , 8)),
				 2 => std_logic_vector(to_unsigned( 54 , 8)),
				 3 => std_logic_vector(to_unsigned( 252 , 8)),
				 4 => std_logic_vector(to_unsigned( 51 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 164 , 8)),
				 8 => std_logic_vector(to_unsigned( 143 , 8)),
				 9 => std_logic_vector(to_unsigned( 20 , 8)),
				 10 => std_logic_vector(to_unsigned( 112 , 8)),
				 11 => std_logic_vector(to_unsigned( 130 , 8)),
				 12 => std_logic_vector(to_unsigned( 32 , 8)),
				 13 => std_logic_vector(to_unsigned( 59 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 68 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 60 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 879

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 41 , 8)),
				 1 => std_logic_vector(to_unsigned( 167 , 8)),
				 2 => std_logic_vector(to_unsigned( 43 , 8)),
				 3 => std_logic_vector(to_unsigned( 179 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 105 , 8)),
				 8 => std_logic_vector(to_unsigned( 169 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 41 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 68 , 8)),
				 13 => std_logic_vector(to_unsigned( 185 , 8)),
				 14 => std_logic_vector(to_unsigned( 253 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 242 , 8)),
				 18 => std_logic_vector(to_unsigned( 74 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 880

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 52 , 8)),
				 3 => std_logic_vector(to_unsigned( 89 , 8)),
				 4 => std_logic_vector(to_unsigned( 168 , 8)),
				 5 => std_logic_vector(to_unsigned( 118 , 8)),
				 6 => std_logic_vector(to_unsigned( 139 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 17 , 8)),
				 9 => std_logic_vector(to_unsigned( 248 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 11 , 8)),
				 12 => std_logic_vector(to_unsigned( 113 , 8)),
				 13 => std_logic_vector(to_unsigned( 17 , 8)),
				 14 => std_logic_vector(to_unsigned( 107 , 8)),
				 15 => std_logic_vector(to_unsigned( 75 , 8)),
				 16 => std_logic_vector(to_unsigned( 49 , 8)),
				 17 => std_logic_vector(to_unsigned( 243 , 8)),
				 18 => std_logic_vector(to_unsigned( 194 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 6 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 881

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 87 , 8)),
				 1 => std_logic_vector(to_unsigned( 176 , 8)),
				 2 => std_logic_vector(to_unsigned( 39 , 8)),
				 3 => std_logic_vector(to_unsigned( 168 , 8)),
				 4 => std_logic_vector(to_unsigned( 148 , 8)),
				 5 => std_logic_vector(to_unsigned( 28 , 8)),
				 6 => std_logic_vector(to_unsigned( 218 , 8)),
				 7 => std_logic_vector(to_unsigned( 97 , 8)),
				 8 => std_logic_vector(to_unsigned( 149 , 8)),
				 9 => std_logic_vector(to_unsigned( 211 , 8)),
				 10 => std_logic_vector(to_unsigned( 35 , 8)),
				 11 => std_logic_vector(to_unsigned( 31 , 8)),
				 12 => std_logic_vector(to_unsigned( 178 , 8)),
				 13 => std_logic_vector(to_unsigned( 144 , 8)),
				 14 => std_logic_vector(to_unsigned( 65 , 8)),
				 15 => std_logic_vector(to_unsigned( 169 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 219 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 882

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 66 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 102 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 31 , 8)),
				 5 => std_logic_vector(to_unsigned( 126 , 8)),
				 6 => std_logic_vector(to_unsigned( 29 , 8)),
				 7 => std_logic_vector(to_unsigned( 196 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 239 , 8)),
				 10 => std_logic_vector(to_unsigned( 167 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 186 , 8)),
				 13 => std_logic_vector(to_unsigned( 247 , 8)),
				 14 => std_logic_vector(to_unsigned( 155 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 147 , 8)),
				 17 => std_logic_vector(to_unsigned( 93 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 883

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 61 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 150 , 8)),
				 3 => std_logic_vector(to_unsigned( 169 , 8)),
				 4 => std_logic_vector(to_unsigned( 128 , 8)),
				 5 => std_logic_vector(to_unsigned( 193 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 21 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 173 , 8)),
				 11 => std_logic_vector(to_unsigned( 164 , 8)),
				 12 => std_logic_vector(to_unsigned( 183 , 8)),
				 13 => std_logic_vector(to_unsigned( 198 , 8)),
				 14 => std_logic_vector(to_unsigned( 149 , 8)),
				 15 => std_logic_vector(to_unsigned( 228 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 189 , 8)),
				 18 => std_logic_vector(to_unsigned( 233 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 884

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 207 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 177 , 8)),
				 4 => std_logic_vector(to_unsigned( 47 , 8)),
				 5 => std_logic_vector(to_unsigned( 67 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 96 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 86 , 8)),
				 10 => std_logic_vector(to_unsigned( 100 , 8)),
				 11 => std_logic_vector(to_unsigned( 152 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 153 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 35 , 8)),
				 18 => std_logic_vector(to_unsigned( 208 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 885

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 188 , 8)),
				 1 => std_logic_vector(to_unsigned( 86 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 228 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 4 , 8)),
				 6 => std_logic_vector(to_unsigned( 212 , 8)),
				 7 => std_logic_vector(to_unsigned( 121 , 8)),
				 8 => std_logic_vector(to_unsigned( 95 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 25 , 8)),
				 11 => std_logic_vector(to_unsigned( 132 , 8)),
				 12 => std_logic_vector(to_unsigned( 84 , 8)),
				 13 => std_logic_vector(to_unsigned( 174 , 8)),
				 14 => std_logic_vector(to_unsigned( 42 , 8)),
				 15 => std_logic_vector(to_unsigned( 187 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 152 , 8)),
				 18 => std_logic_vector(to_unsigned( 186 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 40 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 886

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 151 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 252 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 182 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 45 , 8)),
				 8 => std_logic_vector(to_unsigned( 189 , 8)),
				 9 => std_logic_vector(to_unsigned( 178 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 200 , 8)),
				 12 => std_logic_vector(to_unsigned( 34 , 8)),
				 13 => std_logic_vector(to_unsigned( 140 , 8)),
				 14 => std_logic_vector(to_unsigned( 252 , 8)),
				 15 => std_logic_vector(to_unsigned( 107 , 8)),
				 16 => std_logic_vector(to_unsigned( 167 , 8)),
				 17 => std_logic_vector(to_unsigned( 229 , 8)),
				 18 => std_logic_vector(to_unsigned( 214 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 887

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 29 , 8)),
				 1 => std_logic_vector(to_unsigned( 199 , 8)),
				 2 => std_logic_vector(to_unsigned( 22 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 19 , 8)),
				 5 => std_logic_vector(to_unsigned( 100 , 8)),
				 6 => std_logic_vector(to_unsigned( 129 , 8)),
				 7 => std_logic_vector(to_unsigned( 183 , 8)),
				 8 => std_logic_vector(to_unsigned( 46 , 8)),
				 9 => std_logic_vector(to_unsigned( 193 , 8)),
				 10 => std_logic_vector(to_unsigned( 36 , 8)),
				 11 => std_logic_vector(to_unsigned( 111 , 8)),
				 12 => std_logic_vector(to_unsigned( 242 , 8)),
				 13 => std_logic_vector(to_unsigned( 99 , 8)),
				 14 => std_logic_vector(to_unsigned( 140 , 8)),
				 15 => std_logic_vector(to_unsigned( 173 , 8)),
				 16 => std_logic_vector(to_unsigned( 66 , 8)),
				 17 => std_logic_vector(to_unsigned( 231 , 8)),
				 18 => std_logic_vector(to_unsigned( 104 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 888

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 71 , 8)),
				 1 => std_logic_vector(to_unsigned( 173 , 8)),
				 2 => std_logic_vector(to_unsigned( 38 , 8)),
				 3 => std_logic_vector(to_unsigned( 207 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 204 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 201 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 198 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 197 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 197 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 197 , 8)),
				 17 => std_logic_vector(to_unsigned( 193 , 8)),
				 18 => std_logic_vector(to_unsigned( 27 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 889

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 154 , 8)),
				 1 => std_logic_vector(to_unsigned( 30 , 8)),
				 2 => std_logic_vector(to_unsigned( 149 , 8)),
				 3 => std_logic_vector(to_unsigned( 72 , 8)),
				 4 => std_logic_vector(to_unsigned( 87 , 8)),
				 5 => std_logic_vector(to_unsigned( 101 , 8)),
				 6 => std_logic_vector(to_unsigned( 69 , 8)),
				 7 => std_logic_vector(to_unsigned( 213 , 8)),
				 8 => std_logic_vector(to_unsigned( 234 , 8)),
				 9 => std_logic_vector(to_unsigned( 216 , 8)),
				 10 => std_logic_vector(to_unsigned( 231 , 8)),
				 11 => std_logic_vector(to_unsigned( 217 , 8)),
				 12 => std_logic_vector(to_unsigned( 230 , 8)),
				 13 => std_logic_vector(to_unsigned( 192 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 239 , 8)),
				 16 => std_logic_vector(to_unsigned( 55 , 8)),
				 17 => std_logic_vector(to_unsigned( 175 , 8)),
				 18 => std_logic_vector(to_unsigned( 167 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 24 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 890

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 189 , 8)),
				 1 => std_logic_vector(to_unsigned( 4 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 31 , 8)),
				 4 => std_logic_vector(to_unsigned( 173 , 8)),
				 5 => std_logic_vector(to_unsigned( 79 , 8)),
				 6 => std_logic_vector(to_unsigned( 125 , 8)),
				 7 => std_logic_vector(to_unsigned( 201 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 15 , 8)),
				 10 => std_logic_vector(to_unsigned( 54 , 8)),
				 11 => std_logic_vector(to_unsigned( 19 , 8)),
				 12 => std_logic_vector(to_unsigned( 185 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 44 , 8)),
				 15 => std_logic_vector(to_unsigned( 186 , 8)),
				 16 => std_logic_vector(to_unsigned( 154 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 35 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 891

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 134 , 8)),
				 2 => std_logic_vector(to_unsigned( 42 , 8)),
				 3 => std_logic_vector(to_unsigned( 153 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 43 , 8)),
				 6 => std_logic_vector(to_unsigned( 176 , 8)),
				 7 => std_logic_vector(to_unsigned( 4 , 8)),
				 8 => std_logic_vector(to_unsigned( 159 , 8)),
				 9 => std_logic_vector(to_unsigned( 12 , 8)),
				 10 => std_logic_vector(to_unsigned( 220 , 8)),
				 11 => std_logic_vector(to_unsigned( 25 , 8)),
				 12 => std_logic_vector(to_unsigned( 207 , 8)),
				 13 => std_logic_vector(to_unsigned( 225 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 85 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 205 , 8)),
				 18 => std_logic_vector(to_unsigned( 197 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 892

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 201 , 8)),
				 1 => std_logic_vector(to_unsigned( 219 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 177 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 165 , 8)),
				 7 => std_logic_vector(to_unsigned( 155 , 8)),
				 8 => std_logic_vector(to_unsigned( 242 , 8)),
				 9 => std_logic_vector(to_unsigned( 207 , 8)),
				 10 => std_logic_vector(to_unsigned( 143 , 8)),
				 11 => std_logic_vector(to_unsigned( 212 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 217 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 101 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 110 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 893

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 38 , 8)),
				 2 => std_logic_vector(to_unsigned( 194 , 8)),
				 3 => std_logic_vector(to_unsigned( 173 , 8)),
				 4 => std_logic_vector(to_unsigned( 59 , 8)),
				 5 => std_logic_vector(to_unsigned( 210 , 8)),
				 6 => std_logic_vector(to_unsigned( 22 , 8)),
				 7 => std_logic_vector(to_unsigned( 174 , 8)),
				 8 => std_logic_vector(to_unsigned( 247 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 188 , 8)),
				 11 => std_logic_vector(to_unsigned( 235 , 8)),
				 12 => std_logic_vector(to_unsigned( 186 , 8)),
				 13 => std_logic_vector(to_unsigned( 67 , 8)),
				 14 => std_logic_vector(to_unsigned( 199 , 8)),
				 15 => std_logic_vector(to_unsigned( 89 , 8)),
				 16 => std_logic_vector(to_unsigned( 177 , 8)),
				 17 => std_logic_vector(to_unsigned( 190 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 894

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 99 , 8)),
				 1 => std_logic_vector(to_unsigned( 173 , 8)),
				 2 => std_logic_vector(to_unsigned( 0 , 8)),
				 3 => std_logic_vector(to_unsigned( 101 , 8)),
				 4 => std_logic_vector(to_unsigned( 122 , 8)),
				 5 => std_logic_vector(to_unsigned( 36 , 8)),
				 6 => std_logic_vector(to_unsigned( 207 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 48 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 82 , 8)),
				 12 => std_logic_vector(to_unsigned( 86 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 250 , 8)),
				 15 => std_logic_vector(to_unsigned( 182 , 8)),
				 16 => std_logic_vector(to_unsigned( 244 , 8)),
				 17 => std_logic_vector(to_unsigned( 161 , 8)),
				 18 => std_logic_vector(to_unsigned( 191 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 895

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 6 , 8)),
				 1 => std_logic_vector(to_unsigned( 91 , 8)),
				 2 => std_logic_vector(to_unsigned( 206 , 8)),
				 3 => std_logic_vector(to_unsigned( 238 , 8)),
				 4 => std_logic_vector(to_unsigned( 86 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 71 , 8)),
				 9 => std_logic_vector(to_unsigned( 10 , 8)),
				 10 => std_logic_vector(to_unsigned( 52 , 8)),
				 11 => std_logic_vector(to_unsigned( 58 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 61 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 228 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 86 , 8)),
				 18 => std_logic_vector(to_unsigned( 159 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 896

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 173 , 8)),
				 1 => std_logic_vector(to_unsigned( 222 , 8)),
				 2 => std_logic_vector(to_unsigned( 47 , 8)),
				 3 => std_logic_vector(to_unsigned( 136 , 8)),
				 4 => std_logic_vector(to_unsigned( 13 , 8)),
				 5 => std_logic_vector(to_unsigned( 141 , 8)),
				 6 => std_logic_vector(to_unsigned( 8 , 8)),
				 7 => std_logic_vector(to_unsigned( 138 , 8)),
				 8 => std_logic_vector(to_unsigned( 236 , 8)),
				 9 => std_logic_vector(to_unsigned( 242 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 245 , 8)),
				 12 => std_logic_vector(to_unsigned( 129 , 8)),
				 13 => std_logic_vector(to_unsigned( 249 , 8)),
				 14 => std_logic_vector(to_unsigned( 125 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 157 , 8)),
				 18 => std_logic_vector(to_unsigned( 111 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 160 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 897

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 163 , 8)),
				 2 => std_logic_vector(to_unsigned( 9 , 8)),
				 3 => std_logic_vector(to_unsigned( 167 , 8)),
				 4 => std_logic_vector(to_unsigned( 5 , 8)),
				 5 => std_logic_vector(to_unsigned( 168 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 169 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 171 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 64 , 8)),
				 12 => std_logic_vector(to_unsigned( 141 , 8)),
				 13 => std_logic_vector(to_unsigned( 2 , 8)),
				 14 => std_logic_vector(to_unsigned( 181 , 8)),
				 15 => std_logic_vector(to_unsigned( 69 , 8)),
				 16 => std_logic_vector(to_unsigned( 114 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 117 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 898

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 51 , 8)),
				 1 => std_logic_vector(to_unsigned( 177 , 8)),
				 2 => std_logic_vector(to_unsigned( 34 , 8)),
				 3 => std_logic_vector(to_unsigned( 199 , 8)),
				 4 => std_logic_vector(to_unsigned( 12 , 8)),
				 5 => std_logic_vector(to_unsigned( 42 , 8)),
				 6 => std_logic_vector(to_unsigned( 84 , 8)),
				 7 => std_logic_vector(to_unsigned( 229 , 8)),
				 8 => std_logic_vector(to_unsigned( 61 , 8)),
				 9 => std_logic_vector(to_unsigned( 50 , 8)),
				 10 => std_logic_vector(to_unsigned( 48 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 18 , 8)),
				 13 => std_logic_vector(to_unsigned( 62 , 8)),
				 14 => std_logic_vector(to_unsigned( 218 , 8)),
				 15 => std_logic_vector(to_unsigned( 73 , 8)),
				 16 => std_logic_vector(to_unsigned( 207 , 8)),
				 17 => std_logic_vector(to_unsigned( 46 , 8)),
				 18 => std_logic_vector(to_unsigned( 2 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 899

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 32 , 8)),
				 1 => std_logic_vector(to_unsigned( 203 , 8)),
				 2 => std_logic_vector(to_unsigned( 57 , 8)),
				 3 => std_logic_vector(to_unsigned( 172 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 189 , 8)),
				 6 => std_logic_vector(to_unsigned( 144 , 8)),
				 7 => std_logic_vector(to_unsigned( 195 , 8)),
				 8 => std_logic_vector(to_unsigned( 102 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 23 , 8)),
				 11 => std_logic_vector(to_unsigned( 89 , 8)),
				 12 => std_logic_vector(to_unsigned( 9 , 8)),
				 13 => std_logic_vector(to_unsigned( 97 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 97 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 82 , 8)),
				 18 => std_logic_vector(to_unsigned( 71 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 900

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 223 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 102 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 170 , 8)),
				 6 => std_logic_vector(to_unsigned( 60 , 8)),
				 7 => std_logic_vector(to_unsigned( 238 , 8)),
				 8 => std_logic_vector(to_unsigned( 243 , 8)),
				 9 => std_logic_vector(to_unsigned( 246 , 8)),
				 10 => std_logic_vector(to_unsigned( 235 , 8)),
				 11 => std_logic_vector(to_unsigned( 179 , 8)),
				 12 => std_logic_vector(to_unsigned( 23 , 8)),
				 13 => std_logic_vector(to_unsigned( 193 , 8)),
				 14 => std_logic_vector(to_unsigned( 9 , 8)),
				 15 => std_logic_vector(to_unsigned( 195 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 51 , 8)),
				 18 => std_logic_vector(to_unsigned( 77 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 901

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 219 , 8)),
				 1 => std_logic_vector(to_unsigned( 13 , 8)),
				 2 => std_logic_vector(to_unsigned( 82 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 128 , 8)),
				 5 => std_logic_vector(to_unsigned( 71 , 8)),
				 6 => std_logic_vector(to_unsigned( 119 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 80 , 8)),
				 9 => std_logic_vector(to_unsigned( 127 , 8)),
				 10 => std_logic_vector(to_unsigned( 166 , 8)),
				 11 => std_logic_vector(to_unsigned( 156 , 8)),
				 12 => std_logic_vector(to_unsigned( 137 , 8)),
				 13 => std_logic_vector(to_unsigned( 196 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 196 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 65 , 8)),
				 18 => std_logic_vector(to_unsigned( 127 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 902

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 125 , 8)),
				 1 => std_logic_vector(to_unsigned( 7 , 8)),
				 2 => std_logic_vector(to_unsigned( 73 , 8)),
				 3 => std_logic_vector(to_unsigned( 54 , 8)),
				 4 => std_logic_vector(to_unsigned( 26 , 8)),
				 5 => std_logic_vector(to_unsigned( 21 , 8)),
				 6 => std_logic_vector(to_unsigned( 132 , 8)),
				 7 => std_logic_vector(to_unsigned( 119 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 119 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 119 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 93 , 8)),
				 14 => std_logic_vector(to_unsigned( 214 , 8)),
				 15 => std_logic_vector(to_unsigned( 130 , 8)),
				 16 => std_logic_vector(to_unsigned( 177 , 8)),
				 17 => std_logic_vector(to_unsigned( 45 , 8)),
				 18 => std_logic_vector(to_unsigned( 141 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 903

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 192 , 8)),
				 1 => std_logic_vector(to_unsigned( 177 , 8)),
				 2 => std_logic_vector(to_unsigned( 0 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 67 , 8)),
				 5 => std_logic_vector(to_unsigned( 205 , 8)),
				 6 => std_logic_vector(to_unsigned( 142 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 23 , 8)),
				 9 => std_logic_vector(to_unsigned( 146 , 8)),
				 10 => std_logic_vector(to_unsigned( 44 , 8)),
				 11 => std_logic_vector(to_unsigned( 146 , 8)),
				 12 => std_logic_vector(to_unsigned( 182 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 165 , 8)),
				 15 => std_logic_vector(to_unsigned( 132 , 8)),
				 16 => std_logic_vector(to_unsigned( 210 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 17 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 904

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 8 , 8)),
				 1 => std_logic_vector(to_unsigned( 188 , 8)),
				 2 => std_logic_vector(to_unsigned( 17 , 8)),
				 3 => std_logic_vector(to_unsigned( 216 , 8)),
				 4 => std_logic_vector(to_unsigned( 105 , 8)),
				 5 => std_logic_vector(to_unsigned( 243 , 8)),
				 6 => std_logic_vector(to_unsigned( 211 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 200 , 8)),
				 9 => std_logic_vector(to_unsigned( 116 , 8)),
				 10 => std_logic_vector(to_unsigned( 139 , 8)),
				 11 => std_logic_vector(to_unsigned( 124 , 8)),
				 12 => std_logic_vector(to_unsigned( 18 , 8)),
				 13 => std_logic_vector(to_unsigned( 131 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 133 , 8)),
				 16 => std_logic_vector(to_unsigned( 9 , 8)),
				 17 => std_logic_vector(to_unsigned( 102 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 905

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 217 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 202 , 8)),
				 5 => std_logic_vector(to_unsigned( 242 , 8)),
				 6 => std_logic_vector(to_unsigned( 200 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 195 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 193 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 193 , 8)),
				 13 => std_logic_vector(to_unsigned( 87 , 8)),
				 14 => std_logic_vector(to_unsigned( 39 , 8)),
				 15 => std_logic_vector(to_unsigned( 237 , 8)),
				 16 => std_logic_vector(to_unsigned( 68 , 8)),
				 17 => std_logic_vector(to_unsigned( 201 , 8)),
				 18 => std_logic_vector(to_unsigned( 188 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 25 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 906

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 69 , 8)),
				 1 => std_logic_vector(to_unsigned( 33 , 8)),
				 2 => std_logic_vector(to_unsigned( 254 , 8)),
				 3 => std_logic_vector(to_unsigned( 169 , 8)),
				 4 => std_logic_vector(to_unsigned( 118 , 8)),
				 5 => std_logic_vector(to_unsigned( 151 , 8)),
				 6 => std_logic_vector(to_unsigned( 19 , 8)),
				 7 => std_logic_vector(to_unsigned( 115 , 8)),
				 8 => std_logic_vector(to_unsigned( 215 , 8)),
				 9 => std_logic_vector(to_unsigned( 61 , 8)),
				 10 => std_logic_vector(to_unsigned( 143 , 8)),
				 11 => std_logic_vector(to_unsigned( 177 , 8)),
				 12 => std_logic_vector(to_unsigned( 27 , 8)),
				 13 => std_logic_vector(to_unsigned( 15 , 8)),
				 14 => std_logic_vector(to_unsigned( 255 , 8)),
				 15 => std_logic_vector(to_unsigned( 106 , 8)),
				 16 => std_logic_vector(to_unsigned( 164 , 8)),
				 17 => std_logic_vector(to_unsigned( 218 , 8)),
				 18 => std_logic_vector(to_unsigned( 162 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 907

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 42 , 8)),
				 1 => std_logic_vector(to_unsigned( 225 , 8)),
				 2 => std_logic_vector(to_unsigned( 215 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 215 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 199 , 8)),
				 7 => std_logic_vector(to_unsigned( 244 , 8)),
				 8 => std_logic_vector(to_unsigned( 196 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 191 , 8)),
				 11 => std_logic_vector(to_unsigned( 26 , 8)),
				 12 => std_logic_vector(to_unsigned( 140 , 8)),
				 13 => std_logic_vector(to_unsigned( 56 , 8)),
				 14 => std_logic_vector(to_unsigned( 34 , 8)),
				 15 => std_logic_vector(to_unsigned( 72 , 8)),
				 16 => std_logic_vector(to_unsigned( 18 , 8)),
				 17 => std_logic_vector(to_unsigned( 238 , 8)),
				 18 => std_logic_vector(to_unsigned( 199 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 908

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 36 , 8)),
				 1 => std_logic_vector(to_unsigned( 63 , 8)),
				 2 => std_logic_vector(to_unsigned( 221 , 8)),
				 3 => std_logic_vector(to_unsigned( 92 , 8)),
				 4 => std_logic_vector(to_unsigned( 192 , 8)),
				 5 => std_logic_vector(to_unsigned( 213 , 8)),
				 6 => std_logic_vector(to_unsigned( 71 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 32 , 8)),
				 9 => std_logic_vector(to_unsigned( 57 , 8)),
				 10 => std_logic_vector(to_unsigned( 173 , 8)),
				 11 => std_logic_vector(to_unsigned( 129 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 200 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 204 , 8)),
				 16 => std_logic_vector(to_unsigned( 92 , 8)),
				 17 => std_logic_vector(to_unsigned( 200 , 8)),
				 18 => std_logic_vector(to_unsigned( 82 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 909

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 221 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 230 , 8)),
				 4 => std_logic_vector(to_unsigned( 240 , 8)),
				 5 => std_logic_vector(to_unsigned( 245 , 8)),
				 6 => std_logic_vector(to_unsigned( 225 , 8)),
				 7 => std_logic_vector(to_unsigned( 153 , 8)),
				 8 => std_logic_vector(to_unsigned( 69 , 8)),
				 9 => std_logic_vector(to_unsigned( 47 , 8)),
				 10 => std_logic_vector(to_unsigned( 170 , 8)),
				 11 => std_logic_vector(to_unsigned( 87 , 8)),
				 12 => std_logic_vector(to_unsigned( 130 , 8)),
				 13 => std_logic_vector(to_unsigned( 117 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 178 , 8)),
				 16 => std_logic_vector(to_unsigned( 128 , 8)),
				 17 => std_logic_vector(to_unsigned( 119 , 8)),
				 18 => std_logic_vector(to_unsigned( 12 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 910

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 71 , 8)),
				 1 => std_logic_vector(to_unsigned( 101 , 8)),
				 2 => std_logic_vector(to_unsigned( 146 , 8)),
				 3 => std_logic_vector(to_unsigned( 154 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 128 , 8)),
				 8 => std_logic_vector(to_unsigned( 218 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 60 , 8)),
				 11 => std_logic_vector(to_unsigned( 174 , 8)),
				 12 => std_logic_vector(to_unsigned( 27 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 174 , 8)),
				 15 => std_logic_vector(to_unsigned( 196 , 8)),
				 16 => std_logic_vector(to_unsigned( 29 , 8)),
				 17 => std_logic_vector(to_unsigned( 101 , 8)),
				 18 => std_logic_vector(to_unsigned( 189 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 911

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 68 , 8)),
				 1 => std_logic_vector(to_unsigned( 172 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 207 , 8)),
				 4 => std_logic_vector(to_unsigned( 61 , 8)),
				 5 => std_logic_vector(to_unsigned( 226 , 8)),
				 6 => std_logic_vector(to_unsigned( 42 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 16 , 8)),
				 9 => std_logic_vector(to_unsigned( 252 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 137 , 8)),
				 12 => std_logic_vector(to_unsigned( 253 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 182 , 8)),
				 15 => std_logic_vector(to_unsigned( 173 , 8)),
				 16 => std_logic_vector(to_unsigned( 129 , 8)),
				 17 => std_logic_vector(to_unsigned( 109 , 8)),
				 18 => std_logic_vector(to_unsigned( 228 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 912

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 61 , 8)),
				 1 => std_logic_vector(to_unsigned( 143 , 8)),
				 2 => std_logic_vector(to_unsigned( 155 , 8)),
				 3 => std_logic_vector(to_unsigned( 211 , 8)),
				 4 => std_logic_vector(to_unsigned( 87 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 122 , 8)),
				 8 => std_logic_vector(to_unsigned( 69 , 8)),
				 9 => std_logic_vector(to_unsigned( 143 , 8)),
				 10 => std_logic_vector(to_unsigned( 38 , 8)),
				 11 => std_logic_vector(to_unsigned( 208 , 8)),
				 12 => std_logic_vector(to_unsigned( 103 , 8)),
				 13 => std_logic_vector(to_unsigned( 210 , 8)),
				 14 => std_logic_vector(to_unsigned( 234 , 8)),
				 15 => std_logic_vector(to_unsigned( 42 , 8)),
				 16 => std_logic_vector(to_unsigned( 232 , 8)),
				 17 => std_logic_vector(to_unsigned( 120 , 8)),
				 18 => std_logic_vector(to_unsigned( 21 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 913

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 228 , 8)),
				 1 => std_logic_vector(to_unsigned( 237 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 36 , 8)),
				 4 => std_logic_vector(to_unsigned( 15 , 8)),
				 5 => std_logic_vector(to_unsigned( 19 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 34 , 8)),
				 8 => std_logic_vector(to_unsigned( 122 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 123 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 122 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 249 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 69 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 200 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 914

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 51 , 8)),
				 2 => std_logic_vector(to_unsigned( 56 , 8)),
				 3 => std_logic_vector(to_unsigned( 69 , 8)),
				 4 => std_logic_vector(to_unsigned( 101 , 8)),
				 5 => std_logic_vector(to_unsigned( 79 , 8)),
				 6 => std_logic_vector(to_unsigned( 91 , 8)),
				 7 => std_logic_vector(to_unsigned( 167 , 8)),
				 8 => std_logic_vector(to_unsigned( 187 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 130 , 8)),
				 11 => std_logic_vector(to_unsigned( 241 , 8)),
				 12 => std_logic_vector(to_unsigned( 113 , 8)),
				 13 => std_logic_vector(to_unsigned( 88 , 8)),
				 14 => std_logic_vector(to_unsigned( 183 , 8)),
				 15 => std_logic_vector(to_unsigned( 121 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 103 , 8)),
				 18 => std_logic_vector(to_unsigned( 182 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 915

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 230 , 8)),
				 1 => std_logic_vector(to_unsigned( 117 , 8)),
				 2 => std_logic_vector(to_unsigned( 58 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 122 , 8)),
				 6 => std_logic_vector(to_unsigned( 141 , 8)),
				 7 => std_logic_vector(to_unsigned( 193 , 8)),
				 8 => std_logic_vector(to_unsigned( 70 , 8)),
				 9 => std_logic_vector(to_unsigned( 210 , 8)),
				 10 => std_logic_vector(to_unsigned( 53 , 8)),
				 11 => std_logic_vector(to_unsigned( 226 , 8)),
				 12 => std_logic_vector(to_unsigned( 37 , 8)),
				 13 => std_logic_vector(to_unsigned( 230 , 8)),
				 14 => std_logic_vector(to_unsigned( 33 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 10 , 8)),
				 17 => std_logic_vector(to_unsigned( 203 , 8)),
				 18 => std_logic_vector(to_unsigned( 22 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 916

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 221 , 8)),
				 1 => std_logic_vector(to_unsigned( 230 , 8)),
				 2 => std_logic_vector(to_unsigned( 78 , 8)),
				 3 => std_logic_vector(to_unsigned( 173 , 8)),
				 4 => std_logic_vector(to_unsigned( 162 , 8)),
				 5 => std_logic_vector(to_unsigned( 188 , 8)),
				 6 => std_logic_vector(to_unsigned( 147 , 8)),
				 7 => std_logic_vector(to_unsigned( 216 , 8)),
				 8 => std_logic_vector(to_unsigned( 119 , 8)),
				 9 => std_logic_vector(to_unsigned( 104 , 8)),
				 10 => std_logic_vector(to_unsigned( 83 , 8)),
				 11 => std_logic_vector(to_unsigned( 139 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 222 , 8)),
				 14 => std_logic_vector(to_unsigned( 78 , 8)),
				 15 => std_logic_vector(to_unsigned( 253 , 8)),
				 16 => std_logic_vector(to_unsigned( 47 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 138 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 917

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 128 , 8)),
				 1 => std_logic_vector(to_unsigned( 64 , 8)),
				 2 => std_logic_vector(to_unsigned( 8 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 145 , 8)),
				 5 => std_logic_vector(to_unsigned( 56 , 8)),
				 6 => std_logic_vector(to_unsigned( 96 , 8)),
				 7 => std_logic_vector(to_unsigned( 227 , 8)),
				 8 => std_logic_vector(to_unsigned( 236 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 34 , 8)),
				 11 => std_logic_vector(to_unsigned( 13 , 8)),
				 12 => std_logic_vector(to_unsigned( 242 , 8)),
				 13 => std_logic_vector(to_unsigned( 55 , 8)),
				 14 => std_logic_vector(to_unsigned( 74 , 8)),
				 15 => std_logic_vector(to_unsigned( 124 , 8)),
				 16 => std_logic_vector(to_unsigned( 45 , 8)),
				 17 => std_logic_vector(to_unsigned( 143 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 918

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 65 , 8)),
				 1 => std_logic_vector(to_unsigned( 115 , 8)),
				 2 => std_logic_vector(to_unsigned( 136 , 8)),
				 3 => std_logic_vector(to_unsigned( 34 , 8)),
				 4 => std_logic_vector(to_unsigned( 250 , 8)),
				 5 => std_logic_vector(to_unsigned( 224 , 8)),
				 6 => std_logic_vector(to_unsigned( 60 , 8)),
				 7 => std_logic_vector(to_unsigned( 230 , 8)),
				 8 => std_logic_vector(to_unsigned( 41 , 8)),
				 9 => std_logic_vector(to_unsigned( 231 , 8)),
				 10 => std_logic_vector(to_unsigned( 40 , 8)),
				 11 => std_logic_vector(to_unsigned( 73 , 8)),
				 12 => std_logic_vector(to_unsigned( 244 , 8)),
				 13 => std_logic_vector(to_unsigned( 9 , 8)),
				 14 => std_logic_vector(to_unsigned( 255 , 8)),
				 15 => std_logic_vector(to_unsigned( 71 , 8)),
				 16 => std_logic_vector(to_unsigned( 234 , 8)),
				 17 => std_logic_vector(to_unsigned( 87 , 8)),
				 18 => std_logic_vector(to_unsigned( 61 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 919

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 185 , 8)),
				 1 => std_logic_vector(to_unsigned( 45 , 8)),
				 2 => std_logic_vector(to_unsigned( 213 , 8)),
				 3 => std_logic_vector(to_unsigned( 170 , 8)),
				 4 => std_logic_vector(to_unsigned( 0 , 8)),
				 5 => std_logic_vector(to_unsigned( 155 , 8)),
				 6 => std_logic_vector(to_unsigned( 47 , 8)),
				 7 => std_logic_vector(to_unsigned( 175 , 8)),
				 8 => std_logic_vector(to_unsigned( 27 , 8)),
				 9 => std_logic_vector(to_unsigned( 228 , 8)),
				 10 => std_logic_vector(to_unsigned( 113 , 8)),
				 11 => std_logic_vector(to_unsigned( 218 , 8)),
				 12 => std_logic_vector(to_unsigned( 40 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 38 , 8)),
				 15 => std_logic_vector(to_unsigned( 252 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 226 , 8)),
				 18 => std_logic_vector(to_unsigned( 167 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 920

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 69 , 8)),
				 1 => std_logic_vector(to_unsigned( 170 , 8)),
				 2 => std_logic_vector(to_unsigned( 123 , 8)),
				 3 => std_logic_vector(to_unsigned( 240 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 40 , 8)),
				 7 => std_logic_vector(to_unsigned( 43 , 8)),
				 8 => std_logic_vector(to_unsigned( 179 , 8)),
				 9 => std_logic_vector(to_unsigned( 111 , 8)),
				 10 => std_logic_vector(to_unsigned( 111 , 8)),
				 11 => std_logic_vector(to_unsigned( 142 , 8)),
				 12 => std_logic_vector(to_unsigned( 80 , 8)),
				 13 => std_logic_vector(to_unsigned( 151 , 8)),
				 14 => std_logic_vector(to_unsigned( 107 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 142 , 8)),
				 17 => std_logic_vector(to_unsigned( 42 , 8)),
				 18 => std_logic_vector(to_unsigned( 49 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 921

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 153 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 251 , 8)),
				 3 => std_logic_vector(to_unsigned( 249 , 8)),
				 4 => std_logic_vector(to_unsigned( 207 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 231 , 8)),
				 7 => std_logic_vector(to_unsigned( 3 , 8)),
				 8 => std_logic_vector(to_unsigned( 52 , 8)),
				 9 => std_logic_vector(to_unsigned( 151 , 8)),
				 10 => std_logic_vector(to_unsigned( 31 , 8)),
				 11 => std_logic_vector(to_unsigned( 190 , 8)),
				 12 => std_logic_vector(to_unsigned( 221 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 203 , 8)),
				 15 => std_logic_vector(to_unsigned( 219 , 8)),
				 16 => std_logic_vector(to_unsigned( 75 , 8)),
				 17 => std_logic_vector(to_unsigned( 37 , 8)),
				 18 => std_logic_vector(to_unsigned( 213 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 922

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 94 , 8)),
				 1 => std_logic_vector(to_unsigned( 46 , 8)),
				 2 => std_logic_vector(to_unsigned( 232 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 53 , 8)),
				 5 => std_logic_vector(to_unsigned( 158 , 8)),
				 6 => std_logic_vector(to_unsigned( 39 , 8)),
				 7 => std_logic_vector(to_unsigned( 184 , 8)),
				 8 => std_logic_vector(to_unsigned( 13 , 8)),
				 9 => std_logic_vector(to_unsigned( 161 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 166 , 8)),
				 12 => std_logic_vector(to_unsigned( 37 , 8)),
				 13 => std_logic_vector(to_unsigned( 232 , 8)),
				 14 => std_logic_vector(to_unsigned( 246 , 8)),
				 15 => std_logic_vector(to_unsigned( 34 , 8)),
				 16 => std_logic_vector(to_unsigned( 40 , 8)),
				 17 => std_logic_vector(to_unsigned( 18 , 8)),
				 18 => std_logic_vector(to_unsigned( 48 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 923

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 133 , 8)),
				 2 => std_logic_vector(to_unsigned( 232 , 8)),
				 3 => std_logic_vector(to_unsigned( 152 , 8)),
				 4 => std_logic_vector(to_unsigned( 213 , 8)),
				 5 => std_logic_vector(to_unsigned( 85 , 8)),
				 6 => std_logic_vector(to_unsigned( 220 , 8)),
				 7 => std_logic_vector(to_unsigned( 240 , 8)),
				 8 => std_logic_vector(to_unsigned( 65 , 8)),
				 9 => std_logic_vector(to_unsigned( 8 , 8)),
				 10 => std_logic_vector(to_unsigned( 238 , 8)),
				 11 => std_logic_vector(to_unsigned( 209 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 243 , 8)),
				 15 => std_logic_vector(to_unsigned( 141 , 8)),
				 16 => std_logic_vector(to_unsigned( 82 , 8)),
				 17 => std_logic_vector(to_unsigned( 132 , 8)),
				 18 => std_logic_vector(to_unsigned( 98 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 924

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 28 , 8)),
				 1 => std_logic_vector(to_unsigned( 49 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 249 , 8)),
				 5 => std_logic_vector(to_unsigned( 201 , 8)),
				 6 => std_logic_vector(to_unsigned( 135 , 8)),
				 7 => std_logic_vector(to_unsigned( 177 , 8)),
				 8 => std_logic_vector(to_unsigned( 173 , 8)),
				 9 => std_logic_vector(to_unsigned( 109 , 8)),
				 10 => std_logic_vector(to_unsigned( 160 , 8)),
				 11 => std_logic_vector(to_unsigned( 128 , 8)),
				 12 => std_logic_vector(to_unsigned( 31 , 8)),
				 13 => std_logic_vector(to_unsigned( 158 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 158 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 200 , 8)),
				 18 => std_logic_vector(to_unsigned( 76 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 925

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 177 , 8)),
				 2 => std_logic_vector(to_unsigned( 61 , 8)),
				 3 => std_logic_vector(to_unsigned( 15 , 8)),
				 4 => std_logic_vector(to_unsigned( 147 , 8)),
				 5 => std_logic_vector(to_unsigned( 57 , 8)),
				 6 => std_logic_vector(to_unsigned( 105 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 31 , 8)),
				 9 => std_logic_vector(to_unsigned( 141 , 8)),
				 10 => std_logic_vector(to_unsigned( 66 , 8)),
				 11 => std_logic_vector(to_unsigned( 201 , 8)),
				 12 => std_logic_vector(to_unsigned( 6 , 8)),
				 13 => std_logic_vector(to_unsigned( 143 , 8)),
				 14 => std_logic_vector(to_unsigned( 94 , 8)),
				 15 => std_logic_vector(to_unsigned( 160 , 8)),
				 16 => std_logic_vector(to_unsigned( 77 , 8)),
				 17 => std_logic_vector(to_unsigned( 69 , 8)),
				 18 => std_logic_vector(to_unsigned( 242 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 926

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 118 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 37 , 8)),
				 3 => std_logic_vector(to_unsigned( 33 , 8)),
				 4 => std_logic_vector(to_unsigned( 76 , 8)),
				 5 => std_logic_vector(to_unsigned( 72 , 8)),
				 6 => std_logic_vector(to_unsigned( 104 , 8)),
				 7 => std_logic_vector(to_unsigned( 24 , 8)),
				 8 => std_logic_vector(to_unsigned( 59 , 8)),
				 9 => std_logic_vector(to_unsigned( 34 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 149 , 8)),
				 12 => std_logic_vector(to_unsigned( 157 , 8)),
				 13 => std_logic_vector(to_unsigned( 9 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 6 , 8)),
				 16 => std_logic_vector(to_unsigned( 78 , 8)),
				 17 => std_logic_vector(to_unsigned( 200 , 8)),
				 18 => std_logic_vector(to_unsigned( 211 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 927

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 24 , 8)),
				 1 => std_logic_vector(to_unsigned( 88 , 8)),
				 2 => std_logic_vector(to_unsigned( 218 , 8)),
				 3 => std_logic_vector(to_unsigned( 202 , 8)),
				 4 => std_logic_vector(to_unsigned( 104 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 77 , 8)),
				 7 => std_logic_vector(to_unsigned( 252 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 51 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 51 , 8)),
				 13 => std_logic_vector(to_unsigned( 185 , 8)),
				 14 => std_logic_vector(to_unsigned( 174 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 205 , 8)),
				 17 => std_logic_vector(to_unsigned( 231 , 8)),
				 18 => std_logic_vector(to_unsigned( 117 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 928

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 112 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 189 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 87 , 8)),
				 7 => std_logic_vector(to_unsigned( 143 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 9 , 8)),
				 10 => std_logic_vector(to_unsigned( 24 , 8)),
				 11 => std_logic_vector(to_unsigned( 158 , 8)),
				 12 => std_logic_vector(to_unsigned( 205 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 108 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 108 , 8)),
				 17 => std_logic_vector(to_unsigned( 146 , 8)),
				 18 => std_logic_vector(to_unsigned( 99 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 929

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 138 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 198 , 8)),
				 3 => std_logic_vector(to_unsigned( 247 , 8)),
				 4 => std_logic_vector(to_unsigned( 83 , 8)),
				 5 => std_logic_vector(to_unsigned( 89 , 8)),
				 6 => std_logic_vector(to_unsigned( 167 , 8)),
				 7 => std_logic_vector(to_unsigned( 121 , 8)),
				 8 => std_logic_vector(to_unsigned( 22 , 8)),
				 9 => std_logic_vector(to_unsigned( 125 , 8)),
				 10 => std_logic_vector(to_unsigned( 18 , 8)),
				 11 => std_logic_vector(to_unsigned( 251 , 8)),
				 12 => std_logic_vector(to_unsigned( 151 , 8)),
				 13 => std_logic_vector(to_unsigned( 97 , 8)),
				 14 => std_logic_vector(to_unsigned( 188 , 8)),
				 15 => std_logic_vector(to_unsigned( 67 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 162 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 930

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 4 , 8)),
				 1 => std_logic_vector(to_unsigned( 217 , 8)),
				 2 => std_logic_vector(to_unsigned( 145 , 8)),
				 3 => std_logic_vector(to_unsigned( 134 , 8)),
				 4 => std_logic_vector(to_unsigned( 42 , 8)),
				 5 => std_logic_vector(to_unsigned( 33 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 128 , 8)),
				 8 => std_logic_vector(to_unsigned( 26 , 8)),
				 9 => std_logic_vector(to_unsigned( 128 , 8)),
				 10 => std_logic_vector(to_unsigned( 26 , 8)),
				 11 => std_logic_vector(to_unsigned( 141 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 147 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 198 , 8)),
				 16 => std_logic_vector(to_unsigned( 235 , 8)),
				 17 => std_logic_vector(to_unsigned( 98 , 8)),
				 18 => std_logic_vector(to_unsigned( 4 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 931

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 179 , 8)),
				 1 => std_logic_vector(to_unsigned( 147 , 8)),
				 2 => std_logic_vector(to_unsigned( 207 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 151 , 8)),
				 5 => std_logic_vector(to_unsigned( 211 , 8)),
				 6 => std_logic_vector(to_unsigned( 61 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 54 , 8)),
				 9 => std_logic_vector(to_unsigned( 54 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 6 , 8)),
				 12 => std_logic_vector(to_unsigned( 162 , 8)),
				 13 => std_logic_vector(to_unsigned( 111 , 8)),
				 14 => std_logic_vector(to_unsigned( 57 , 8)),
				 15 => std_logic_vector(to_unsigned( 141 , 8)),
				 16 => std_logic_vector(to_unsigned( 27 , 8)),
				 17 => std_logic_vector(to_unsigned( 254 , 8)),
				 18 => std_logic_vector(to_unsigned( 92 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 932

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 43 , 8)),
				 1 => std_logic_vector(to_unsigned( 169 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 110 , 8)),
				 4 => std_logic_vector(to_unsigned( 109 , 8)),
				 5 => std_logic_vector(to_unsigned( 116 , 8)),
				 6 => std_logic_vector(to_unsigned( 194 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 127 , 8)),
				 9 => std_logic_vector(to_unsigned( 191 , 8)),
				 10 => std_logic_vector(to_unsigned( 49 , 8)),
				 11 => std_logic_vector(to_unsigned( 27 , 8)),
				 12 => std_logic_vector(to_unsigned( 66 , 8)),
				 13 => std_logic_vector(to_unsigned( 127 , 8)),
				 14 => std_logic_vector(to_unsigned( 214 , 8)),
				 15 => std_logic_vector(to_unsigned( 25 , 8)),
				 16 => std_logic_vector(to_unsigned( 120 , 8)),
				 17 => std_logic_vector(to_unsigned( 82 , 8)),
				 18 => std_logic_vector(to_unsigned( 123 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 933

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 245 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 250 , 8)),
				 3 => std_logic_vector(to_unsigned( 186 , 8)),
				 4 => std_logic_vector(to_unsigned( 4 , 8)),
				 5 => std_logic_vector(to_unsigned( 187 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 2 , 8)),
				 8 => std_logic_vector(to_unsigned( 61 , 8)),
				 9 => std_logic_vector(to_unsigned( 126 , 8)),
				 10 => std_logic_vector(to_unsigned( 81 , 8)),
				 11 => std_logic_vector(to_unsigned( 141 , 8)),
				 12 => std_logic_vector(to_unsigned( 26 , 8)),
				 13 => std_logic_vector(to_unsigned( 130 , 8)),
				 14 => std_logic_vector(to_unsigned( 140 , 8)),
				 15 => std_logic_vector(to_unsigned( 244 , 8)),
				 16 => std_logic_vector(to_unsigned( 26 , 8)),
				 17 => std_logic_vector(to_unsigned( 2 , 8)),
				 18 => std_logic_vector(to_unsigned( 26 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 934

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 209 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 39 , 8)),
				 5 => std_logic_vector(to_unsigned( 241 , 8)),
				 6 => std_logic_vector(to_unsigned( 23 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 19 , 8)),
				 9 => std_logic_vector(to_unsigned( 32 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 107 , 8)),
				 12 => std_logic_vector(to_unsigned( 222 , 8)),
				 13 => std_logic_vector(to_unsigned( 160 , 8)),
				 14 => std_logic_vector(to_unsigned( 169 , 8)),
				 15 => std_logic_vector(to_unsigned( 122 , 8)),
				 16 => std_logic_vector(to_unsigned( 228 , 8)),
				 17 => std_logic_vector(to_unsigned( 160 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 935

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 135 , 8)),
				 1 => std_logic_vector(to_unsigned( 136 , 8)),
				 2 => std_logic_vector(to_unsigned( 83 , 8)),
				 3 => std_logic_vector(to_unsigned( 196 , 8)),
				 4 => std_logic_vector(to_unsigned( 23 , 8)),
				 5 => std_logic_vector(to_unsigned( 203 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 94 , 8)),
				 8 => std_logic_vector(to_unsigned( 206 , 8)),
				 9 => std_logic_vector(to_unsigned( 5 , 8)),
				 10 => std_logic_vector(to_unsigned( 69 , 8)),
				 11 => std_logic_vector(to_unsigned( 185 , 8)),
				 12 => std_logic_vector(to_unsigned( 56 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 94 , 8)),
				 18 => std_logic_vector(to_unsigned( 209 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 936

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 209 , 8)),
				 1 => std_logic_vector(to_unsigned( 212 , 8)),
				 2 => std_logic_vector(to_unsigned( 55 , 8)),
				 3 => std_logic_vector(to_unsigned( 195 , 8)),
				 4 => std_logic_vector(to_unsigned( 199 , 8)),
				 5 => std_logic_vector(to_unsigned( 73 , 8)),
				 6 => std_logic_vector(to_unsigned( 228 , 8)),
				 7 => std_logic_vector(to_unsigned( 171 , 8)),
				 8 => std_logic_vector(to_unsigned( 130 , 8)),
				 9 => std_logic_vector(to_unsigned( 212 , 8)),
				 10 => std_logic_vector(to_unsigned( 89 , 8)),
				 11 => std_logic_vector(to_unsigned( 224 , 8)),
				 12 => std_logic_vector(to_unsigned( 77 , 8)),
				 13 => std_logic_vector(to_unsigned( 224 , 8)),
				 14 => std_logic_vector(to_unsigned( 77 , 8)),
				 15 => std_logic_vector(to_unsigned( 240 , 8)),
				 16 => std_logic_vector(to_unsigned( 61 , 8)),
				 17 => std_logic_vector(to_unsigned( 44 , 8)),
				 18 => std_logic_vector(to_unsigned( 51 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 937

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 14 , 8)),
				 1 => std_logic_vector(to_unsigned( 85 , 8)),
				 2 => std_logic_vector(to_unsigned( 156 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 79 , 8)),
				 5 => std_logic_vector(to_unsigned( 0 , 8)),
				 6 => std_logic_vector(to_unsigned( 1 , 8)),
				 7 => std_logic_vector(to_unsigned( 0 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 0 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 0 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 0 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 11 , 8)),
				 16 => std_logic_vector(to_unsigned( 173 , 8)),
				 17 => std_logic_vector(to_unsigned( 131 , 8)),
				 18 => std_logic_vector(to_unsigned( 29 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 938

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 29 , 8)),
				 1 => std_logic_vector(to_unsigned( 56 , 8)),
				 2 => std_logic_vector(to_unsigned( 137 , 8)),
				 3 => std_logic_vector(to_unsigned( 88 , 8)),
				 4 => std_logic_vector(to_unsigned( 56 , 8)),
				 5 => std_logic_vector(to_unsigned( 89 , 8)),
				 6 => std_logic_vector(to_unsigned( 55 , 8)),
				 7 => std_logic_vector(to_unsigned( 63 , 8)),
				 8 => std_logic_vector(to_unsigned( 241 , 8)),
				 9 => std_logic_vector(to_unsigned( 220 , 8)),
				 10 => std_logic_vector(to_unsigned( 53 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 24 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 18 , 8)),
				 15 => std_logic_vector(to_unsigned( 159 , 8)),
				 16 => std_logic_vector(to_unsigned( 91 , 8)),
				 17 => std_logic_vector(to_unsigned( 169 , 8)),
				 18 => std_logic_vector(to_unsigned( 173 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 939

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 160 , 8)),
				 1 => std_logic_vector(to_unsigned( 179 , 8)),
				 2 => std_logic_vector(to_unsigned( 81 , 8)),
				 3 => std_logic_vector(to_unsigned( 150 , 8)),
				 4 => std_logic_vector(to_unsigned( 15 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 164 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 20 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 209 , 8)),
				 12 => std_logic_vector(to_unsigned( 79 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 65 , 8)),
				 15 => std_logic_vector(to_unsigned( 228 , 8)),
				 16 => std_logic_vector(to_unsigned( 60 , 8)),
				 17 => std_logic_vector(to_unsigned( 233 , 8)),
				 18 => std_logic_vector(to_unsigned( 49 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 940

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 10 , 8)),
				 1 => std_logic_vector(to_unsigned( 135 , 8)),
				 2 => std_logic_vector(to_unsigned( 155 , 8)),
				 3 => std_logic_vector(to_unsigned( 56 , 8)),
				 4 => std_logic_vector(to_unsigned( 26 , 8)),
				 5 => std_logic_vector(to_unsigned( 66 , 8)),
				 6 => std_logic_vector(to_unsigned( 16 , 8)),
				 7 => std_logic_vector(to_unsigned( 78 , 8)),
				 8 => std_logic_vector(to_unsigned( 4 , 8)),
				 9 => std_logic_vector(to_unsigned( 200 , 8)),
				 10 => std_logic_vector(to_unsigned( 22 , 8)),
				 11 => std_logic_vector(to_unsigned( 220 , 8)),
				 12 => std_logic_vector(to_unsigned( 2 , 8)),
				 13 => std_logic_vector(to_unsigned( 220 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 220 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 37 , 8)),
				 18 => std_logic_vector(to_unsigned( 178 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 941

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 75 , 8)),
				 1 => std_logic_vector(to_unsigned( 25 , 8)),
				 2 => std_logic_vector(to_unsigned( 214 , 8)),
				 3 => std_logic_vector(to_unsigned( 162 , 8)),
				 4 => std_logic_vector(to_unsigned( 157 , 8)),
				 5 => std_logic_vector(to_unsigned( 247 , 8)),
				 6 => std_logic_vector(to_unsigned( 97 , 8)),
				 7 => std_logic_vector(to_unsigned( 248 , 8)),
				 8 => std_logic_vector(to_unsigned( 96 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 94 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 90 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 89 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 95 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 942

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 189 , 8)),
				 1 => std_logic_vector(to_unsigned( 200 , 8)),
				 2 => std_logic_vector(to_unsigned( 16 , 8)),
				 3 => std_logic_vector(to_unsigned( 150 , 8)),
				 4 => std_logic_vector(to_unsigned( 252 , 8)),
				 5 => std_logic_vector(to_unsigned( 9 , 8)),
				 6 => std_logic_vector(to_unsigned( 28 , 8)),
				 7 => std_logic_vector(to_unsigned( 225 , 8)),
				 8 => std_logic_vector(to_unsigned( 165 , 8)),
				 9 => std_logic_vector(to_unsigned( 203 , 8)),
				 10 => std_logic_vector(to_unsigned( 218 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 172 , 8)),
				 13 => std_logic_vector(to_unsigned( 89 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 90 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 194 , 8)),
				 18 => std_logic_vector(to_unsigned( 82 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 943

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 15 , 8)),
				 1 => std_logic_vector(to_unsigned( 221 , 8)),
				 2 => std_logic_vector(to_unsigned( 102 , 8)),
				 3 => std_logic_vector(to_unsigned( 139 , 8)),
				 4 => std_logic_vector(to_unsigned( 240 , 8)),
				 5 => std_logic_vector(to_unsigned( 210 , 8)),
				 6 => std_logic_vector(to_unsigned( 46 , 8)),
				 7 => std_logic_vector(to_unsigned( 226 , 8)),
				 8 => std_logic_vector(to_unsigned( 30 , 8)),
				 9 => std_logic_vector(to_unsigned( 241 , 8)),
				 10 => std_logic_vector(to_unsigned( 15 , 8)),
				 11 => std_logic_vector(to_unsigned( 102 , 8)),
				 12 => std_logic_vector(to_unsigned( 145 , 8)),
				 13 => std_logic_vector(to_unsigned( 148 , 8)),
				 14 => std_logic_vector(to_unsigned( 216 , 8)),
				 15 => std_logic_vector(to_unsigned( 221 , 8)),
				 16 => std_logic_vector(to_unsigned( 221 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 225 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 944

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 131 , 8)),
				 1 => std_logic_vector(to_unsigned( 101 , 8)),
				 2 => std_logic_vector(to_unsigned( 53 , 8)),
				 3 => std_logic_vector(to_unsigned( 9 , 8)),
				 4 => std_logic_vector(to_unsigned( 91 , 8)),
				 5 => std_logic_vector(to_unsigned( 48 , 8)),
				 6 => std_logic_vector(to_unsigned( 127 , 8)),
				 7 => std_logic_vector(to_unsigned( 140 , 8)),
				 8 => std_logic_vector(to_unsigned( 255 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 168 , 8)),
				 11 => std_logic_vector(to_unsigned( 192 , 8)),
				 12 => std_logic_vector(to_unsigned( 250 , 8)),
				 13 => std_logic_vector(to_unsigned( 228 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 49 , 8)),
				 16 => std_logic_vector(to_unsigned( 93 , 8)),
				 17 => std_logic_vector(to_unsigned( 137 , 8)),
				 18 => std_logic_vector(to_unsigned( 162 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 945

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 208 , 8)),
				 1 => std_logic_vector(to_unsigned( 174 , 8)),
				 2 => std_logic_vector(to_unsigned( 251 , 8)),
				 3 => std_logic_vector(to_unsigned( 243 , 8)),
				 4 => std_logic_vector(to_unsigned( 182 , 8)),
				 5 => std_logic_vector(to_unsigned( 228 , 8)),
				 6 => std_logic_vector(to_unsigned( 214 , 8)),
				 7 => std_logic_vector(to_unsigned( 232 , 8)),
				 8 => std_logic_vector(to_unsigned( 210 , 8)),
				 9 => std_logic_vector(to_unsigned( 218 , 8)),
				 10 => std_logic_vector(to_unsigned( 153 , 8)),
				 11 => std_logic_vector(to_unsigned( 43 , 8)),
				 12 => std_logic_vector(to_unsigned( 87 , 8)),
				 13 => std_logic_vector(to_unsigned( 84 , 8)),
				 14 => std_logic_vector(to_unsigned( 46 , 8)),
				 15 => std_logic_vector(to_unsigned( 7 , 8)),
				 16 => std_logic_vector(to_unsigned( 214 , 8)),
				 17 => std_logic_vector(to_unsigned( 215 , 8)),
				 18 => std_logic_vector(to_unsigned( 155 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 946

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 202 , 8)),
				 1 => std_logic_vector(to_unsigned( 165 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 140 , 8)),
				 4 => std_logic_vector(to_unsigned( 222 , 8)),
				 5 => std_logic_vector(to_unsigned( 244 , 8)),
				 6 => std_logic_vector(to_unsigned( 191 , 8)),
				 7 => std_logic_vector(to_unsigned( 254 , 8)),
				 8 => std_logic_vector(to_unsigned( 181 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 180 , 8)),
				 11 => std_logic_vector(to_unsigned( 233 , 8)),
				 12 => std_logic_vector(to_unsigned( 193 , 8)),
				 13 => std_logic_vector(to_unsigned( 7 , 8)),
				 14 => std_logic_vector(to_unsigned( 189 , 8)),
				 15 => std_logic_vector(to_unsigned( 9 , 8)),
				 16 => std_logic_vector(to_unsigned( 187 , 8)),
				 17 => std_logic_vector(to_unsigned( 52 , 8)),
				 18 => std_logic_vector(to_unsigned( 169 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 947

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 170 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 209 , 8)),
				 4 => std_logic_vector(to_unsigned( 212 , 8)),
				 5 => std_logic_vector(to_unsigned( 95 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 112 , 8)),
				 8 => std_logic_vector(to_unsigned( 121 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 99 , 8)),
				 11 => std_logic_vector(to_unsigned( 27 , 8)),
				 12 => std_logic_vector(to_unsigned( 189 , 8)),
				 13 => std_logic_vector(to_unsigned( 131 , 8)),
				 14 => std_logic_vector(to_unsigned( 85 , 8)),
				 15 => std_logic_vector(to_unsigned( 172 , 8)),
				 16 => std_logic_vector(to_unsigned( 44 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 90 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 948

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 46 , 8)),
				 1 => std_logic_vector(to_unsigned( 113 , 8)),
				 2 => std_logic_vector(to_unsigned( 173 , 8)),
				 3 => std_logic_vector(to_unsigned( 239 , 8)),
				 4 => std_logic_vector(to_unsigned( 65 , 8)),
				 5 => std_logic_vector(to_unsigned( 244 , 8)),
				 6 => std_logic_vector(to_unsigned( 60 , 8)),
				 7 => std_logic_vector(to_unsigned( 247 , 8)),
				 8 => std_logic_vector(to_unsigned( 57 , 8)),
				 9 => std_logic_vector(to_unsigned( 247 , 8)),
				 10 => std_logic_vector(to_unsigned( 57 , 8)),
				 11 => std_logic_vector(to_unsigned( 252 , 8)),
				 12 => std_logic_vector(to_unsigned( 52 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 49 , 8)),
				 15 => std_logic_vector(to_unsigned( 212 , 8)),
				 16 => std_logic_vector(to_unsigned( 160 , 8)),
				 17 => std_logic_vector(to_unsigned( 196 , 8)),
				 18 => std_logic_vector(to_unsigned( 9 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 46 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 949

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 37 , 8)),
				 1 => std_logic_vector(to_unsigned( 146 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 151 , 8)),
				 4 => std_logic_vector(to_unsigned( 16 , 8)),
				 5 => std_logic_vector(to_unsigned( 165 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 165 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 85 , 8)),
				 10 => std_logic_vector(to_unsigned( 30 , 8)),
				 11 => std_logic_vector(to_unsigned( 107 , 8)),
				 12 => std_logic_vector(to_unsigned( 8 , 8)),
				 13 => std_logic_vector(to_unsigned( 110 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 227 , 8)),
				 16 => std_logic_vector(to_unsigned( 192 , 8)),
				 17 => std_logic_vector(to_unsigned( 56 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 950

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 175 , 8)),
				 1 => std_logic_vector(to_unsigned( 81 , 8)),
				 2 => std_logic_vector(to_unsigned( 162 , 8)),
				 3 => std_logic_vector(to_unsigned( 208 , 8)),
				 4 => std_logic_vector(to_unsigned( 35 , 8)),
				 5 => std_logic_vector(to_unsigned( 224 , 8)),
				 6 => std_logic_vector(to_unsigned( 19 , 8)),
				 7 => std_logic_vector(to_unsigned( 233 , 8)),
				 8 => std_logic_vector(to_unsigned( 10 , 8)),
				 9 => std_logic_vector(to_unsigned( 233 , 8)),
				 10 => std_logic_vector(to_unsigned( 10 , 8)),
				 11 => std_logic_vector(to_unsigned( 239 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 241 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 159 , 8)),
				 18 => std_logic_vector(to_unsigned( 106 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 951

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 225 , 8)),
				 1 => std_logic_vector(to_unsigned( 99 , 8)),
				 2 => std_logic_vector(to_unsigned( 189 , 8)),
				 3 => std_logic_vector(to_unsigned( 118 , 8)),
				 4 => std_logic_vector(to_unsigned( 93 , 8)),
				 5 => std_logic_vector(to_unsigned( 144 , 8)),
				 6 => std_logic_vector(to_unsigned( 52 , 8)),
				 7 => std_logic_vector(to_unsigned( 94 , 8)),
				 8 => std_logic_vector(to_unsigned( 121 , 8)),
				 9 => std_logic_vector(to_unsigned( 135 , 8)),
				 10 => std_logic_vector(to_unsigned( 80 , 8)),
				 11 => std_logic_vector(to_unsigned( 139 , 8)),
				 12 => std_logic_vector(to_unsigned( 48 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 11 , 8)),
				 15 => std_logic_vector(to_unsigned( 184 , 8)),
				 16 => std_logic_vector(to_unsigned( 3 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 224 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 952

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 59 , 8)),
				 1 => std_logic_vector(to_unsigned( 216 , 8)),
				 2 => std_logic_vector(to_unsigned( 152 , 8)),
				 3 => std_logic_vector(to_unsigned( 97 , 8)),
				 4 => std_logic_vector(to_unsigned( 38 , 8)),
				 5 => std_logic_vector(to_unsigned( 110 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 134 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 108 , 8)),
				 12 => std_logic_vector(to_unsigned( 249 , 8)),
				 13 => std_logic_vector(to_unsigned( 155 , 8)),
				 14 => std_logic_vector(to_unsigned( 202 , 8)),
				 15 => std_logic_vector(to_unsigned( 228 , 8)),
				 16 => std_logic_vector(to_unsigned( 38 , 8)),
				 17 => std_logic_vector(to_unsigned( 22 , 8)),
				 18 => std_logic_vector(to_unsigned( 217 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 953

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 89 , 8)),
				 1 => std_logic_vector(to_unsigned( 42 , 8)),
				 2 => std_logic_vector(to_unsigned( 15 , 8)),
				 3 => std_logic_vector(to_unsigned( 70 , 8)),
				 4 => std_logic_vector(to_unsigned( 138 , 8)),
				 5 => std_logic_vector(to_unsigned( 101 , 8)),
				 6 => std_logic_vector(to_unsigned( 149 , 8)),
				 7 => std_logic_vector(to_unsigned( 189 , 8)),
				 8 => std_logic_vector(to_unsigned( 61 , 8)),
				 9 => std_logic_vector(to_unsigned( 220 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 154 , 8)),
				 12 => std_logic_vector(to_unsigned( 104 , 8)),
				 13 => std_logic_vector(to_unsigned( 185 , 8)),
				 14 => std_logic_vector(to_unsigned( 88 , 8)),
				 15 => std_logic_vector(to_unsigned( 249 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 206 , 8)),
				 18 => std_logic_vector(to_unsigned( 113 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 954

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 119 , 8)),
				 1 => std_logic_vector(to_unsigned( 93 , 8)),
				 2 => std_logic_vector(to_unsigned( 217 , 8)),
				 3 => std_logic_vector(to_unsigned( 164 , 8)),
				 4 => std_logic_vector(to_unsigned( 90 , 8)),
				 5 => std_logic_vector(to_unsigned( 221 , 8)),
				 6 => std_logic_vector(to_unsigned( 33 , 8)),
				 7 => std_logic_vector(to_unsigned( 212 , 8)),
				 8 => std_logic_vector(to_unsigned( 237 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 195 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 194 , 8)),
				 13 => std_logic_vector(to_unsigned( 14 , 8)),
				 14 => std_logic_vector(to_unsigned( 201 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 24 , 8)),
				 17 => std_logic_vector(to_unsigned( 247 , 8)),
				 18 => std_logic_vector(to_unsigned( 136 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 48 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 955

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 123 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 101 , 8)),
				 3 => std_logic_vector(to_unsigned( 115 , 8)),
				 4 => std_logic_vector(to_unsigned( 60 , 8)),
				 5 => std_logic_vector(to_unsigned( 206 , 8)),
				 6 => std_logic_vector(to_unsigned( 113 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 22 , 8)),
				 9 => std_logic_vector(to_unsigned( 77 , 8)),
				 10 => std_logic_vector(to_unsigned( 9 , 8)),
				 11 => std_logic_vector(to_unsigned( 35 , 8)),
				 12 => std_logic_vector(to_unsigned( 13 , 8)),
				 13 => std_logic_vector(to_unsigned( 47 , 8)),
				 14 => std_logic_vector(to_unsigned( 1 , 8)),
				 15 => std_logic_vector(to_unsigned( 47 , 8)),
				 16 => std_logic_vector(to_unsigned( 1 , 8)),
				 17 => std_logic_vector(to_unsigned( 25 , 8)),
				 18 => std_logic_vector(to_unsigned( 161 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 956

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 158 , 8)),
				 1 => std_logic_vector(to_unsigned( 167 , 8)),
				 2 => std_logic_vector(to_unsigned( 80 , 8)),
				 3 => std_logic_vector(to_unsigned( 104 , 8)),
				 4 => std_logic_vector(to_unsigned( 244 , 8)),
				 5 => std_logic_vector(to_unsigned( 147 , 8)),
				 6 => std_logic_vector(to_unsigned( 201 , 8)),
				 7 => std_logic_vector(to_unsigned( 215 , 8)),
				 8 => std_logic_vector(to_unsigned( 133 , 8)),
				 9 => std_logic_vector(to_unsigned( 58 , 8)),
				 10 => std_logic_vector(to_unsigned( 78 , 8)),
				 11 => std_logic_vector(to_unsigned( 231 , 8)),
				 12 => std_logic_vector(to_unsigned( 204 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 193 , 8)),
				 15 => std_logic_vector(to_unsigned( 176 , 8)),
				 16 => std_logic_vector(to_unsigned( 31 , 8)),
				 17 => std_logic_vector(to_unsigned( 127 , 8)),
				 18 => std_logic_vector(to_unsigned( 120 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 12 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 957

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 156 , 8)),
				 1 => std_logic_vector(to_unsigned( 116 , 8)),
				 2 => std_logic_vector(to_unsigned( 194 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 186 , 8)),
				 5 => std_logic_vector(to_unsigned( 222 , 8)),
				 6 => std_logic_vector(to_unsigned( 88 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 82 , 8)),
				 9 => std_logic_vector(to_unsigned( 232 , 8)),
				 10 => std_logic_vector(to_unsigned( 232 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 206 , 8)),
				 13 => std_logic_vector(to_unsigned( 147 , 8)),
				 14 => std_logic_vector(to_unsigned( 165 , 8)),
				 15 => std_logic_vector(to_unsigned( 115 , 8)),
				 16 => std_logic_vector(to_unsigned( 84 , 8)),
				 17 => std_logic_vector(to_unsigned( 14 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 958

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 116 , 8)),
				 1 => std_logic_vector(to_unsigned( 58 , 8)),
				 2 => std_logic_vector(to_unsigned( 115 , 8)),
				 3 => std_logic_vector(to_unsigned( 78 , 8)),
				 4 => std_logic_vector(to_unsigned( 141 , 8)),
				 5 => std_logic_vector(to_unsigned( 117 , 8)),
				 6 => std_logic_vector(to_unsigned( 102 , 8)),
				 7 => std_logic_vector(to_unsigned( 10 , 8)),
				 8 => std_logic_vector(to_unsigned( 189 , 8)),
				 9 => std_logic_vector(to_unsigned( 59 , 8)),
				 10 => std_logic_vector(to_unsigned( 140 , 8)),
				 11 => std_logic_vector(to_unsigned( 217 , 8)),
				 12 => std_logic_vector(to_unsigned( 125 , 8)),
				 13 => std_logic_vector(to_unsigned( 244 , 8)),
				 14 => std_logic_vector(to_unsigned( 98 , 8)),
				 15 => std_logic_vector(to_unsigned( 245 , 8)),
				 16 => std_logic_vector(to_unsigned( 97 , 8)),
				 17 => std_logic_vector(to_unsigned( 96 , 8)),
				 18 => std_logic_vector(to_unsigned( 162 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 959

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 164 , 8)),
				 1 => std_logic_vector(to_unsigned( 232 , 8)),
				 2 => std_logic_vector(to_unsigned( 94 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 49 , 8)),
				 5 => std_logic_vector(to_unsigned( 167 , 8)),
				 6 => std_logic_vector(to_unsigned( 6 , 8)),
				 7 => std_logic_vector(to_unsigned( 172 , 8)),
				 8 => std_logic_vector(to_unsigned( 1 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 233 , 8)),
				 12 => std_logic_vector(to_unsigned( 105 , 8)),
				 13 => std_logic_vector(to_unsigned( 208 , 8)),
				 14 => std_logic_vector(to_unsigned( 157 , 8)),
				 15 => std_logic_vector(to_unsigned( 212 , 8)),
				 16 => std_logic_vector(to_unsigned( 153 , 8)),
				 17 => std_logic_vector(to_unsigned( 83 , 8)),
				 18 => std_logic_vector(to_unsigned( 139 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 960

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 154 , 8)),
				 1 => std_logic_vector(to_unsigned( 252 , 8)),
				 2 => std_logic_vector(to_unsigned( 79 , 8)),
				 3 => std_logic_vector(to_unsigned( 12 , 8)),
				 4 => std_logic_vector(to_unsigned( 220 , 8)),
				 5 => std_logic_vector(to_unsigned( 162 , 8)),
				 6 => std_logic_vector(to_unsigned( 70 , 8)),
				 7 => std_logic_vector(to_unsigned( 52 , 8)),
				 8 => std_logic_vector(to_unsigned( 81 , 8)),
				 9 => std_logic_vector(to_unsigned( 77 , 8)),
				 10 => std_logic_vector(to_unsigned( 56 , 8)),
				 11 => std_logic_vector(to_unsigned( 102 , 8)),
				 12 => std_logic_vector(to_unsigned( 31 , 8)),
				 13 => std_logic_vector(to_unsigned( 78 , 8)),
				 14 => std_logic_vector(to_unsigned( 253 , 8)),
				 15 => std_logic_vector(to_unsigned( 224 , 8)),
				 16 => std_logic_vector(to_unsigned( 87 , 8)),
				 17 => std_logic_vector(to_unsigned( 167 , 8)),
				 18 => std_logic_vector(to_unsigned( 167 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 961

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 232 , 8)),
				 1 => std_logic_vector(to_unsigned( 144 , 8)),
				 2 => std_logic_vector(to_unsigned( 151 , 8)),
				 3 => std_logic_vector(to_unsigned( 218 , 8)),
				 4 => std_logic_vector(to_unsigned( 77 , 8)),
				 5 => std_logic_vector(to_unsigned( 138 , 8)),
				 6 => std_logic_vector(to_unsigned( 252 , 8)),
				 7 => std_logic_vector(to_unsigned( 62 , 8)),
				 8 => std_logic_vector(to_unsigned( 152 , 8)),
				 9 => std_logic_vector(to_unsigned( 205 , 8)),
				 10 => std_logic_vector(to_unsigned( 16 , 8)),
				 11 => std_logic_vector(to_unsigned( 210 , 8)),
				 12 => std_logic_vector(to_unsigned( 11 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 10 , 8)),
				 15 => std_logic_vector(to_unsigned( 96 , 8)),
				 16 => std_logic_vector(to_unsigned( 146 , 8)),
				 17 => std_logic_vector(to_unsigned( 239 , 8)),
				 18 => std_logic_vector(to_unsigned( 67 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 96 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 962

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 101 , 8)),
				 1 => std_logic_vector(to_unsigned( 36 , 8)),
				 2 => std_logic_vector(to_unsigned( 249 , 8)),
				 3 => std_logic_vector(to_unsigned( 206 , 8)),
				 4 => std_logic_vector(to_unsigned( 79 , 8)),
				 5 => std_logic_vector(to_unsigned( 206 , 8)),
				 6 => std_logic_vector(to_unsigned( 79 , 8)),
				 7 => std_logic_vector(to_unsigned( 218 , 8)),
				 8 => std_logic_vector(to_unsigned( 226 , 8)),
				 9 => std_logic_vector(to_unsigned( 24 , 8)),
				 10 => std_logic_vector(to_unsigned( 231 , 8)),
				 11 => std_logic_vector(to_unsigned( 180 , 8)),
				 12 => std_logic_vector(to_unsigned( 75 , 8)),
				 13 => std_logic_vector(to_unsigned( 252 , 8)),
				 14 => std_logic_vector(to_unsigned( 225 , 8)),
				 15 => std_logic_vector(to_unsigned( 3 , 8)),
				 16 => std_logic_vector(to_unsigned( 14 , 8)),
				 17 => std_logic_vector(to_unsigned( 139 , 8)),
				 18 => std_logic_vector(to_unsigned( 22 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 963

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 229 , 8)),
				 1 => std_logic_vector(to_unsigned( 180 , 8)),
				 2 => std_logic_vector(to_unsigned( 165 , 8)),
				 3 => std_logic_vector(to_unsigned( 186 , 8)),
				 4 => std_logic_vector(to_unsigned( 159 , 8)),
				 5 => std_logic_vector(to_unsigned( 253 , 8)),
				 6 => std_logic_vector(to_unsigned( 92 , 8)),
				 7 => std_logic_vector(to_unsigned( 239 , 8)),
				 8 => std_logic_vector(to_unsigned( 215 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 200 , 8)),
				 11 => std_logic_vector(to_unsigned( 254 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 52 , 8)),
				 14 => std_logic_vector(to_unsigned( 109 , 8)),
				 15 => std_logic_vector(to_unsigned( 125 , 8)),
				 16 => std_logic_vector(to_unsigned( 36 , 8)),
				 17 => std_logic_vector(to_unsigned( 113 , 8)),
				 18 => std_logic_vector(to_unsigned( 9 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 964

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 154 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 112 , 8)),
				 3 => std_logic_vector(to_unsigned( 42 , 8)),
				 4 => std_logic_vector(to_unsigned( 110 , 8)),
				 5 => std_logic_vector(to_unsigned( 109 , 8)),
				 6 => std_logic_vector(to_unsigned( 43 , 8)),
				 7 => std_logic_vector(to_unsigned( 127 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 145 , 8)),
				 10 => std_logic_vector(to_unsigned( 7 , 8)),
				 11 => std_logic_vector(to_unsigned( 147 , 8)),
				 12 => std_logic_vector(to_unsigned( 5 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 126 , 8)),
				 15 => std_logic_vector(to_unsigned( 236 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 79 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 965

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 237 , 8)),
				 1 => std_logic_vector(to_unsigned( 40 , 8)),
				 2 => std_logic_vector(to_unsigned( 183 , 8)),
				 3 => std_logic_vector(to_unsigned( 227 , 8)),
				 4 => std_logic_vector(to_unsigned( 79 , 8)),
				 5 => std_logic_vector(to_unsigned( 217 , 8)),
				 6 => std_logic_vector(to_unsigned( 53 , 8)),
				 7 => std_logic_vector(to_unsigned( 118 , 8)),
				 8 => std_logic_vector(to_unsigned( 183 , 8)),
				 9 => std_logic_vector(to_unsigned( 33 , 8)),
				 10 => std_logic_vector(to_unsigned( 158 , 8)),
				 11 => std_logic_vector(to_unsigned( 169 , 8)),
				 12 => std_logic_vector(to_unsigned( 22 , 8)),
				 13 => std_logic_vector(to_unsigned( 184 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 39 , 8)),
				 16 => std_logic_vector(to_unsigned( 179 , 8)),
				 17 => std_logic_vector(to_unsigned( 21 , 8)),
				 18 => std_logic_vector(to_unsigned( 156 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 966

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 193 , 8)),
				 1 => std_logic_vector(to_unsigned( 250 , 8)),
				 2 => std_logic_vector(to_unsigned( 101 , 8)),
				 3 => std_logic_vector(to_unsigned( 254 , 8)),
				 4 => std_logic_vector(to_unsigned( 97 , 8)),
				 5 => std_logic_vector(to_unsigned( 224 , 8)),
				 6 => std_logic_vector(to_unsigned( 158 , 8)),
				 7 => std_logic_vector(to_unsigned( 241 , 8)),
				 8 => std_logic_vector(to_unsigned( 141 , 8)),
				 9 => std_logic_vector(to_unsigned( 253 , 8)),
				 10 => std_logic_vector(to_unsigned( 129 , 8)),
				 11 => std_logic_vector(to_unsigned( 199 , 8)),
				 12 => std_logic_vector(to_unsigned( 200 , 8)),
				 13 => std_logic_vector(to_unsigned( 163 , 8)),
				 14 => std_logic_vector(to_unsigned( 152 , 8)),
				 15 => std_logic_vector(to_unsigned( 242 , 8)),
				 16 => std_logic_vector(to_unsigned( 91 , 8)),
				 17 => std_logic_vector(to_unsigned( 95 , 8)),
				 18 => std_logic_vector(to_unsigned( 44 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 967

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 150 , 8)),
				 1 => std_logic_vector(to_unsigned( 156 , 8)),
				 2 => std_logic_vector(to_unsigned( 71 , 8)),
				 3 => std_logic_vector(to_unsigned( 140 , 8)),
				 4 => std_logic_vector(to_unsigned( 190 , 8)),
				 5 => std_logic_vector(to_unsigned( 34 , 8)),
				 6 => std_logic_vector(to_unsigned( 109 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 85 , 8)),
				 9 => std_logic_vector(to_unsigned( 38 , 8)),
				 10 => std_logic_vector(to_unsigned( 101 , 8)),
				 11 => std_logic_vector(to_unsigned( 48 , 8)),
				 12 => std_logic_vector(to_unsigned( 91 , 8)),
				 13 => std_logic_vector(to_unsigned( 42 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 119 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 117 , 8)),
				 18 => std_logic_vector(to_unsigned( 173 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 968

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 73 , 8)),
				 1 => std_logic_vector(to_unsigned( 205 , 8)),
				 2 => std_logic_vector(to_unsigned( 126 , 8)),
				 3 => std_logic_vector(to_unsigned( 212 , 8)),
				 4 => std_logic_vector(to_unsigned( 119 , 8)),
				 5 => std_logic_vector(to_unsigned( 226 , 8)),
				 6 => std_logic_vector(to_unsigned( 73 , 8)),
				 7 => std_logic_vector(to_unsigned( 242 , 8)),
				 8 => std_logic_vector(to_unsigned( 57 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 75 , 8)),
				 11 => std_logic_vector(to_unsigned( 45 , 8)),
				 12 => std_logic_vector(to_unsigned( 47 , 8)),
				 13 => std_logic_vector(to_unsigned( 158 , 8)),
				 14 => std_logic_vector(to_unsigned( 220 , 8)),
				 15 => std_logic_vector(to_unsigned( 103 , 8)),
				 16 => std_logic_vector(to_unsigned( 97 , 8)),
				 17 => std_logic_vector(to_unsigned( 60 , 8)),
				 18 => std_logic_vector(to_unsigned( 185 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 969

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 53 , 8)),
				 1 => std_logic_vector(to_unsigned( 116 , 8)),
				 2 => std_logic_vector(to_unsigned( 247 , 8)),
				 3 => std_logic_vector(to_unsigned( 180 , 8)),
				 4 => std_logic_vector(to_unsigned( 183 , 8)),
				 5 => std_logic_vector(to_unsigned( 228 , 8)),
				 6 => std_logic_vector(to_unsigned( 243 , 8)),
				 7 => std_logic_vector(to_unsigned( 251 , 8)),
				 8 => std_logic_vector(to_unsigned( 220 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 216 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 216 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 245 , 8)),
				 15 => std_logic_vector(to_unsigned( 255 , 8)),
				 16 => std_logic_vector(to_unsigned( 245 , 8)),
				 17 => std_logic_vector(to_unsigned( 53 , 8)),
				 18 => std_logic_vector(to_unsigned( 250 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 970

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 213 , 8)),
				 1 => std_logic_vector(to_unsigned( 204 , 8)),
				 2 => std_logic_vector(to_unsigned( 176 , 8)),
				 3 => std_logic_vector(to_unsigned( 253 , 8)),
				 4 => std_logic_vector(to_unsigned( 215 , 8)),
				 5 => std_logic_vector(to_unsigned( 255 , 8)),
				 6 => std_logic_vector(to_unsigned( 213 , 8)),
				 7 => std_logic_vector(to_unsigned( 161 , 8)),
				 8 => std_logic_vector(to_unsigned( 36 , 8)),
				 9 => std_logic_vector(to_unsigned( 43 , 8)),
				 10 => std_logic_vector(to_unsigned( 67 , 8)),
				 11 => std_logic_vector(to_unsigned( 63 , 8)),
				 12 => std_logic_vector(to_unsigned( 178 , 8)),
				 13 => std_logic_vector(to_unsigned( 110 , 8)),
				 14 => std_logic_vector(to_unsigned( 181 , 8)),
				 15 => std_logic_vector(to_unsigned( 229 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 61 , 8)),
				 18 => std_logic_vector(to_unsigned( 157 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 971

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 105 , 8)),
				 1 => std_logic_vector(to_unsigned( 218 , 8)),
				 2 => std_logic_vector(to_unsigned( 161 , 8)),
				 3 => std_logic_vector(to_unsigned( 223 , 8)),
				 4 => std_logic_vector(to_unsigned( 156 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 148 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 136 , 8)),
				 9 => std_logic_vector(to_unsigned( 245 , 8)),
				 10 => std_logic_vector(to_unsigned( 134 , 8)),
				 11 => std_logic_vector(to_unsigned( 89 , 8)),
				 12 => std_logic_vector(to_unsigned( 76 , 8)),
				 13 => std_logic_vector(to_unsigned( 106 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 153 , 8)),
				 16 => std_logic_vector(to_unsigned( 12 , 8)),
				 17 => std_logic_vector(to_unsigned( 105 , 8)),
				 18 => std_logic_vector(to_unsigned( 202 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 972

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 199 , 8)),
				 2 => std_logic_vector(to_unsigned( 236 , 8)),
				 3 => std_logic_vector(to_unsigned( 195 , 8)),
				 4 => std_logic_vector(to_unsigned( 228 , 8)),
				 5 => std_logic_vector(to_unsigned( 29 , 8)),
				 6 => std_logic_vector(to_unsigned( 240 , 8)),
				 7 => std_logic_vector(to_unsigned( 64 , 8)),
				 8 => std_logic_vector(to_unsigned( 243 , 8)),
				 9 => std_logic_vector(to_unsigned( 166 , 8)),
				 10 => std_logic_vector(to_unsigned( 141 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 52 , 8)),
				 13 => std_logic_vector(to_unsigned( 95 , 8)),
				 14 => std_logic_vector(to_unsigned( 15 , 8)),
				 15 => std_logic_vector(to_unsigned( 73 , 8)),
				 16 => std_logic_vector(to_unsigned( 119 , 8)),
				 17 => std_logic_vector(to_unsigned( 8 , 8)),
				 18 => std_logic_vector(to_unsigned( 83 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 973

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 133 , 8)),
				 1 => std_logic_vector(to_unsigned( 236 , 8)),
				 2 => std_logic_vector(to_unsigned( 84 , 8)),
				 3 => std_logic_vector(to_unsigned( 246 , 8)),
				 4 => std_logic_vector(to_unsigned( 74 , 8)),
				 5 => std_logic_vector(to_unsigned( 254 , 8)),
				 6 => std_logic_vector(to_unsigned( 66 , 8)),
				 7 => std_logic_vector(to_unsigned( 255 , 8)),
				 8 => std_logic_vector(to_unsigned( 65 , 8)),
				 9 => std_logic_vector(to_unsigned( 255 , 8)),
				 10 => std_logic_vector(to_unsigned( 65 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 65 , 8)),
				 13 => std_logic_vector(to_unsigned( 255 , 8)),
				 14 => std_logic_vector(to_unsigned( 65 , 8)),
				 15 => std_logic_vector(to_unsigned( 24 , 8)),
				 16 => std_logic_vector(to_unsigned( 124 , 8)),
				 17 => std_logic_vector(to_unsigned( 209 , 8)),
				 18 => std_logic_vector(to_unsigned( 150 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 974

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 18 , 8)),
				 1 => std_logic_vector(to_unsigned( 238 , 8)),
				 2 => std_logic_vector(to_unsigned( 96 , 8)),
				 3 => std_logic_vector(to_unsigned( 238 , 8)),
				 4 => std_logic_vector(to_unsigned( 96 , 8)),
				 5 => std_logic_vector(to_unsigned( 252 , 8)),
				 6 => std_logic_vector(to_unsigned( 82 , 8)),
				 7 => std_logic_vector(to_unsigned( 228 , 8)),
				 8 => std_logic_vector(to_unsigned( 12 , 8)),
				 9 => std_logic_vector(to_unsigned( 199 , 8)),
				 10 => std_logic_vector(to_unsigned( 253 , 8)),
				 11 => std_logic_vector(to_unsigned( 235 , 8)),
				 12 => std_logic_vector(to_unsigned( 217 , 8)),
				 13 => std_logic_vector(to_unsigned( 242 , 8)),
				 14 => std_logic_vector(to_unsigned( 210 , 8)),
				 15 => std_logic_vector(to_unsigned( 123 , 8)),
				 16 => std_logic_vector(to_unsigned( 5 , 8)),
				 17 => std_logic_vector(to_unsigned( 57 , 8)),
				 18 => std_logic_vector(to_unsigned( 30 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 975

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 101 , 8)),
				 2 => std_logic_vector(to_unsigned( 52 , 8)),
				 3 => std_logic_vector(to_unsigned( 12 , 8)),
				 4 => std_logic_vector(to_unsigned( 19 , 8)),
				 5 => std_logic_vector(to_unsigned( 13 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 174 , 8)),
				 8 => std_logic_vector(to_unsigned( 103 , 8)),
				 9 => std_logic_vector(to_unsigned( 244 , 8)),
				 10 => std_logic_vector(to_unsigned( 33 , 8)),
				 11 => std_logic_vector(to_unsigned( 250 , 8)),
				 12 => std_logic_vector(to_unsigned( 27 , 8)),
				 13 => std_logic_vector(to_unsigned( 250 , 8)),
				 14 => std_logic_vector(to_unsigned( 27 , 8)),
				 15 => std_logic_vector(to_unsigned( 192 , 8)),
				 16 => std_logic_vector(to_unsigned( 202 , 8)),
				 17 => std_logic_vector(to_unsigned( 3 , 8)),
				 18 => std_logic_vector(to_unsigned( 229 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 976

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 67 , 8)),
				 1 => std_logic_vector(to_unsigned( 8 , 8)),
				 2 => std_logic_vector(to_unsigned( 241 , 8)),
				 3 => std_logic_vector(to_unsigned( 78 , 8)),
				 4 => std_logic_vector(to_unsigned( 60 , 8)),
				 5 => std_logic_vector(to_unsigned( 113 , 8)),
				 6 => std_logic_vector(to_unsigned( 25 , 8)),
				 7 => std_logic_vector(to_unsigned( 113 , 8)),
				 8 => std_logic_vector(to_unsigned( 25 , 8)),
				 9 => std_logic_vector(to_unsigned( 5 , 8)),
				 10 => std_logic_vector(to_unsigned( 250 , 8)),
				 11 => std_logic_vector(to_unsigned( 96 , 8)),
				 12 => std_logic_vector(to_unsigned( 180 , 8)),
				 13 => std_logic_vector(to_unsigned( 122 , 8)),
				 14 => std_logic_vector(to_unsigned( 55 , 8)),
				 15 => std_logic_vector(to_unsigned( 88 , 8)),
				 16 => std_logic_vector(to_unsigned( 176 , 8)),
				 17 => std_logic_vector(to_unsigned( 165 , 8)),
				 18 => std_logic_vector(to_unsigned( 201 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 977

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 243 , 8)),
				 1 => std_logic_vector(to_unsigned( 44 , 8)),
				 2 => std_logic_vector(to_unsigned( 35 , 8)),
				 3 => std_logic_vector(to_unsigned( 62 , 8)),
				 4 => std_logic_vector(to_unsigned( 17 , 8)),
				 5 => std_logic_vector(to_unsigned( 77 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 32 , 8)),
				 8 => std_logic_vector(to_unsigned( 230 , 8)),
				 9 => std_logic_vector(to_unsigned( 88 , 8)),
				 10 => std_logic_vector(to_unsigned( 174 , 8)),
				 11 => std_logic_vector(to_unsigned( 236 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 240 , 8)),
				 14 => std_logic_vector(to_unsigned( 24 , 8)),
				 15 => std_logic_vector(to_unsigned( 251 , 8)),
				 16 => std_logic_vector(to_unsigned( 13 , 8)),
				 17 => std_logic_vector(to_unsigned( 197 , 8)),
				 18 => std_logic_vector(to_unsigned( 105 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 978

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 168 , 8)),
				 1 => std_logic_vector(to_unsigned( 14 , 8)),
				 2 => std_logic_vector(to_unsigned( 243 , 8)),
				 3 => std_logic_vector(to_unsigned( 226 , 8)),
				 4 => std_logic_vector(to_unsigned( 237 , 8)),
				 5 => std_logic_vector(to_unsigned( 38 , 8)),
				 6 => std_logic_vector(to_unsigned( 13 , 8)),
				 7 => std_logic_vector(to_unsigned( 134 , 8)),
				 8 => std_logic_vector(to_unsigned( 56 , 8)),
				 9 => std_logic_vector(to_unsigned( 172 , 8)),
				 10 => std_logic_vector(to_unsigned( 42 , 8)),
				 11 => std_logic_vector(to_unsigned( 120 , 8)),
				 12 => std_logic_vector(to_unsigned( 42 , 8)),
				 13 => std_logic_vector(to_unsigned( 125 , 8)),
				 14 => std_logic_vector(to_unsigned( 37 , 8)),
				 15 => std_logic_vector(to_unsigned( 2 , 8)),
				 16 => std_logic_vector(to_unsigned( 176 , 8)),
				 17 => std_logic_vector(to_unsigned( 251 , 8)),
				 18 => std_logic_vector(to_unsigned( 198 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 979

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 57 , 8)),
				 1 => std_logic_vector(to_unsigned( 193 , 8)),
				 2 => std_logic_vector(to_unsigned( 49 , 8)),
				 3 => std_logic_vector(to_unsigned( 15 , 8)),
				 4 => std_logic_vector(to_unsigned( 21 , 8)),
				 5 => std_logic_vector(to_unsigned( 19 , 8)),
				 6 => std_logic_vector(to_unsigned( 17 , 8)),
				 7 => std_logic_vector(to_unsigned( 83 , 8)),
				 8 => std_logic_vector(to_unsigned( 166 , 8)),
				 9 => std_logic_vector(to_unsigned( 188 , 8)),
				 10 => std_logic_vector(to_unsigned( 61 , 8)),
				 11 => std_logic_vector(to_unsigned( 221 , 8)),
				 12 => std_logic_vector(to_unsigned( 28 , 8)),
				 13 => std_logic_vector(to_unsigned( 22 , 8)),
				 14 => std_logic_vector(to_unsigned( 2 , 8)),
				 15 => std_logic_vector(to_unsigned( 80 , 8)),
				 16 => std_logic_vector(to_unsigned( 75 , 8)),
				 17 => std_logic_vector(to_unsigned( 141 , 8)),
				 18 => std_logic_vector(to_unsigned( 249 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 980

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 193 , 8)),
				 1 => std_logic_vector(to_unsigned( 21 , 8)),
				 2 => std_logic_vector(to_unsigned( 105 , 8)),
				 3 => std_logic_vector(to_unsigned( 64 , 8)),
				 4 => std_logic_vector(to_unsigned( 62 , 8)),
				 5 => std_logic_vector(to_unsigned( 195 , 8)),
				 6 => std_logic_vector(to_unsigned( 190 , 8)),
				 7 => std_logic_vector(to_unsigned( 205 , 8)),
				 8 => std_logic_vector(to_unsigned( 180 , 8)),
				 9 => std_logic_vector(to_unsigned( 30 , 8)),
				 10 => std_logic_vector(to_unsigned( 134 , 8)),
				 11 => std_logic_vector(to_unsigned( 50 , 8)),
				 12 => std_logic_vector(to_unsigned( 252 , 8)),
				 13 => std_logic_vector(to_unsigned( 125 , 8)),
				 14 => std_logic_vector(to_unsigned( 177 , 8)),
				 15 => std_logic_vector(to_unsigned( 152 , 8)),
				 16 => std_logic_vector(to_unsigned( 150 , 8)),
				 17 => std_logic_vector(to_unsigned( 11 , 8)),
				 18 => std_logic_vector(to_unsigned( 78 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 981

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 128 , 8)),
				 1 => std_logic_vector(to_unsigned( 216 , 8)),
				 2 => std_logic_vector(to_unsigned( 85 , 8)),
				 3 => std_logic_vector(to_unsigned( 45 , 8)),
				 4 => std_logic_vector(to_unsigned( 232 , 8)),
				 5 => std_logic_vector(to_unsigned( 120 , 8)),
				 6 => std_logic_vector(to_unsigned( 157 , 8)),
				 7 => std_logic_vector(to_unsigned( 157 , 8)),
				 8 => std_logic_vector(to_unsigned( 120 , 8)),
				 9 => std_logic_vector(to_unsigned( 180 , 8)),
				 10 => std_logic_vector(to_unsigned( 97 , 8)),
				 11 => std_logic_vector(to_unsigned( 104 , 8)),
				 12 => std_logic_vector(to_unsigned( 98 , 8)),
				 13 => std_logic_vector(to_unsigned( 111 , 8)),
				 14 => std_logic_vector(to_unsigned( 91 , 8)),
				 15 => std_logic_vector(to_unsigned( 47 , 8)),
				 16 => std_logic_vector(to_unsigned( 66 , 8)),
				 17 => std_logic_vector(to_unsigned( 214 , 8)),
				 18 => std_logic_vector(to_unsigned( 149 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 982

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 3 , 8)),
				 1 => std_logic_vector(to_unsigned( 56 , 8)),
				 2 => std_logic_vector(to_unsigned( 131 , 8)),
				 3 => std_logic_vector(to_unsigned( 57 , 8)),
				 4 => std_logic_vector(to_unsigned( 130 , 8)),
				 5 => std_logic_vector(to_unsigned( 183 , 8)),
				 6 => std_logic_vector(to_unsigned( 4 , 8)),
				 7 => std_logic_vector(to_unsigned( 140 , 8)),
				 8 => std_logic_vector(to_unsigned( 236 , 8)),
				 9 => std_logic_vector(to_unsigned( 67 , 8)),
				 10 => std_logic_vector(to_unsigned( 164 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 155 , 8)),
				 13 => std_logic_vector(to_unsigned( 85 , 8)),
				 14 => std_logic_vector(to_unsigned( 146 , 8)),
				 15 => std_logic_vector(to_unsigned( 99 , 8)),
				 16 => std_logic_vector(to_unsigned( 132 , 8)),
				 17 => std_logic_vector(to_unsigned( 68 , 8)),
				 18 => std_logic_vector(to_unsigned( 58 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 983

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 210 , 8)),
				 1 => std_logic_vector(to_unsigned( 85 , 8)),
				 2 => std_logic_vector(to_unsigned( 88 , 8)),
				 3 => std_logic_vector(to_unsigned( 127 , 8)),
				 4 => std_logic_vector(to_unsigned( 217 , 8)),
				 5 => std_logic_vector(to_unsigned( 228 , 8)),
				 6 => std_logic_vector(to_unsigned( 116 , 8)),
				 7 => std_logic_vector(to_unsigned( 245 , 8)),
				 8 => std_logic_vector(to_unsigned( 99 , 8)),
				 9 => std_logic_vector(to_unsigned( 249 , 8)),
				 10 => std_logic_vector(to_unsigned( 95 , 8)),
				 11 => std_logic_vector(to_unsigned( 249 , 8)),
				 12 => std_logic_vector(to_unsigned( 95 , 8)),
				 13 => std_logic_vector(to_unsigned( 145 , 8)),
				 14 => std_logic_vector(to_unsigned( 250 , 8)),
				 15 => std_logic_vector(to_unsigned( 159 , 8)),
				 16 => std_logic_vector(to_unsigned( 236 , 8)),
				 17 => std_logic_vector(to_unsigned( 236 , 8)),
				 18 => std_logic_vector(to_unsigned( 119 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 984

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 103 , 8)),
				 1 => std_logic_vector(to_unsigned( 206 , 8)),
				 2 => std_logic_vector(to_unsigned( 225 , 8)),
				 3 => std_logic_vector(to_unsigned( 223 , 8)),
				 4 => std_logic_vector(to_unsigned( 208 , 8)),
				 5 => std_logic_vector(to_unsigned( 248 , 8)),
				 6 => std_logic_vector(to_unsigned( 183 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 178 , 8)),
				 9 => std_logic_vector(to_unsigned( 254 , 8)),
				 10 => std_logic_vector(to_unsigned( 177 , 8)),
				 11 => std_logic_vector(to_unsigned( 197 , 8)),
				 12 => std_logic_vector(to_unsigned( 95 , 8)),
				 13 => std_logic_vector(to_unsigned( 179 , 8)),
				 14 => std_logic_vector(to_unsigned( 86 , 8)),
				 15 => std_logic_vector(to_unsigned( 243 , 8)),
				 16 => std_logic_vector(to_unsigned( 22 , 8)),
				 17 => std_logic_vector(to_unsigned( 116 , 8)),
				 18 => std_logic_vector(to_unsigned( 46 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 985

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 78 , 8)),
				 1 => std_logic_vector(to_unsigned( 57 , 8)),
				 2 => std_logic_vector(to_unsigned( 70 , 8)),
				 3 => std_logic_vector(to_unsigned( 107 , 8)),
				 4 => std_logic_vector(to_unsigned( 20 , 8)),
				 5 => std_logic_vector(to_unsigned( 109 , 8)),
				 6 => std_logic_vector(to_unsigned( 18 , 8)),
				 7 => std_logic_vector(to_unsigned( 140 , 8)),
				 8 => std_logic_vector(to_unsigned( 201 , 8)),
				 9 => std_logic_vector(to_unsigned( 224 , 8)),
				 10 => std_logic_vector(to_unsigned( 117 , 8)),
				 11 => std_logic_vector(to_unsigned( 229 , 8)),
				 12 => std_logic_vector(to_unsigned( 112 , 8)),
				 13 => std_logic_vector(to_unsigned( 47 , 8)),
				 14 => std_logic_vector(to_unsigned( 122 , 8)),
				 15 => std_logic_vector(to_unsigned( 99 , 8)),
				 16 => std_logic_vector(to_unsigned( 70 , 8)),
				 17 => std_logic_vector(to_unsigned( 171 , 8)),
				 18 => std_logic_vector(to_unsigned( 164 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 8 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 986

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 140 , 8)),
				 1 => std_logic_vector(to_unsigned( 24 , 8)),
				 2 => std_logic_vector(to_unsigned( 103 , 8)),
				 3 => std_logic_vector(to_unsigned( 230 , 8)),
				 4 => std_logic_vector(to_unsigned( 10 , 8)),
				 5 => std_logic_vector(to_unsigned( 87 , 8)),
				 6 => std_logic_vector(to_unsigned( 137 , 8)),
				 7 => std_logic_vector(to_unsigned( 67 , 8)),
				 8 => std_logic_vector(to_unsigned( 221 , 8)),
				 9 => std_logic_vector(to_unsigned( 14 , 8)),
				 10 => std_logic_vector(to_unsigned( 2 , 8)),
				 11 => std_logic_vector(to_unsigned( 15 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 124 , 8)),
				 14 => std_logic_vector(to_unsigned( 7 , 8)),
				 15 => std_logic_vector(to_unsigned( 38 , 8)),
				 16 => std_logic_vector(to_unsigned( 47 , 8)),
				 17 => std_logic_vector(to_unsigned( 122 , 8)),
				 18 => std_logic_vector(to_unsigned( 161 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 987

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 168 , 8)),
				 1 => std_logic_vector(to_unsigned( 45 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 144 , 8)),
				 4 => std_logic_vector(to_unsigned( 92 , 8)),
				 5 => std_logic_vector(to_unsigned( 140 , 8)),
				 6 => std_logic_vector(to_unsigned( 54 , 8)),
				 7 => std_logic_vector(to_unsigned( 11 , 8)),
				 8 => std_logic_vector(to_unsigned( 227 , 8)),
				 9 => std_logic_vector(to_unsigned( 45 , 8)),
				 10 => std_logic_vector(to_unsigned( 193 , 8)),
				 11 => std_logic_vector(to_unsigned( 216 , 8)),
				 12 => std_logic_vector(to_unsigned( 35 , 8)),
				 13 => std_logic_vector(to_unsigned( 145 , 8)),
				 14 => std_logic_vector(to_unsigned( 89 , 8)),
				 15 => std_logic_vector(to_unsigned( 167 , 8)),
				 16 => std_logic_vector(to_unsigned( 67 , 8)),
				 17 => std_logic_vector(to_unsigned( 240 , 8)),
				 18 => std_logic_vector(to_unsigned( 182 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 32 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 988

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 182 , 8)),
				 1 => std_logic_vector(to_unsigned( 196 , 8)),
				 2 => std_logic_vector(to_unsigned( 115 , 8)),
				 3 => std_logic_vector(to_unsigned( 214 , 8)),
				 4 => std_logic_vector(to_unsigned( 97 , 8)),
				 5 => std_logic_vector(to_unsigned( 178 , 8)),
				 6 => std_logic_vector(to_unsigned( 206 , 8)),
				 7 => std_logic_vector(to_unsigned( 243 , 8)),
				 8 => std_logic_vector(to_unsigned( 141 , 8)),
				 9 => std_logic_vector(to_unsigned( 243 , 8)),
				 10 => std_logic_vector(to_unsigned( 141 , 8)),
				 11 => std_logic_vector(to_unsigned( 244 , 8)),
				 12 => std_logic_vector(to_unsigned( 140 , 8)),
				 13 => std_logic_vector(to_unsigned( 14 , 8)),
				 14 => std_logic_vector(to_unsigned( 5 , 8)),
				 15 => std_logic_vector(to_unsigned( 186 , 8)),
				 16 => std_logic_vector(to_unsigned( 160 , 8)),
				 17 => std_logic_vector(to_unsigned( 42 , 8)),
				 18 => std_logic_vector(to_unsigned( 205 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 989

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 51 , 8)),
				 1 => std_logic_vector(to_unsigned( 166 , 8)),
				 2 => std_logic_vector(to_unsigned( 174 , 8)),
				 3 => std_logic_vector(to_unsigned( 124 , 8)),
				 4 => std_logic_vector(to_unsigned( 241 , 8)),
				 5 => std_logic_vector(to_unsigned( 231 , 8)),
				 6 => std_logic_vector(to_unsigned( 134 , 8)),
				 7 => std_logic_vector(to_unsigned( 8 , 8)),
				 8 => std_logic_vector(to_unsigned( 239 , 8)),
				 9 => std_logic_vector(to_unsigned( 227 , 8)),
				 10 => std_logic_vector(to_unsigned( 87 , 8)),
				 11 => std_logic_vector(to_unsigned( 255 , 8)),
				 12 => std_logic_vector(to_unsigned( 59 , 8)),
				 13 => std_logic_vector(to_unsigned( 211 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 187 , 8)),
				 16 => std_logic_vector(to_unsigned( 4 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 114 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 990

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 166 , 8)),
				 1 => std_logic_vector(to_unsigned( 242 , 8)),
				 2 => std_logic_vector(to_unsigned( 208 , 8)),
				 3 => std_logic_vector(to_unsigned( 244 , 8)),
				 4 => std_logic_vector(to_unsigned( 206 , 8)),
				 5 => std_logic_vector(to_unsigned( 207 , 8)),
				 6 => std_logic_vector(to_unsigned( 38 , 8)),
				 7 => std_logic_vector(to_unsigned( 230 , 8)),
				 8 => std_logic_vector(to_unsigned( 15 , 8)),
				 9 => std_logic_vector(to_unsigned( 240 , 8)),
				 10 => std_logic_vector(to_unsigned( 5 , 8)),
				 11 => std_logic_vector(to_unsigned( 74 , 8)),
				 12 => std_logic_vector(to_unsigned( 201 , 8)),
				 13 => std_logic_vector(to_unsigned( 122 , 8)),
				 14 => std_logic_vector(to_unsigned( 153 , 8)),
				 15 => std_logic_vector(to_unsigned( 131 , 8)),
				 16 => std_logic_vector(to_unsigned( 144 , 8)),
				 17 => std_logic_vector(to_unsigned( 145 , 8)),
				 18 => std_logic_vector(to_unsigned( 181 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 991

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 235 , 8)),
				 1 => std_logic_vector(to_unsigned( 59 , 8)),
				 2 => std_logic_vector(to_unsigned( 248 , 8)),
				 3 => std_logic_vector(to_unsigned( 178 , 8)),
				 4 => std_logic_vector(to_unsigned( 189 , 8)),
				 5 => std_logic_vector(to_unsigned( 229 , 8)),
				 6 => std_logic_vector(to_unsigned( 138 , 8)),
				 7 => std_logic_vector(to_unsigned( 31 , 8)),
				 8 => std_logic_vector(to_unsigned( 86 , 8)),
				 9 => std_logic_vector(to_unsigned( 36 , 8)),
				 10 => std_logic_vector(to_unsigned( 74 , 8)),
				 11 => std_logic_vector(to_unsigned( 46 , 8)),
				 12 => std_logic_vector(to_unsigned( 64 , 8)),
				 13 => std_logic_vector(to_unsigned( 223 , 8)),
				 14 => std_logic_vector(to_unsigned( 183 , 8)),
				 15 => std_logic_vector(to_unsigned( 224 , 8)),
				 16 => std_logic_vector(to_unsigned( 182 , 8)),
				 17 => std_logic_vector(to_unsigned( 14 , 8)),
				 18 => std_logic_vector(to_unsigned( 252 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 1 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 992

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 254 , 8)),
				 1 => std_logic_vector(to_unsigned( 96 , 8)),
				 2 => std_logic_vector(to_unsigned( 219 , 8)),
				 3 => std_logic_vector(to_unsigned( 201 , 8)),
				 4 => std_logic_vector(to_unsigned( 114 , 8)),
				 5 => std_logic_vector(to_unsigned( 250 , 8)),
				 6 => std_logic_vector(to_unsigned( 65 , 8)),
				 7 => std_logic_vector(to_unsigned( 253 , 8)),
				 8 => std_logic_vector(to_unsigned( 62 , 8)),
				 9 => std_logic_vector(to_unsigned( 150 , 8)),
				 10 => std_logic_vector(to_unsigned( 132 , 8)),
				 11 => std_logic_vector(to_unsigned( 193 , 8)),
				 12 => std_logic_vector(to_unsigned( 205 , 8)),
				 13 => std_logic_vector(to_unsigned( 0 , 8)),
				 14 => std_logic_vector(to_unsigned( 116 , 8)),
				 15 => std_logic_vector(to_unsigned( 18 , 8)),
				 16 => std_logic_vector(to_unsigned( 122 , 8)),
				 17 => std_logic_vector(to_unsigned( 20 , 8)),
				 18 => std_logic_vector(to_unsigned( 131 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 993

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 165 , 8)),
				 1 => std_logic_vector(to_unsigned( 42 , 8)),
				 2 => std_logic_vector(to_unsigned( 69 , 8)),
				 3 => std_logic_vector(to_unsigned( 108 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 205 , 8)),
				 6 => std_logic_vector(to_unsigned( 30 , 8)),
				 7 => std_logic_vector(to_unsigned( 47 , 8)),
				 8 => std_logic_vector(to_unsigned( 29 , 8)),
				 9 => std_logic_vector(to_unsigned( 3 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 3 , 8)),
				 12 => std_logic_vector(to_unsigned( 4 , 8)),
				 13 => std_logic_vector(to_unsigned( 146 , 8)),
				 14 => std_logic_vector(to_unsigned( 100 , 8)),
				 15 => std_logic_vector(to_unsigned( 51 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 221 , 8)),
				 18 => std_logic_vector(to_unsigned( 7 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 4 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 994

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 168 , 8)),
				 1 => std_logic_vector(to_unsigned( 105 , 8)),
				 2 => std_logic_vector(to_unsigned( 2 , 8)),
				 3 => std_logic_vector(to_unsigned( 105 , 8)),
				 4 => std_logic_vector(to_unsigned( 2 , 8)),
				 5 => std_logic_vector(to_unsigned( 105 , 8)),
				 6 => std_logic_vector(to_unsigned( 2 , 8)),
				 7 => std_logic_vector(to_unsigned( 105 , 8)),
				 8 => std_logic_vector(to_unsigned( 2 , 8)),
				 9 => std_logic_vector(to_unsigned( 106 , 8)),
				 10 => std_logic_vector(to_unsigned( 1 , 8)),
				 11 => std_logic_vector(to_unsigned( 106 , 8)),
				 12 => std_logic_vector(to_unsigned( 1 , 8)),
				 13 => std_logic_vector(to_unsigned( 40 , 8)),
				 14 => std_logic_vector(to_unsigned( 237 , 8)),
				 15 => std_logic_vector(to_unsigned( 68 , 8)),
				 16 => std_logic_vector(to_unsigned( 209 , 8)),
				 17 => std_logic_vector(to_unsigned( 143 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 995

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 184 , 8)),
				 1 => std_logic_vector(to_unsigned( 220 , 8)),
				 2 => std_logic_vector(to_unsigned( 8 , 8)),
				 3 => std_logic_vector(to_unsigned( 225 , 8)),
				 4 => std_logic_vector(to_unsigned( 3 , 8)),
				 5 => std_logic_vector(to_unsigned( 225 , 8)),
				 6 => std_logic_vector(to_unsigned( 3 , 8)),
				 7 => std_logic_vector(to_unsigned( 225 , 8)),
				 8 => std_logic_vector(to_unsigned( 3 , 8)),
				 9 => std_logic_vector(to_unsigned( 75 , 8)),
				 10 => std_logic_vector(to_unsigned( 82 , 8)),
				 11 => std_logic_vector(to_unsigned( 76 , 8)),
				 12 => std_logic_vector(to_unsigned( 81 , 8)),
				 13 => std_logic_vector(to_unsigned( 132 , 8)),
				 14 => std_logic_vector(to_unsigned( 25 , 8)),
				 15 => std_logic_vector(to_unsigned( 150 , 8)),
				 16 => std_logic_vector(to_unsigned( 7 , 8)),
				 17 => std_logic_vector(to_unsigned( 31 , 8)),
				 18 => std_logic_vector(to_unsigned( 255 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 996

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 111 , 8)),
				 1 => std_logic_vector(to_unsigned( 153 , 8)),
				 2 => std_logic_vector(to_unsigned( 159 , 8)),
				 3 => std_logic_vector(to_unsigned( 121 , 8)),
				 4 => std_logic_vector(to_unsigned( 227 , 8)),
				 5 => std_logic_vector(to_unsigned( 142 , 8)),
				 6 => std_logic_vector(to_unsigned( 206 , 8)),
				 7 => std_logic_vector(to_unsigned( 189 , 8)),
				 8 => std_logic_vector(to_unsigned( 159 , 8)),
				 9 => std_logic_vector(to_unsigned( 37 , 8)),
				 10 => std_logic_vector(to_unsigned( 113 , 8)),
				 11 => std_logic_vector(to_unsigned( 59 , 8)),
				 12 => std_logic_vector(to_unsigned( 91 , 8)),
				 13 => std_logic_vector(to_unsigned( 91 , 8)),
				 14 => std_logic_vector(to_unsigned( 59 , 8)),
				 15 => std_logic_vector(to_unsigned( 103 , 8)),
				 16 => std_logic_vector(to_unsigned( 98 , 8)),
				 17 => std_logic_vector(to_unsigned( 204 , 8)),
				 18 => std_logic_vector(to_unsigned( 19 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 64 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 997

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 91 , 8)),
				 1 => std_logic_vector(to_unsigned( 218 , 8)),
				 2 => std_logic_vector(to_unsigned( 107 , 8)),
				 3 => std_logic_vector(to_unsigned( 98 , 8)),
				 4 => std_logic_vector(to_unsigned( 174 , 8)),
				 5 => std_logic_vector(to_unsigned( 159 , 8)),
				 6 => std_logic_vector(to_unsigned( 113 , 8)),
				 7 => std_logic_vector(to_unsigned( 58 , 8)),
				 8 => std_logic_vector(to_unsigned( 64 , 8)),
				 9 => std_logic_vector(to_unsigned( 54 , 8)),
				 10 => std_logic_vector(to_unsigned( 203 , 8)),
				 11 => std_logic_vector(to_unsigned( 95 , 8)),
				 12 => std_logic_vector(to_unsigned( 85 , 8)),
				 13 => std_logic_vector(to_unsigned( 176 , 8)),
				 14 => std_logic_vector(to_unsigned( 4 , 8)),
				 15 => std_logic_vector(to_unsigned( 178 , 8)),
				 16 => std_logic_vector(to_unsigned( 2 , 8)),
				 17 => std_logic_vector(to_unsigned( 166 , 8)),
				 18 => std_logic_vector(to_unsigned( 154 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 998

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 23 , 8)),
				 1 => std_logic_vector(to_unsigned( 250 , 8)),
				 2 => std_logic_vector(to_unsigned( 30 , 8)),
				 3 => std_logic_vector(to_unsigned( 80 , 8)),
				 4 => std_logic_vector(to_unsigned( 161 , 8)),
				 5 => std_logic_vector(to_unsigned( 182 , 8)),
				 6 => std_logic_vector(to_unsigned( 59 , 8)),
				 7 => std_logic_vector(to_unsigned( 51 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 113 , 8)),
				 10 => std_logic_vector(to_unsigned( 4 , 8)),
				 11 => std_logic_vector(to_unsigned( 173 , 8)),
				 12 => std_logic_vector(to_unsigned( 227 , 8)),
				 13 => std_logic_vector(to_unsigned( 247 , 8)),
				 14 => std_logic_vector(to_unsigned( 43 , 8)),
				 15 => std_logic_vector(to_unsigned( 250 , 8)),
				 16 => std_logic_vector(to_unsigned( 143 , 8)),
				 17 => std_logic_vector(to_unsigned( 54 , 8)),
				 18 => std_logic_vector(to_unsigned( 132 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 2 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 999

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 159 , 8)),
				 1 => std_logic_vector(to_unsigned( 181 , 8)),
				 2 => std_logic_vector(to_unsigned( 172 , 8)),
				 3 => std_logic_vector(to_unsigned( 212 , 8)),
				 4 => std_logic_vector(to_unsigned( 141 , 8)),
				 5 => std_logic_vector(to_unsigned( 232 , 8)),
				 6 => std_logic_vector(to_unsigned( 121 , 8)),
				 7 => std_logic_vector(to_unsigned( 235 , 8)),
				 8 => std_logic_vector(to_unsigned( 118 , 8)),
				 9 => std_logic_vector(to_unsigned( 250 , 8)),
				 10 => std_logic_vector(to_unsigned( 103 , 8)),
				 11 => std_logic_vector(to_unsigned( 223 , 8)),
				 12 => std_logic_vector(to_unsigned( 250 , 8)),
				 13 => std_logic_vector(to_unsigned( 103 , 8)),
				 14 => std_logic_vector(to_unsigned( 102 , 8)),
				 15 => std_logic_vector(to_unsigned( 142 , 8)),
				 16 => std_logic_vector(to_unsigned( 101 , 8)),
				 17 => std_logic_vector(to_unsigned( 93 , 8)),
				 18 => std_logic_vector(to_unsigned( 145 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 128 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



--test # 1000

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity project_tb is
end project_tb;
architecture projecttb of project_tb is
constant c_CLOCK_PERIOD		: time := 100 ns;
signal   tb_done				: std_logic;
signal   mem_address			: std_logic_vector (15 downto 0) := (others => '0');
signal   tb_rst					: std_logic := '0';
signal   tb_start				: std_logic := '0';
signal   tb_clk					: std_logic := '0';
signal   mem_o_data,mem_i_data	: std_logic_vector (7 downto 0);
signal   enable_wire			: std_logic;
signal   mem_we					: std_logic;
type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);

signal RAM: ram_type := (0 => std_logic_vector(to_unsigned( 220 , 8)),
				 1 => std_logic_vector(to_unsigned( 26 , 8)),
				 2 => std_logic_vector(to_unsigned( 21 , 8)),
				 3 => std_logic_vector(to_unsigned( 11 , 8)),
				 4 => std_logic_vector(to_unsigned( 42 , 8)),
				 5 => std_logic_vector(to_unsigned( 26 , 8)),
				 6 => std_logic_vector(to_unsigned( 27 , 8)),
				 7 => std_logic_vector(to_unsigned( 8 , 8)),
				 8 => std_logic_vector(to_unsigned( 66 , 8)),
				 9 => std_logic_vector(to_unsigned( 74 , 8)),
				 10 => std_logic_vector(to_unsigned( 202 , 8)),
				 11 => std_logic_vector(to_unsigned( 209 , 8)),
				 12 => std_logic_vector(to_unsigned( 238 , 8)),
				 13 => std_logic_vector(to_unsigned( 209 , 8)),
				 14 => std_logic_vector(to_unsigned( 238 , 8)),
				 15 => std_logic_vector(to_unsigned( 224 , 8)),
				 16 => std_logic_vector(to_unsigned( 223 , 8)),
				 17 => std_logic_vector(to_unsigned( 63 , 8)),
				 18 => std_logic_vector(to_unsigned( 128 , 8)),
			 others => (others =>'0'));

signal count: integer := 0;

component project_reti_logiche is
port (
		i_clk			: in std_logic;
		i_start			: in std_logic;
		i_rst			: in std_logic;
		i_data			: in std_logic_vector(7 downto 0);
		o_address		: out std_logic_vector(15 downto 0);
		o_done			: out std_logic;
		o_en			: out std_logic;
		o_we			: out std_logic;
		o_data			: out std_logic_vector (7 downto 0)
		);
end component project_reti_logiche;

begin
UUT: project_reti_logiche
port map (
			i_clk			=> tb_clk,
			i_start			=> tb_start,
			i_rst			=> tb_rst,
			i_data			=> mem_o_data,
			o_address		=> mem_address,
			o_done			=> tb_done,
			o_en			=> enable_wire,
			o_we			=> mem_we,
			o_data			=> mem_i_data
			);

p_CLK_GEN : process is
begin
	wait for c_CLOCK_PERIOD/2;
	tb_clk <= not tb_clk;
end process p_CLK_GEN;

MEM : process(tb_clk)
begin
	if tb_clk'event and tb_clk='1' then
		if enable_wire='1' then
			if mem_we='1' then
				RAM(conv_integer(mem_address)) <= mem_i_data;
				mem_o_data <= mem_i_data after 2 ns;
			else
				mem_o_data <= RAM(conv_integer(mem_address)) after 2 ns;
			end if;
		end if;
	end if;
end process;

test : process is
begin
	wait for 100 ns;
	wait for c_CLOCK_PERIOD;
	tb_rst <= '1';
	wait for c_CLOCK_PERIOD;
	tb_rst <= '0';
	wait for c_CLOCK_PERIOD;
	tb_start <= '1';
	wait for c_CLOCK_PERIOD;
	wait until tb_done = '1';
	wait for c_CLOCK_PERIOD;
	tb_start <= '0';
	wait until tb_done = '0';

	assert RAM(19) = std_logic_vector(to_unsigned( 16 , 8)) report "TEST FALLITO" severity failure;


assert false report "Simulation Ended!, TEST PASSATO" severity failure;
end process test;

end projecttb;



